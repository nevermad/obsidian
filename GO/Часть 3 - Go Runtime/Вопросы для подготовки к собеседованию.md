# Вопросы для подготовки к собеседованию: Часть 3 - Go Runtime

Этот список вопросов охватывает все темы из третьей части материалов и поможет подготовиться к собеседованию. Вопросы организованы по темам и расположены от базовых концепций к более сложным.

## Процессы и потоки ОС

1. В чем разница между процессом и потоком в операционной системе?
2. Что включает в себя адресное пространство процесса?
3. Какие ресурсы разделяют потоки внутри одного процесса, а какие имеют собственные?
4. Как работает планировщик ОС? Какие стратегии планирования существуют?
5. Что такое квант времени и прерывание таймера в контексте планирования?
6. Что представляет собой переключение контекста (context switching) и какова его стоимость?
7. Какие механизмы межпроцессного взаимодействия (IPC) существуют?
8. Как организована виртуальная память процессов?
9. Что такое потоки пользовательского уровня и потоки ядра? В чем их отличия?
10. Как связаны процессы и потоки ОС с моделью выполнения Go?

## Go Runtime. Составляющие части

1. Что такое Go Runtime и какие основные компоненты он включает?
2. Как Go Runtime абстрагирует работу с разными операционными системами?
3. Каким образом Go Runtime компилируется вместе с пользовательским кодом?
4. Какие возможности предоставляет пакет runtime в Go?
5. Какие подсистемы включает netpoller и как он оптимизирует ввод-вывод?
6. Как происходит инициализация Go Runtime при запуске программы?
7. Какие внутренние механизмы обеспечивают асинхронность в Go?
8. Как Go Runtime взаимодействует с системными вызовами ОС?
9. Как работает механизм CGO и почему он может быть менее эффективен?
10. Как эволюционировал Go Runtime в разных версиях языка?

## Go Scheduler

1. Что представляет собой модель GMP в планировщике Go?
2. Какую роль выполняет каждый из компонентов G, M и P?
3. Как соотносится количество P, M и G в типичной Go-программе?
4. Как работают локальные и глобальная очереди горутин?
5. Что такое "work stealing" в контексте планировщика Go?
6. Как планировщик Go обрабатывает блокирующие системные вызовы?
7. Как связаны переменная GOMAXPROCS и компонент P?
8. Что такое сетевой поллер (netpoller) и как он взаимодействует с планировщиком?
9. Какие эвристики использует планировщик для балансировки нагрузки?
10. Как реализовано вытеснение горутин? Как оно изменилось с версии Go 1.14?

## Горутины. Внутреннее устройство

1. Что такое горутина в Go и чем она отличается от потока ОС?
2. Как устроен стек горутины? Почему он может расти динамически?
3. Что такое "stack splitting" и как он работает?
4. Каков жизненный цикл горутины от создания до завершения?
5. Какие внутренние состояния может иметь горутина?
6. Что происходит при блокировке горутины на канале, мьютексе или I/O?
7. Как реализована передача параметров в горутину?
8. Что происходит с ресурсами горутины после её завершения?
9. Как устроен механизм переключения между горутинами?
10. Какие структуры данных используются для представления горутины в Go Runtime?

## Garbage Collector

1. Какой тип сборщика мусора используется в Go?
2. Что такое трехцветный маркировочно-очистной алгоритм?
3. Какие фазы включает в себя цикл сборки мусора в Go?
4. Что такое write barrier и зачем он нужен?
5. Как настраивается частота запуска сборщика мусора (GOGC)?
6. Что такое GOMEMLIMIT и как он влияет на работу GC?
7. Какие оптимизации реализованы в Go GC для минимизации пауз?
8. В чем отличие GC в Go от поколенческих сборщиков мусора?
9. Какие существуют инструменты для профилирования работы GC?
10. Какие стратегии можно применить в коде для снижения нагрузки на GC?

## Коммуникация и синхронизация горутин

1. Какие механизмы коммуникации и синхронизации горутин существуют в Go?
2. В чем суть принципа "share memory by communicating" в Go?
3. Какие типы каналов существуют и в чем их отличия?
4. Как устроены каналы внутренне (структура hchan)?
5. Что произойдет при различных операциях с nil, закрытым и обычным каналом?
6. Как работает конструкция select и как реализовано мультиплексирование каналов?
7. Какие примитивы синхронизации предоставляет пакет sync?
8. В каких случаях лучше использовать каналы, а в каких — мьютексы?
9. Как работает пакет context и для чего он используется?
10. Какие типичные ошибки и анти-паттерны существуют при синхронизации горутин?

## Продвинутые вопросы

1. Как можно оптимизировать работу с горутинами в высоконагруженных системах?
2. Какие компромиссы существуют при настройке GOGC и GOMEMLIMIT?
3. Как реализовать собственный планировщик задач поверх горутин?
4. Какие специфические проблемы возникают при профилировании Go-приложений?
5. Как оптимизировать взаимодействие между Go и C через CGO?
6. Какие низкоуровневые API предоставляет пакет runtime?
7. Как работают атомарные операции в Go и какие гарантии они предоставляют?
8. Как реализовать отказоустойчивую систему с использованием горутин и каналов?
9. Какие практики помогают уменьшить количество блокировок в высококонкурентных системах?
10. Как можно расширить возможности Go Runtime с помощью пользовательских библиотек?

## Связанные заметки

- [[Процессы и потоки ОС]]
- [[Go Runtime. Составляющие части Go Runtime]]
- [[Go Scheduler]]
- [[Горутины. Внутреннее устройство горутин]]
- [[Garbage Collector. Различные алгоритмы сборки мусора]]
- [[Коммуникация и синхронизация горутин]] 