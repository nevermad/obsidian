# Garbage Collector. Различные алгоритмы сборки мусора

## Краткий обзор

Сборщик мусора (Garbage Collector, GC) в Go — это неперемещающий, параллельный, трехцветный маркировочно-очистной (mark and sweep) сборщик с малыми паузами (low-latency). Современный GC в Go оптимизирован для минимального прерывания работы программы, используя параллельную маркировку и конкурентную очистку. Go GC основан на идее компромисса между пропускной способностью и использованием памяти, позволяя приложениям потреблять больше памяти в обмен на меньшее влияние на производительность. Помимо алгоритма в Go, существуют и другие подходы к сборке мусора: подсчет ссылок, копирующая сборка, поколенческая сборка и др., каждый со своими преимуществами и недостатками.

## Подробный разбор

### Основы управления памятью

Управление памятью — ключевой аспект любого языка программирования:

1. **Ручное управление памятью** (C, C++):
   - Явное выделение и освобождение памяти
   - Программист полностью контролирует жизненный цикл объектов
   - Подвержено ошибкам: утечки памяти, обращение к освобожденной памяти, фрагментация

2. **Автоматическое управление памятью** (Go, Java, C#, Python):
   - Среда выполнения автоматически определяет, когда объекты больше не используются
   - Освобождает разработчика от явного управления памятью
   - Может влиять на производительность (паузы, накладные расходы)

3. **Основные понятия**:
   - **Куча (Heap)** — область памяти для динамического выделения
   - **Живые объекты** — объекты, доступные из корней (глобальные переменные, стек)
   - **Мусор** — объекты в куче, которые больше не достижимы из корней
   - **Фрагментация** — неэффективное использование памяти из-за «дыр» между выделенными блоками

### Алгоритмы сборки мусора

#### 1. Подсчет ссылок (Reference Counting)

Принцип: каждый объект содержит счетчик, указывающий количество ссылок на него.

1. **Механизм работы**:
   - При создании новой ссылки на объект счетчик увеличивается
   - При удалении ссылки счетчик уменьшается
   - Когда счетчик достигает нуля, объект освобождается

2. **Преимущества**:
   - Сборка мусора происходит немедленно (нет паузы)
   - Предсказуемое использование ресурсов
   - Хорошо работает с детерминированными шаблонами использования

3. **Недостатки**:
   - Не справляется с циклическими ссылками (требуются дополнительные механизмы)
   - Накладные расходы на обновление счетчиков
   - Потенциальные проблемы с многопоточностью (атомарные операции)

4. **Примеры использования**:
   - Objective-C, Swift, Python (с дополнительным обнаружением циклов)
   - Rust (ownership model)
   - Компоненты COM в Windows

#### 2. Маркировочно-очистной алгоритм (Mark and Sweep)

Принцип: в две фазы определяет достижимые объекты и освобождает недостижимые.

1. **Фаза маркировки (Mark)**:
   - Начиная с корней (глобальные переменные, стек), обходит граф объектов
   - Помечает каждый посещенный объект как достижимый

2. **Фаза очистки (Sweep)**:
   - Проходит по всем объектам в куче
   - Освобождает непомеченные объекты

3. **Преимущества**:
   - Корректно обрабатывает циклические ссылки
   - Не требует дополнительной работы при обычных операциях с объектами

4. **Недостатки**:
   - Временно останавливает программу (stop-the-world pauses)
   - Неэффективен для больших куч (полное сканирование)
   - Может привести к фрагментации памяти

5. **Варианты реализации**:
   - Одновременный (Concurrent) — маркировка происходит одновременно с выполнением программы
   - Инкрементальный (Incremental) — процесс разбивается на короткие шаги
   - Параллельный (Parallel) — использует несколько потоков для ускорения

6. **Примеры использования**:
   - Ранние версии Java, JavaScript, Ruby
   - Go (с улучшениями для конкурентности)

#### 3. Копирующая сборка (Copying/Scavenging)

Принцип: перемещает живые объекты из одной области памяти в другую, освобождая первую область.

1. **Механизм работы**:
   - Память разделена на две части: "От-пространство" (From-space) и "К-пространству" (To-space)
   - Живые объекты копируются из "От-пространства" в "К-пространство"
   - После копирования всех живых объектов, "От-пространство" полностью очищается
   - Роли пространств меняются для следующего цикла сборки

2. **Преимущества**:
   - Очень эффективное использование памяти (нет фрагментации)
   - Аллокация очень быстрая (просто смещение указателя)
   - Время сборки пропорционально количеству живых объектов, а не размеру кучи

3. **Недостатки**:
   - Требует вдвое больше памяти
   - Перемещение объектов может быть дорогим
   - Все ссылки на перемещенные объекты должны быть обновлены

4. **Примеры использования**:
   - Scheme, ML, Haskell
   - JVM (для молодого поколения)
   - .NET CLR (в некоторых режимах)

#### 4. Поколенческая сборка (Generational)

Принцип: разделение объектов по возрасту с разной частотой сборки для разных поколений.

1. **Основная идея**:
   - "Гипотеза слабого поколения": большинство объектов живут короткое время
   - Новые объекты размещаются в "молодом поколении" (Young Generation, Nursery)
   - Выжившие объекты после нескольких сборок перемещаются в "старое поколение" (Old Generation)
   - Сборка мусора в молодом поколении происходит чаще, но быстрее

2. **Структура поколений**:
   - Eden Space — для новых объектов
   - Survivor Spaces (S0, S1) — для выживших молодых объектов
   - Tenured/Old Generation — для долгоживущих объектов
   - Permanent/Metaspace — для метаданных классов (в некоторых реализациях)

3. **Преимущества**:
   - Меньшие паузы для большинства сборок
   - Более эффективное использование времени CPU
   - Лучшая локальность кэша для новых объектов

4. **Недостатки**:
   - Сложная реализация
   - Полные (major) сборки все еще могут вызывать значительные паузы
   - Требуется отслеживание ссылок между поколениями (write barriers)

5. **Примеры использования**:
   - Java HotSpot VM
   - .NET CLR
   - V8 JavaScript Engine

#### 5. Инкрементальная и конкурентная сборка

Техники для минимизации пауз при сборке мусора:

1. **Инкрементальная сборка**:
   - Разбивает процесс сборки на маленькие шаги
   - Чередует сборку и выполнение программы
   - Более равномерное распределение нагрузки, но большие накладные расходы

2. **Конкурентная сборка**:
   - Выполняет сборку одновременно с работой программы
   - Требует синхронизации между сборщиком и мутаторами (программа)
   - Использует барьеры записи (write barriers) для отслеживания изменений

3. **Параллельная сборка**:
   - Использует несколько потоков для сборки мусора
   - Ускоряет сборку, но не обязательно уменьшает паузы
   - Часто комбинируется с конкурентными техниками

### Сборщик мусора в Go

#### 1. Эволюция GC в Go

1. **Go 1.0 (2012)** — Стоп-мир (stop-the-world) маркировочно-очистной сборщик
2. **Go 1.3 (2014)** — Параллельная маркировка и очистка
3. **Go 1.5 (2015)** — Трехцветный параллельный сборщик с низкой латентностью
4. **Go 1.6-1.7 (2016)** — Улучшения производительности, уменьшение пауз
5. **Go 1.8 (2017)** — Гибридная барьерная модель, ускорение очистки
6. **Go 1.9-1.10 (2018)** — Улучшения в планировании и производительности
7. **Go 1.12-1.14 (2019-2020)** — Оптимизации для больших куч
8. **Go 1.16-1.18 (2021-2022)** — Улучшения сканирования стека и эффективности
9. **Go 1.19+ (2022+)** — Soft memory limit, более гибкая настройка

#### 2. Трехцветный алгоритм в Go

Основа текущего сборщика мусора в Go:

1. **Цветовая маркировка**:
   - **Белые объекты**: потенциальный мусор, еще не посещенные
   - **Серые объекты**: живые, но их исходящие ссылки еще не просканированы
   - **Черные объекты**: живые объекты, все их исходящие ссылки обработаны
   - Go GC использует гибридный write barrier (Dijkstra + Yuasa), что позволяет минимизировать паузы и поддерживать инвариант трехцветности.

2. **Фазы трехцветного алгоритма**:
   - Начало: все объекты белые
   - Маркировка корневых объектов как серые
   - Итеративное сканирование серых объектов, переводя их в черные и находя новые серые
   - Конец маркировки: остались только черные (живые) и белые (мусор) объекты
   - Очистка: освобождение всех белых объектов
   - Sweep-фаза выполняется инкрементально и может продолжаться после завершения mark-фазы.

3. **Инвариант трехцветности** — условие корректной работы:
   - Черные объекты никогда не должны указывать на белые объекты
   - Поддерживается через барьеры записи (write barriers)

#### 3. Реализация GC в Go

1. **Архитектура**:
   - Неперемещающий (non-moving): объекты не перемещаются в памяти
   - Конкурентный (concurrent): выполняется параллельно с программой
   - Параллельный (parallel): использует несколько потоков
   - Трехцветный (tri-color) маркировочно-очистной (mark-sweep)

2. **Фазы GC в деталях**:
   - **Mark Setup**: Stop-the-world (STW) фаза, подготовка к маркировке
   - **Marking**: конкурентная фаза маркировки (с write barriers)
   - **Mark Termination**: STW фаза, завершение маркировки
   - **Sweeping**: конкурентная фаза очистки, выполняется по мере аллокации

3. **Барьеры записи (Write Barriers)**:
   - Гибридный барьер (Hybrid Write Barrier) с Go 1.8
   - Отслеживает записи указателей из черных объектов в белые
   - Сильно упрощенно: `если объект A черный и записываем указатель в нем на белый объект B, то B становится серым`

4. **Управление GC**:
   - `GOGC` — процент дополнительной выделяемой памяти перед запуском GC
      - По умолчанию 100%: GC запускается, когда куча вырастает вдвое
      - Значение 200% — запуск GC, когда куча втрое больше живых данных
      - Значение off — отключает автоматический GC (только явные вызовы)
   - `GOMEMLIMIT` (с Go 1.19) — мягкое ограничение общего использования памяти
   - `runtime.GC()` — явный запуск сборки мусора
   - `runtime/debug.SetGCPercent()` — динамическое изменение GOGC
   - `runtime/debug.FreeOSMemory()` — принудительный возврат памяти в ОС
   - GOGC регулирует не только частоту, но и целевой размер кучи относительно живых данных.

5. **Ассистенты GC (GC Assists)**:
   - Механизм, заставляющий горутины, активно выделяющие память, помогать в маркировке
   - Замедляет горутины, которые выделяют много памяти
   - Обеспечивает справедливое распределение работы по сборке мусора

#### 4. Особенности и оптимизации GC в Go

1. **Целевые показатели**:
   - Минимизация пауз (обычно <1ms)
   - Компромисс: использование большего объема памяти для снижения CPU-overhead
   - Оптимизация для серверных приложений с высокой конкурентностью

2. **Оптимизации**:
   - Карта битов (bitmap) для отслеживания указателей в стеке
   - Сканирование стека по блокам для сокращения STW-пауз
   - Специализированный аллокатор для объектов без указателей
   - Возврат неиспользуемой памяти в ОС
   - Go активно использует bitmap для отслеживания указателей в стеке и куче, что ускоряет сканирование.

3. **Стратегии минимизации GC-пауз**:
   - Уменьшение количества выделяемых объектов (пулы, предвыделение)
   - Повторное использование объектов
   - Компактные структуры данных
   - Использование стека вместо кучи (escape analysis)
   - Правильный подбор GOGC для конкретного приложения

### Другие подходы и сравнение алгоритмов

#### 1. Особые реализации GC

1. **Бурнхофа и Демерса (Boehn-Demers-Weiser)**:
   - Консервативный сборщик мусора для C/C++
   - Все значения, похожие на указатели, считаются указателями
   - Используется в библиотеках GC для C/C++

2. **Incremental Update vs. Snapshot at the Beginning**:
   - Две основные стратегии для трехцветной маркировки
   - Incremental Update: отслеживает новые указатели на белые объекты (как в Go)
   - Snapshot at the Beginning: сохраняет начальное состояние объектов

3. **Реактивные сборщики (Azul C4)**:
   - Сборка с компактификацией без пауз
   - Используют виртуальную память для перемещения объектов
   - Высокопроизводительные, но требуют специальной поддержки ОС

#### 2. Сравнительная таблица алгоритмов GC

| Алгоритм | Паузы | Использование памяти | Накладные расходы CPU | Сложность реализации | Примеры языков |
|----------|-------|---------------------|----------------------|---------------------|----------------|
| Подсчет ссылок | Минимальные, распределенные | Низкое | Высокие | Средняя | Swift, Python, PHP |
| Маркировочно-очистной | Может быть длительными | Среднее | Низкие/Средние | Низкая/Средняя | Go, JavaScript |
| Копирующий | Длительные, но предсказуемые | Высокое (2x) | Средние/Высокие | Средняя | Lisp, ML |
| Поколенческий | Короткие с редкими длинными | Среднее/Высокое | Средние | Высокая | Java, .NET, V8 |
| Инкрементальный | Очень короткие | Среднее/Высокое | Высокие | Высокая | Modern JVMs, .NET |
| Конкурентный | Очень короткие | Высокое | Очень высокие | Очень высокая | Go, Java G1, ZGC |

#### 3. Выбор подходящего алгоритма

Факторы, влияющие на выбор алгоритма сборки мусора:

1. **Характеристики приложения**:
   - Интерактивные — требуют минимальных пауз
   - Пакетные — могут допускать длинные паузы в обмен на высокую пропускную способность
   - Memory-bound — эффективность использования памяти
   - CPU-bound — минимизация накладных расходов процессора

2. **Паттерны аллокации**:
   - Короткоживущие объекты — поколенческий GC
   - Долгоживущие, стабильные объекты — маркировочно-очистной
   - Частое создание/уничтожение — подсчет ссылок или копирующий

3. **Требования к производительности**:
   - Предсказуемые паузы vs общая пропускная способность
   - Использование памяти vs время выполнения
   - Масштабируемость на многоядерных системах

### Профилирование и оптимизация GC в Go

#### 1. Профилирование

1. **Инструменты**:
   - `GODEBUG=gctrace=1` — вывод информации о каждом цикле GC
   - `go tool pprof` — профилирование аллокаций и времени сборки мусора
   - `go tool trace` — трассировка исполнения с информацией о GC
   - `runtime/debug.ReadGCStats()` — сбор статистики GC в программе

2. **Метрики GC**:
   - Частота запусков GC
   - Продолжительность пауз
   - Общее время, проведенное в GC
   - Размер кучи и процент использования
   - Количество выделений и освобождений памяти

#### 2. Оптимизация

1. **Уменьшение аллокаций**:
   - Переиспользование объектов через пулы
   - Использование `sync.Pool` для временных объектов
   - Избегание ненужных аллокаций в циклах

2. **Оптимизация структур данных**:
   - Компактное представление данных
   - Минимизация указателей в структурах
   - Использование слайсов вместо связанных списков

3. **Настройка GC**:
   - Подбор оптимального значения GOGC
   - Использование GOMEMLIMIT для контроля общего использования памяти
   - Стратегическое размещение явных вызовов `runtime.GC()`

4. **Стратегии для больших приложений**:
   - Sharding данных для уменьшения размера рабочего набора
   - Периодическое перезапуск/замена горутин с большими стеками
   - Минимизация глобальных переменных

## Связанные темы

[[Go Runtime. Составляющие части Go Runtime]]
[[Go Scheduler]]
[[Горутины. Внутреннее устройство горутин]]
[[Куча и стек. Escape Analysis]]
[[Пакет builtin. Операции new и make]]

## Источники

1. [The Go Memory Model](https://golang.org/ref/mem)
2. [Go Blog: Garbage Collection Semantics](https://blog.golang.org/ismmkeynote)
3. [Getting to Go: The Journey of Go's Garbage Collector](https://blog.golang.org/ismmkeynote)
4. [Go under the hood: GC Design and Implementation](https://go.dev/src/runtime/mgc.go)
5. [Go GC: Prioritizing low latency and simplicity](https://blog.golang.org/go15gc)
6. [The Garbage Collection Handbook](https://gchandbook.org/) - Richard Jones, Antony Hosking, Eliot Moss
7. [Visualizing memory management in Golang](https://deepu.tech/memory-management-in-golang/)
8. [Go's Garbage Collector](https://medium.com/safetycultureengineering/go-s-garbage-collector-a-guide-for-the-perplexed-92cad292c4a8)
9. [Modern Garbage Collection](https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e)
10. [Golang's Real-time GC in Theory and Practice](https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/)
