# Go Scheduler

## Краткий обзор

Go Scheduler — это компонент Go Runtime, который управляет выполнением горутин на потоках операционной системы. Он реализует модель M:N, где множество горутин (G) выполняются на меньшем количестве потоков ОС (M), используя абстракцию процессоров (P). Планировщик Go обеспечивает эффективное распределение ресурсов, балансировку нагрузки через "work stealing", неблокирующее I/O и масштабируемость. В отличие от планировщиков ОС, планировщик Go работает в пользовательском пространстве, что позволяет оптимизировать переключение контекста и уменьшить накладные расходы.

## Подробный разбор

### Модель GMP

Основа планировщика Go — трехкомпонентная модель GMP:

1. **G (Goroutine)**:
   - Горутина — легковесный поток выполнения
   - Представляет собой функцию с собственным стеком (изначально 2KB, может расти до 1GB)
   - Хранит состояние выполнения (PC, регистры, стек)
   - Может находиться в разных состояниях: выполнение, ожидание, готовность

2. **M (Machine)**:
   - Поток ОС (OS Thread), управляемый операционной системой
   - Всегда привязан к конкретному ядру процессора
   - Количество M обычно ограничено (по умолчанию = GOMAXPROCS + некоторое количество для блокирующих операций), но может быть больше, если есть блокирующие системные вызовы или cgo. M выделяются динамически по мере необходимости.
   - M может выполнять G только при наличии P

3. **P (Processor)**:
   - Контекст исполнения, ресурс для выполнения горутин
   - Абстракция логического процессора
   - Количество P определяется переменной GOMAXPROCS (по умолчанию = количество ядер CPU)
   - Имеет локальную очередь задач (runqueue) для выполнения горутин

### Внутренняя структура планировщика

#### Структуры данных

1. **Локальная очередь P (P's Local Queue)**:
   - Содержит горутины, готовые к выполнению
   - Ограниченный размер (256 горутин)
   - Работает по принципу FIFO (первым пришел, первым обслужен)
   - Доступ без блокировок (lockless) для привязанного M

2. **Глобальная очередь (Global Queue)**:
   - Содержит горутины, которые не поместились в локальные очереди
   - Используется, когда локальная очередь переполнена или для балансировки
   - Требует блокировок для доступа

3. **Idle M и P списки**:
   - Списки неактивных M и P, готовых к работе
   - Используются при создании новых горутин или разблокировке существующих

4. **Структура G**:

   ```go
   type g struct {
       stack       stack      // Стек горутины
       stackguard0 uintptr    // Защита для проверки переполнения стека
       stackguard1 uintptr
       
       _panic      *_panic    // Активная паника, если есть
       _defer      *_defer    // Отложенные вызовы
       
       m           *m         // Текущий M (если выполняется)
       sched       gobuf      // Состояние для сохранения/восстановления
       
       atomicstatus uint32    // Статус горутины
       goid        int64      // ID горутины
       
       // Прочие поля...
   }
   ```

5. **Структура M**:

   ```go
   type m struct {
       g0         *g          // Системная горутина для M
       curg       *g          // Текущая выполняемая горутина
       p          puintptr    // Привязанный P
       nextp      puintptr    // Следующий P для этого M
       id         int64       // ID потока
       
       spinning   bool        // Поиск работы
       blocked    bool        // В блокировке
       
       // Прочие поля...
   }
   ```

6. **Структура P**:

   ```go
   type p struct {
       id          int32      // ID процессора
       status      uint32     // Статус P
       
       m           muintptr   // Привязанный M
       runqhead    uint32     // Начало очереди готовых горутин
       runqtail    uint32     // Конец очереди
       runq        [256]guintptr // Очередь готовых горутин
       
       runnext     guintptr   // Следующая горутина на выполнение
       
       // Кэш аллокаций и другие структуры
   }
   ```

### Алгоритмы планирования

#### 1. Запуск новой горутины

Когда создается новая горутина через `go func()`:

1. Новая G размещается в памяти (выделяется стек и инициализируются поля)
2. G помещается в локальную очередь текущего P
3. Если локальная очередь заполнена, половина горутин перемещается в глобальную очередь (глобальная очередь используется для балансировки и при старте новых горутин)
4. Если горутина имеет атрибут `GOMAXPROCS`, она может вытеснить текущую горутину

#### 2. Work Stealing (Кража работы)

Алгоритм балансировки нагрузки:

1. Когда P исчерпывает свою локальную очередь:
   - Проверяет глобальную очередь (каждые 61 раз)
   - Проверяет runnable netpoll (каждые 61 раз)
   - Случайным образом выбирает другой P и пытается украсть половину его горутин (кража работы происходит только между локальными очередями P)

2. Порядок поиска работы:
   - Проверка локальной очереди
   - Проверка глобальной очереди (с определенной вероятностью)
   - Проверка сетевых событий (с определенной вероятностью)
   - Кража работы у других P

#### 3. Обработка блокирующих операций

Когда горутина выполняет блокирующую операцию:

1. **Системные вызовы**:
   - При входе в системный вызов M отсоединяется от P
   - P может быть передан другому M для выполнения других горутин
   - После завершения системного вызова M пытается получить P обратно
   - Если это невозможно, G помещается в глобальную очередь, а M переходит в режим ожидания

2. **Блокировки в пользовательском пространстве** (мьютексы, каналы):
   - G переходит в состояние ожидания и освобождает M
   - M продолжает выполнять другие горутины из очереди P
   - Когда блокировка снимается, G помещается обратно в очередь P

3. **Сетевые операции**:
   - Используется netpoller для неблокирующего I/O
   - G парковка до завершения I/O операции
   - M выполняет другие горутины
   - Когда операция завершена, G помещается обратно в очередь

#### 4. Вытеснение (Preemption)

Механизмы вытеснения горутин:

1. **Кооперативное вытеснение** (до Go 1.14):
   - В точках проверки переполнения стека
   - После определенного количества вызовов функций (функция `sysmon` помечает G как вытесняемую)

2. **Асинхронное вытеснение** (с Go 1.14):
   - Использует сигналы ОС (SIGURG) для прерывания выполнения
   - Позволяет вытеснять долго выполняющиеся горутины, не достигшие точек проверки
   - Асинхронное вытеснение работает только на поддерживаемых архитектурах и может быть отключено через переменные окружения

### Функция sysmon

Фоновый поток `sysmon` выполняет мониторинг и обслуживание:

1. **Обязанности**:
   - Вытеснение долго выполняющихся горутин (>10ms)
   - Проверка состояния netpoller
   - Возврат неиспользуемой памяти в ОС
   - Запуск сборщика мусора, если необходимо
   - Поиск "спящих" P и их активация
   - Мониторинг deadlock-ситуаций

2. **Частота работы**:
   - Начинает с 20мкс и постепенно увеличивается до 10мс
   - Не использует P для работы (выполняется на выделенном M)

### Инициализация и завершение

1. **Инициализация планировщика**:
   - Создание начального набора P (GOMAXPROCS)
   - Инициализация глобальных очередей
   - Запуск фонового потока sysmon
   - Создание первоначального M для выполнения main

2. **Завершение планировщика**:
   - Завершение всех горутин
   - Ожидание завершения блокирующих операций
   - Освобождение ресурсов

### Настройка и оптимизация

1. **GOMAXPROCS**:
   - Контролирует количество P (логических процессоров)
   - Устанавливается через переменную окружения или через API `runtime.GOMAXPROCS()`
   - По умолчанию равно количеству логических CPU
   - Увеличение GOMAXPROCS не всегда приводит к лучшей производительности

2. **Блокирующие операции**:
   - Планировщик автоматически создает новые потоки M при необходимости
   - Максимальное количество потоков M ограничено (по умолчанию 10000)
   - Избыточные блокирующие операции могут привести к израсходованию всех M

3. **I/O-связанные приложения**:
   - Планировщик оптимизирован для высокой конкурентности
   - Netpoller обеспечивает эффективное мультиплексирование I/O
   - Блокирующие I/O операции в Cgo могут негативно влиять на производительность

### Особенности и нюансы

1. **Локальность выполнения**:
   - Горутины стремятся выполняться на том же P и M для лучшей локальности кэша
   - Нет гарантий точного порядка выполнения между горутинами

2. **Справедливость**:
   - Планировщик не гарантирует справедливое выделение времени CPU между горутинами
   - Горутины с интенсивным CPU-использованием могут получать больше времени

3. **Диагностика планировщика**:
   - Трассировка планировщика через `GODEBUG=schedtrace=1000,scheddetail=1`
   - Профилирование блокировок через `go tool pprof -mutex`
   - Трассировка исполнения через `go tool trace`

### Эволюция планировщика

1. **Go 1.0-1.1**: Глобальная очередь с блокировками для всех горутин, модель GM
2. **Go 1.1**: Введение локальных очередей, предшественник модели GMP
3. **Go 1.2-1.4**: Полная реализация модели GMP, улучшение work stealing
4. **Go 1.5-1.6**: Оптимизация процесса сетевого ввода-вывода
5. **Go 1.7-1.9**: Улучшение масштабируемости и локальности кэша
6. **Go 1.10-1.13**: Оптимизация для выполнения на NUMA-системах
7. **Go 1.14**: Асинхронное вытеснение горутин через сигналы ОС
8. **Go 1.15-1.18**: Улучшение работы с симметричными мультипроцессорными системами
9. **Go 1.19+**: Оптимизация работы со спящими P и M

## Связанные темы

[[Процессы и потоки ОС]]
[[Go Runtime. Составляющие части Go Runtime]]
[[Горутины. Внутреннее устройство горутин]]
[[Коммуникация и синхронизация горутин]]
[[Garbage Collector. Различные алгоритмы сборки мусора]]

## Источники

1. [Go Scheduler: MS, PS & GS](https://povilasv.me/go-scheduler/)
2. [Scheduling in Go - Part I](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
3. [Scheduling in Go - Part II](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html)
4. [Scheduling in Go - Part III](https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html)
5. [Go's work-stealing scheduler](https://rakyll.org/scheduler/)
6. [Analysis of the Go runtime scheduler](https://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf)
7. [Go: asynchronous preemption](https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c)
8. [The Go scheduler](https://morsmachine.dk/go-scheduler)
9. [Go GMP модель планировщика](https://dev.to/furdarius/go-gmp-model-planirovsika-na-100-strok-2mne) (на русском)
10. [Golang 源码剖析: GMP 调度器](https://github.com/golang-design/under-the-hood/tree/master/book/zh-cn/part2runtime/ch06sched)
