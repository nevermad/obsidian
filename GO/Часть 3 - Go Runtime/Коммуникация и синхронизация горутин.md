# Коммуникация и синхронизация горутин

## Краткий обзор

В Go существует несколько механизмов коммуникации и синхронизации горутин. Основным из них являются каналы (channels), реализующие принцип CSP (Communicating Sequential Processes), который позволяет горутинам обмениваться данными без использования общего состояния. Для ситуаций, требующих контроля доступа к общим ресурсам, Go предоставляет примитивы синхронизации в пакете `sync`: мьютексы, условные переменные, WaitGroup, Once и т.д. Также Go поддерживает атомарные операции для низкоуровневой синхронизации и пакет `context` для управления жизненным циклом горутин. Правильный выбор механизма синхронизации зависит от конкретной задачи, но общий принцип Go — "не общайтесь через разделяемую память; вместо этого разделяйте память через общение".

## Подробный разбор

### Принципы конкуретности в Go

Go построен вокруг двух основных принципов конкурентного программирования:

1. **"Share memory by communicating, don't communicate by sharing memory"** — делитесь памятью путем коммуникации, а не коммуницируйте через разделяемую память
2. **CSP (Communicating Sequential Processes)** — модель параллельных вычислений, основанная на обмене сообщениями

Эти принципы определяют подход Go к реализации параллельного выполнения кода и синхронизации горутин.

### Каналы (Channels)

Каналы — ключевой механизм синхронизации и коммуникации в Go:

#### 1. Основы каналов

1. **Определение**: Канал — это типизированный конвейер, через который можно отправлять и получать значения
2. **Создание**:

   ```go
   ch := make(chan int)        // Небуферизованный канал
   ch := make(chan string, 10) // Буферизованный канал с емкостью 10
   ```

3. **Операции**:

   ```go
   ch <- x    // Отправка значения x в канал ch
   x := <-ch  // Получение значения из канала ch
   x, ok := <-ch  // Получение с проверкой открытости канала
   close(ch)  // Закрытие канала
   ```

#### 2. Типы каналов

1. **Небуферизованные каналы**:
   - Синхронная коммуникация — отправитель блокируется до получения данных
   - Гарантирует, что отправка и получение происходят одновременно
   - Используются как механизм синхронизации

2. **Буферизованные каналы**:
   - Асинхронная коммуникация до заполнения буфера
   - Отправка блокируется только при заполненном буфере
   - Получение блокируется только при пустом буфере
   - Ёмкость определяется при создании

3. **Однонаправленные каналы**:

   ```go
   var sendOnly chan<- int    // Только для отправки
   var receiveOnly <-chan int // Только для получения
   ```

   - Усиление типобезопасности
   - Явное указание намерений

#### 3. Поведение каналов

1. **Отправка**:
   - В открытый канал: нормальная операция
   - В закрытый канал: вызывает панику
   - В nil-канал: блокирует навсегда

2. **Получение**:
   - Из открытого канала: нормальная операция
   - Из закрытого канала: возвращает нулевое значение и `ok=false`
   - Из nil-канала: блокирует навсегда

3. **Закрытие**:
   - Указывает, что больше значений не будет отправлено
   - Получатели могут определить, закрыт ли канал
   - Закрытие закрытого канала вызывает панику
   - Закрытие nil-канала вызывает панику

#### 4. Внутреннее устройство каналов

Канал в Go реализован как структура `hchan`:

```go
type hchan struct {
    qcount   uint           // Количество элементов в буфере
    dataqsiz uint           // Размер буфера
    buf      unsafe.Pointer // Указатель на буфер (кольцевой массив)
    elemsize uint16         // Размер элемента
    closed   uint32         // Флаг закрытости
    elemtype *_type         // Тип элементов
    sendx    uint           // Индекс отправки в буфере
    recvx    uint           // Индекс получения из буфера
    recvq    waitq          // Список горутин, ожидающих получения (двусвязный список)
    sendq    waitq          // Список горутин, ожидающих отправки (двусвязный список)
    lock     mutex          // Защищает все поля
}
```

Ключевые особенности:

- Кольцевой буфер для хранения данных
- Очереди заблокированных отправителей и получателей (двусвязные списки горутин)
- Mutex для защиты внутреннего состояния
- Метадата для управления типами и размерами

#### 5. Паттерны использования каналов

1. **Fan-Out/Fan-In**:
   - Распределение работы между множеством горутин
   - Сбор результатов из нескольких источников

2. **Pipeline**:
   - Последовательная обработка данных через цепочку горутин
   - Каждая стадия получает данные, обрабатывает и передает дальше

3. **Cancellation**:
   - Использование "done" канала для сигнализации о завершении
   - Позволяет избежать утечек горутин

4. **Timeout**:
   - Использование `time.After` и `select` для ограничения времени ожидания

   ```go
   select {
   case res := <-ch:
       // Используем результат
   case <-time.After(1 * time.Second):
       // Обработка тайм-аута
   }
   ```

5. **Rate limiting**:
   - Использование `time.Tick` для ограничения частоты операций

### Мультиплексирование с помощью select

Конструкция `select` — мощный механизм для работы с несколькими каналами:

#### 1. Базовый синтаксис

```go
select {
case x := <-ch1:
    // Обработка данных из ch1
case ch2 <- y:
    // Данные отправлены в ch2
case <-ch3:
    // Получены данные из ch3, но они не используются
default:
    // Выполняется, если все другие case блокируются
}
```

#### 2. Правила работы select

1. **Порядок проверки**:
   - Все каналы проверяются одновременно
   - Если несколько case готовы, выбирается один случайно
   - Если ни один case не готов, и нет default, блокируется до готовности любого канала
   - Если ни один case не готов, но есть default, выполняется default

2. **nil-каналы**:
   - Case с nil-каналом никогда не выбирается
   - Используется для динамического отключения каналов

3. **Пустой select**:

   ```go
   select {}
   ```

   - Блокирует горутину навсегда
   - Используется, когда горутина должна существовать, но не иметь активной работы

#### 3. Внутренняя реализация select

1. **Компиляция**:
   - Компилятор превращает `select` в сложный код с вызовами runtime
   - Случайный выбор реализуется перемешиванием порядка case (рандомизация предотвращает starvation, но не гарантирует абсолютную справедливость)

2. **Runtime функции**:
   - `selectgo`: основная функция для выполнения select
   - Блокировка и разблокировка всех каналов атомарно
   - Предотвращение состояния гонки при выборе case

#### 4. Распространенные паттерны с select

1. **Неблокирующие операции**:

   ```go
   select {
   case ch <- x:
       // Отправка удалась
   default:
       // Канал заблокирован, пропускаем отправку
   }
   ```

2. **Обработка сигналов завершения**:

   ```go
   select {
   case data := <-dataCh:
       // Обработка данных
   case <-doneCh:
       // Получен сигнал завершения
       return
   }
   ```

3. **Мультиплексирование нескольких источников**:

   ```go
   select {
   case v1 := <-ch1:
       // Обработка данных из ch1
   case v2 := <-ch2:
       // Обработка данных из ch2
   // ...и т.д.
   }
   ```

### Примитивы синхронизации в пакете sync

Для ситуаций, когда обмен данными через каналы не идеален, Go предоставляет традиционные примитивы синхронизации:

#### 1. Mutex (Взаимное исключение)

```go
var mu sync.Mutex

func safeOperation() {
    mu.Lock()
    defer mu.Unlock()
    // Критическая секция
}
```

**Внутреннее устройство**:

- Использует атомарные операции для быстрой проверки
- Семафор для блокировки и очереди ожидания
- Включает механизм обнаружения состояния гонки (в режиме race)

**Использование**:

- Защита доступа к разделяемым данным
- Обеспечение атомарности группы операций

#### 2. RWMutex (Mutex для чтения-записи)

```go
var rwmu sync.RWMutex

func readData() {
    rwmu.RLock()
    defer rwmu.RUnlock()
    // Чтение данных
}

func writeData() {
    rwmu.Lock()
    defer rwmu.Unlock()
    // Запись данных
}
```

**Особенности**:

- Позволяет параллельное чтение
- Запись требует эксклюзивного доступа
- Писатели имеют приоритет над читателями (для предотвращения голодания)

#### 3. WaitGroup

```go
var wg sync.WaitGroup

func main() {
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            // Работа
        }(i)
    }
    wg.Wait() // Блокировка до завершения всех горутин
}
```

**Внутреннее устройство**:

- Атомарный счетчик активных задач
- Семафор для ожидания обнуления счетчика
- Небольшая и эффективная структура

**Использование**:

- Ожидание завершения группы горутин
- Синхронизация потока выполнения
- wg.Add() всегда должен вызываться до запуска горутины, иначе возможна гонка

#### 4. Once

```go
var once sync.Once
var instance *Singleton

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

**Особенности**:

- Гарантирует, что функция будет вызвана только один раз, даже при конкурентном доступе
- Используется для ленивой инициализации
- Внутренне использует mutex и атомарные операции

#### 5. Cond (Условная переменная)

```go
var mu sync.Mutex
var cond = sync.NewCond(&mu)
var ready bool

func waiter() {
    mu.Lock()
    defer mu.Unlock()
    for !ready {
        cond.Wait() // Освобождает mu и блокируется; при пробуждении снова захватывает mu
    }
    // Продолжение работы
}

func broadcaster() {
    mu.Lock()
    ready = true
    mu.Unlock()
    cond.Broadcast() // или cond.Signal() для одной горутины
}
```

**Внутреннее устройство**:

- Список заблокированных горутин
- Мьютекс для защиты состояния
- Семафор для каждой ожидающей горутины

**Использование**:

- Сигнализация об изменении условия
- Ожидание определенного состояния
- Реализация producer-consumer шаблонов

#### 6. Pool

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

func processRequest() {
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf)
    // Использование буфера
}
```

**Особенности**:

- Пул временных объектов для снижения нагрузки на GC
- Нет гарантии доступности объекта после Put()
- GC может очистить неиспользуемые объекты из пула в любой момент, Pool не гарантирует сохранность объектов между GC-циклами

**Внутреннее устройство**:

- Локальные пулы для каждого P (процессора)
- Глобальный пул, используемый при локальном переполнении
- Механизм балансировки между локальными пулами

### Атомарные операции

Пакет `sync/atomic` предоставляет низкоуровневые атомарные операции:

```go
var counter int64

func increment() {
    atomic.AddInt64(&counter, 1)
}

func get() int64 {
    return atomic.LoadInt64(&counter)
}
```

#### 1. Доступные операции

- **Load**: Атомарное чтение значения
- **Store**: Атомарная запись значения
- **Add**: Атомарное сложение
- **Swap**: Атомарная замена с возвратом предыдущего значения
- **CompareAndSwap**: Атомарная замена, если текущее значение совпадает с ожидаемым

#### 2. Использование

- Счетчики без мьютексов
- Флаги и переключатели
- Реализация собственных структур данных без блокировок
- Базис для более сложных примитивов синхронизации

#### 3. Внутренняя реализация

- Использует специальные инструкции процессора для атомарности
- Обеспечивает барьеры памяти для корректной видимости изменений между потоками
- Архитектурно-специфичная реализация (разная для разных CPU)

### Пакет context для управления горутинами

Пакет `context` предоставляет способ управления жизненным циклом горутин:

```go
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            // Получен сигнал отмены
            return
        default:
            // Продолжаем работу
        }
        // ...
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    go worker(ctx)
    // ...
}
```

#### 1. Типы контекстов

- **Background**: Корневой контекст, никогда не отменяется
- **TODO**: Для мест, где контекст еще не определен
- **WithCancel**: Добавляет возможность отмены
- **WithTimeout**: Отменяется после указанного времени
- **WithDeadline**: Отменяется в указанное время
- **WithValue**: Хранит пары ключ-значение

#### 2. Внутреннее устройство

- Дерево связанных контекстов
- Каждый наследует свойства родителя и добавляет свои
- При отмене родителя отменяются все потомки
- Канал `Done()` закрывается при отмене
- Использует механизм блокировок для безопасного доступа

#### 3. Лучшие практики использования

- Передача контекста первым параметром функции
- Неизменяемость контекста (нельзя модифицировать существующий)
- Привязка к жизненному циклу запроса или операции
- Отделение данных запроса от данных приложения
- Избегание избыточного использования `WithValue`

### Сравнение и выбор механизмов синхронизации

#### 1. Каналы vs Мьютексы

**Каналы хороши для**:

- Передачи владения данными между горутинами
- Распределения работы
- Сигнализации между горутинами
- Реализации управляющей логики (таймауты, отмена)

**Мьютексы хороши для**:

- Защиты доступа к разделяемому состоянию
- Коротких критических секций
- Сложных структур данных с множественным доступом
- Кешей и пулов

#### 2. Правила выбора

1. **Используйте каналы, когда**:
   - Передаете данные между горутинами
   - Сигнализируете о событиях
   - Организуете конвейеры обработки
   - Реализуете шаблоны распределения задач

2. **Используйте sync примитивы, когда**:
   - Управляете доступом к общему состоянию
   - Требуется производительность для коротких операций
   - Реализуете сложные структуры данных
   - Нужна более тонкая настройка доступа

3. **Используйте context, когда**:
   - Управляете жизненным циклом горутин
   - Передаете сигналы отмены
   - Устанавливаете таймауты и дедлайны
   - Передаете запрос-специфичные значения

#### 3. Производительность различных механизмов

| Механизм | Затраты на создание | Затраты на использование | Масштабируемость |
|----------|---------------------|--------------------------|------------------|
| Каналы | Средние | Низкие-Средние | Высокая |
| Mutex | Очень низкие | Низкие | Средняя |
| RWMutex | Низкие | Низкие (чтение), Средние (запись) | Высокая для чтения |
| Атомарные операции | - | Очень низкие | Высокая |
| WaitGroup | Очень низкие | Очень низкие | Высокая |
| Cond | Низкие | Средние | Средняя |
| Context | Низкие | Очень низкие | Высокая |

### Частые ошибки и анти-паттерны

#### 1. Утечки горутин

```go
// Неправильно - горутина может никогда не завершиться
go func() {
    for {
        select {
        case data := <-dataCh:
            process(data)
        }
    }
}()

// Правильно - добавлен механизм отмены
go func() {
    for {
        select {
        case data := <-dataCh:
            process(data)
        case <-ctx.Done():
            return
        }
    }
}()
```

#### 2. Разделяемое состояние без синхронизации

```go
// Неправильно - состояние гонки
var counter int
func increment() {
    counter++ // Небезопасно в конкурентном доступе
}

// Правильно - с mutex
var (
    counter int
    mu sync.Mutex
)
func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// Альтернатива - атомарная операция
var counter int64
func increment() {
    atomic.AddInt64(&counter, 1)
}

// Другая альтернатива - каналы
var counterCh = make(chan int)
go func() {
    counter := 0
    for {
        select {
        case <-incrementCh:
            counter++
        case counterCh <- counter:
            // Отправка текущего значения
        }
    }
}()
```

#### 3. Направление закрытия каналов

```go
// Неправильно - получатель закрывает канал
func receiver(ch chan int) {
    for x := range ch {
        // ...
    }
    close(ch) // Опасно, может вызвать панику
}

// Правильно - отправитель закрывает канал
func sender(ch chan int, count int) {
    for i := 0; i < count; i++ {
        ch <- i
    }
    close(ch) // Безопасно, т.к. только один отправитель
}
```

#### 4. Неправильное использование WaitGroup

```go
// Неправильно - возможна гонка на wg.Add
func processAll(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        go func(i Item) {
            wg.Add(1) // Опасно - Add после запуска горутины
            defer wg.Done()
            // ...
        }(item)
    }
    wg.Wait() // Может завершиться до того, как все горутины добавятся
}

// Правильно - wg.Add перед запуском горутины
func processAll(items []Item) {
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(i Item) {
            defer wg.Done()
            // ...
        }(item)
    }
    wg.Wait()
}
```

#### 5. Блокировки и взаимоблокировки

```go
// Неправильно - потенциальная взаимоблокировка
func transfer(from, to *Account, amount int) {
    from.mu.Lock()
    to.mu.Lock()
    defer from.mu.Unlock()
    defer to.mu.Unlock()
    // ...
}

// Правильно - предотвращение взаимоблокировки через порядок блокировки
func transfer(from, to *Account, amount int) {
    // Блокировка в определенном порядке
    if from.id < to.id {
        from.mu.Lock()
        to.mu.Lock()
    } else {
        to.mu.Lock()
        from.mu.Lock()
    }
    defer from.mu.Unlock()
    defer to.mu.Unlock()
    // ...
}
```

## Связанные темы

[[Горутины. Внутреннее устройство горутин]]
[[Go Scheduler]]
[[Go Runtime. Составляющие части Go Runtime]]
[[Процессы и потоки ОС]]
[[Контексты. Работа с контекстами]]

## Источники

1. [The Go Programming Language Specification](https://golang.org/ref/spec)
2. [Effective Go](https://golang.org/doc/effective_go.html#concurrency)
3. [Go Concurrency Patterns](https://blog.golang.org/pipelines)
4. [Advanced Go Concurrency Patterns](https://blog.golang.org/advanced-go-concurrency-patterns)
5. [Go Blog: Share Memory By Communicating](https://blog.golang.org/share-memory-by-communicating)
6. [Go Memory Model](https://golang.org/ref/mem)
7. [Channel internal implementation in Go](https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268)
8. [Go source code: src/runtime/chan.go](https://github.com/golang/go/blob/master/src/runtime/chan.go)
9. [Golang Mutex vs Channels](https://github.com/golang/go/wiki/MutexOrChannel)
10. [Context package - Go standard library](https://golang.org/pkg/context/)
