# Go Runtime. Составляющие части Go Runtime

## Краткий обзор

Go Runtime — это набор библиотек и подсистем, встраиваемых в каждую Go-программу, который обеспечивает управление горутинами, сборку мусора, планирование выполнения и другие низкоуровневые функции. Основные компоненты включают: планировщик горутин (scheduler), систему сборки мусора (garbage collector), управление памятью (memory allocator), поддержку сетевых операций и системных вызовов через netpoller. Go Runtime позволяет абстрагироваться от деталей реализации операционной системы и обеспечивает эффективное использование ресурсов для конкурентных программ.

## Подробный разбор

### Общий обзор Go Runtime

Go Runtime — это слой между Go-программой и операционной системой, который обеспечивает:

1. **Абстракцию от ОС** — унифицированный интерфейс для работы с различными операционными системами
2. **Управление ресурсами** — эффективное использование памяти и процессорного времени
3. **Конкурентность** — поддержка легковесных горутин и каналов
4. **Автоматическое управление памятью** — через сборщик мусора

Go Runtime компилируется вместе с пользовательским кодом в единый бинарный файл, что устраняет необходимость в дополнительных зависимостях для выполнения программы.

### Основные компоненты Go Runtime

#### 1. Планировщик (Scheduler)

Планировщик Go отвечает за распределение горутин по доступным потокам ОС:

1. **Модель GMP**:
   - G (Goroutine) — горутина, легковесный поток выполнения
   - M (Machine) — поток ОС, который может выполнять горутины. Количество M не ограничено GOMAXPROCS, M выделяются динамически по мере необходимости (например, для блокирующих вызовов или cgo).
   - P (Processor) — абстракция, связывающая G и M, предоставляет контекст выполнения. Количество P ограничено GOMAXPROCS.

2. **Основные функции**:
   - Планирование горутин на доступные потоки
   - Балансировка нагрузки между потоками
   - Обработка блокирующих операций
   - Управление параллелизмом (через GOMAXPROCS)

3. **Особенности планировщика**:
   - Кооперативная многозадачность с возможностью вытеснения
   - Планирование в пользовательском пространстве
   - Работа по принципу "work-stealing" (кража работы)
   - Локальные и глобальные очереди горутин

#### 2. Сборщик мусора (Garbage Collector)

Сборщик мусора Go автоматически освобождает память, которая больше не используется программой:

1. **Тип**: Параллельный, трехцветный, маркировочно-очистной (Mark and Sweep), **не поколенческий** (в отличие от JVM/CLR).
2. **Характеристики**:
   - Небольшие паузы (sub-millisecond)
   - Конкурентный — работает одновременно с выполнением программы
   - Параллельный — использует несколько потоков для сборки
   - Неперемещающий — не перемещает объекты в памяти

3. **Фазы работы**:
   - Маркировка (mark) — обход и маркировка достижимых объектов
   - Очистка (sweep) — освобождение памяти недостижимых объектов
   - Фаза write barrier — отслеживание изменений в памяти во время маркировки

4. **Настройка**:
   - `GOGC` — контроль частоты запуска сборки мусора
   - `GOMEMLIMIT` — ограничение общего использования памяти (Go 1.19+)

#### 3. Управление памятью (Memory Allocator)

Система управления памятью в Go:

1. **Основные принципы**:
   - Локальные аллокаторы для каждого P (для уменьшения блокировок)
   - Размещение объектов по размерным классам
   - Фрагментация памяти сведена к минимуму
   - Используется tcmalloc-подобная стратегия, но с оптимизациями для конкурентного выделения памяти (per-P mcache, mcentral, mspan)

2. **Структура**:
   - Страницы памяти (обычно 8KB)
   - Spans — последовательные страницы для объектов одного размера
   - Arenas — крупные блоки памяти, запрашиваемые у ОС
   - mspan, mcache, mcentral — структуры для управления памятью
   - Stack splitting — динамическое увеличение стека горутин реализовано на уровне runtime для минимизации использования памяти

#### 4. Netpoller (Network Poller)

Netpoller обеспечивает неблокирующие I/O операции для сетевых и файловых операций:

1. **Механизм работы**:
   - Использует системные вызовы epoll (Linux), kqueue (BSD/macOS), IOCP (Windows)
   - Позволяет одному потоку ОС обслуживать тысячи соединений

2. **Особенности**:
   - Асинхронные I/O операции без блокирования ОС-потоков
   - Интеграция с планировщиком для эффективного переключения горутин
   - Прозрачный механизм для пользовательского кода

#### 5. Система каналов (Channel System)

Реализация каналов (channels) для коммуникации между горутинами:

1. **Внутреннее устройство**:
   - Кольцевой буфер для хранения данных
   - Очереди заблокированных отправителей и получателей
   - Мьютексы для синхронизации доступа

2. **Типы каналов**:
   - Буферизованные
   - Небуферизованные
   - Однонаправленные (только для отправки/получения)

3. **Операции**:
   - Отправка данных
   - Получение данных
   - Закрытие канала
   - Мультиплексирование через select

#### 6. Система типов и рефлексия (Type System)

Поддержка информации о типах и рефлексии во время выполнения:

1. **Типы данных**:
   - Информация о структуре типов
   - Таблицы методов интерфейсов
   - Поддержка утверждений типа (type assertions)

2. **Рефлексия**:
   - Пакет `reflect` для работы с типами во время выполнения
   - Инспекция и модификация значений
   - Вызов методов динамически

#### 7. Pprof и трассировка (Profiling and Tracing)

Инструменты для профилирования и отладки:

1. **Профилирование**:
   - CPU профилирование
   - Профилирование памяти
   - Профилирование блокировок (mutex profiling)
   - Профилирование горутин

2. **Трассировка**:
   - Запись событий времени выполнения
   - Визуализация взаимодействия горутин
   - Анализ использования ресурсов

#### 8. Интерфейс с ОС (OS Interface)

Низкоуровневые взаимодействия с операционной системой:

1. **Системные вызовы**:
   - Абстракция над нативными системными вызовами
   - Оптимизированные реализации для разных ОС

2. **Сигналы**:
   - Обработка сигналов ОС
   - Конвертация сигналов в панику (например, SIGSEGV)

3. **Управление потоками ОС**:
   - Создание и уничтожение потоков
   - Синхронизация между потоками

### Внутренние механизмы и особенности

#### 1. Инициализация Runtime

Процесс инициализации Go Runtime:

1. **Последовательность запуска**:
   - Инициализация основных подсистем
   - Настройка планировщика
   - Запуск сборщика мусора
   - Инициализация netpoller
   - Запуск функции `main`

2. **Инициализация переменных**:
   - Выполнение инициализаторов пакетов в правильном порядке
   - Выполнение функций `init()`

#### 2. Асинхронность и вытеснение

Механизмы асинхронного выполнения и вытеснения горутин:

1. **Точки вытеснения**:
   - Вызовы функций
   - Обратные вызовы планировщика
   - Барьеры сборщика мусора
   - Асинхронные вытеснения по таймеру (с Go 1.14)

2. **Сигнальное вытеснение**:
   - Использование сигналов SIGURG для асинхронного вытеснения

#### 3. Взаимодействие с CGO

Система взаимодействия с C-кодом:

1. **Особенности**:
   - Переключение между стеками Go и C
   - Управление горутинами при вызовах в C-код
   - Обработка блокирующих C-вызовов

2. **Ограничения**:
   - Стоимость перехода между Go и C
   - Особенности работы со сборщиком мусора

### Эволюция Go Runtime

Значительные изменения в Go Runtime по версиям:

1. **Go 1.10-1.12**:
   - Оптимизация планировщика
   - Улучшения сборщика мусора

2. **Go 1.13-1.14**:
   - Асинхронное вытеснение горутин
   - Улучшенные точки вытеснения

3. **Go 1.15-1.17**:
   - Снижение латентности GC
   - Оптимизация аллокатора памяти

4. **Go 1.18-1.20**:
   - Поддержка generics
   - Мягкие ограничения памяти (soft memory limit)
   - Улучшения производительности сборщика мусора

## Связанные темы

[[Процессы и потоки ОС]]
[[Go Scheduler]]
[[Горутины. Внутреннее устройство горутин]]
[[Garbage Collector. Различные алгоритмы сборки мусора]]
[[Коммуникация и синхронизация горутин]]

## Источники

1. [Go Runtime Scheduler](https://morsmachine.dk/go-scheduler)
2. [Go memory allocator & garbage collector](https://medium.com/a-journey-with-go/go-memory-allocator-visual-guide-e0a7e549b809)
3. [The Go Programming Language Specification](https://golang.org/ref/spec)
4. [The Go Blog: The Go GC History](https://go.dev/blog/ismmkeynote)
5. [The Go Memory Model](https://golang.org/ref/mem)
6. [Go under the hood](https://github.com/golang/go/tree/master/src/runtime)
7. [Scheduler Tracing In Go](https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html)
8. [Go: asynchronous preemption](https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c)
9. [Go: How Does the Garbage Collector Mark the Memory?](https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976)