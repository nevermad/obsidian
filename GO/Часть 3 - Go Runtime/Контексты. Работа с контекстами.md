# Контексты. Работа с контекстами

## Краткий обзор

Пакет `context` в Go предоставляет стандартный способ передачи deadlines, отмены сигналов и значений, привязанных к запросу, между горутинами. Контекст организован как иммутабельное дерево, где каждый потомок наследует свойства родителя и может добавлять свои. Основные типы контекстов: Background, TODO, WithCancel, WithDeadline, WithTimeout и WithValue. Контексты широко используются для управления жизненным циклом горутин, избежания утечек ресурсов, контроля времени выполнения операций и передачи данных запроса между слоями приложения. Важным аспектом пакета является его потокобезопасность и иммутабельность, что делает контексты безопасными для использования в конкурентных программах.

## Подробный разбор

### Концепция контекста в Go

Контекст — это интерфейс, который является основой для управления жизненным циклом горутин:

#### 1. Определение и назначение

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)  // Возвращает время, когда работа должна быть отменена
    Done() <-chan struct{}                    // Канал, закрываемый при отмене контекста
    Err() error                               // Причина отмены (nil, если не отменен)
    Value(key interface{}) interface{}        // Получение значения по ключу
}
```

Основные задачи, решаемые контекстами:

- Отмена операций (cancellation)
- Установка таймаутов и дедлайнов
- Передача значений, привязанных к запросу
- Предотвращение утечек горутин
- Стандартизация API пакетов и библиотек

#### 2. Философия контекстов

Контексты в Go основаны на нескольких ключевых принципах:

1. **Иммутабельность**: Контексты не изменяются после создания
2. **Композиция**: Создание иерархического дерева контекстов
3. **Распространение отмены**: Отмена родителя отменяет всех потомков
4. **Ясность API**: Контекст передается первым параметром функции
5. **Безопасность**: Потокобезопасность для использования в конкурентных программах

### Типы контекстов

Go предоставляет несколько типов контекстов для различных сценариев:

#### 1. Базовые контексты

```go
// Корневой контекст для дерева контекстов
ctx := context.Background()

// Заполнитель, когда неясно, какой контекст использовать
ctx := context.TODO()
```

**Особенности**:

- Никогда не отменяются
- Не имеют значений
- Не имеют дедлайнов
- Используются как корни для создания более специализированных контекстов

#### 2. Отменяемые контексты

```go
// Создание контекста с функцией отмены
ctx, cancel := context.WithCancel(parentCtx)
defer cancel() // Важно всегда вызывать cancel

// Использование
go func() {
    select {
    case <-ctx.Done():
        return // Контекст отменен
    case <-time.After(1 * time.Second):
        doSomething()
    }
}()

// Явная отмена
cancel()
```

**Особенности**:

- Канал `Done()` закрывается при вызове `cancel()`
- `Err()` возвращает `context.Canceled` после отмены
- Отмена распространяется на всех потомков

#### 3. Контексты с таймаутом и дедлайном

```go
// Контекст с таймаутом - отменяется через указанное время
ctx, cancel := context.WithTimeout(parentCtx, 100*time.Millisecond)
defer cancel()

// Контекст с дедлайном - отменяется в указанное время
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(parentCtx, deadline)
defer cancel()
```

**Особенности**:

- `Deadline()` возвращает установленное время
- После истечения времени канал `Done()` закрывается
- `Err()` возвращает `context.DeadlineExceeded`
- `cancel()` всё равно должен быть вызван для освобождения ресурсов

#### 4. Контексты со значениями

```go
// Добавление значения в контекст
// Рекомендуется использовать типизированные ключи (struct{} или custom type), чтобы избежать коллизий между пакетами
ctx := context.WithValue(parentCtx, userIDKey, "12345")

// Извлечение значения
if userID, ok := ctx.Value(userIDKey).(string); ok {
    // Использование userID
}
```

**Особенности**:

- Не влияет на отмену или дедлайны
- Использует сравнение по равенству для ключей
- Для ключей рекомендуется использовать типы, а не строки, чтобы избежать коллизий
- Значения доступны от текущего контекста и всех его родителей

### Внутреннее устройство контекстов

Контексты в Go имеют относительно простую, но эффективную реализацию:

#### 1. Структуры и интерфейсы

1. **emptyCtx** — базовый контекст:

   ```go
   type emptyCtx int

   func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return }
   func (*emptyCtx) Done() <-chan struct{} { return nil }
   func (*emptyCtx) Err() error { return nil }
   func (*emptyCtx) Value(key interface{}) interface{} { return nil }
   ```

2. **cancelCtx** — отменяемый контекст:

   ```go
   type cancelCtx struct {
       Context
       mu       sync.Mutex
       done     chan struct{}
       children map[canceler]struct{}
       err      error
   }
   ```

3. **timerCtx** — контекст с таймером:

   ```go
   type timerCtx struct {
       cancelCtx
       timer *time.Timer
       deadline time.Time
   }
   ```

4. **valueCtx** — контекст со значением:

   ```go
   type valueCtx struct {
       Context
       key, val interface{}
   }
   ```

#### 2. Дерево контекстов

- Каждый контекст, кроме `emptyCtx`, имеет родительский контекст
- `WithCancel`, `WithTimeout`, `WithDeadline` создают `cancelCtx` или `timerCtx`
- `WithValue` создает `valueCtx`
- Отмена распространяется вниз по дереву, но не вверх

#### 3. Механизм отмены

1. **Вызов `cancel()`**:
   - Устанавливает `err` в `context.Canceled`
   - Закрывает канал `done`
   - Отменяет всех детей
   - Останавливает таймер, если есть
   - Удаляет контекст из родительских детей

2. **Отмена по таймауту**:
   - Таймер вызывает `cancel()` после истечения времени
   - `err` устанавливается в `context.DeadlineExceeded`
   - Распространение отмены работает так же, как для `cancel()`

### Применение контекстов

Контексты используются в различных сценариях:

#### 1. Отмена операций

```go
func longOperation(ctx context.Context) error {
    // Создаем канал для результата
    result := make(chan int, 1)
    
    // Запускаем вычисление в отдельной горутине
    go func() {
        // Долгие вычисления
        result <- compute()
    }()
    
    // Ожидаем результата или отмены
    select {
    case res := <-result:
        processResult(res)
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// Использование
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()
err := longOperation(ctx)
if err == context.DeadlineExceeded {
    // Превышен таймаут
}
```

#### 2. Распространение отмены через API

```go
func fetchData(ctx context.Context, url string) (*Response, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    // Проверяем отмену перед затратной операцией
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
        // Продолжаем выполнение
    }
    
    // Обработка ответа...
    return processResponse(resp)
}
```

#### 3. Передача данных запроса

```go
// Тип ключа для избежания коллизий
type contextKey string

const (
    userIDKey contextKey = "user_id"
    authTokenKey contextKey = "auth_token"
)

// Middleware, добавляющий данные в контекст
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := extractTokenFromRequest(r)
        userID, err := validateToken(token)
        if err != nil {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // Добавляем данные в контекст
        ctx := r.Context()
        ctx = context.WithValue(ctx, userIDKey, userID)
        ctx = context.WithValue(ctx, authTokenKey, token)
        
        // Вызываем следующий обработчик с обновленным контекстом
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// Доступ к данным в обработчике
func handleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    userID, ok := ctx.Value(userIDKey).(string)
    if !ok {
        http.Error(w, "No user ID found", http.StatusInternalServerError)
        return
    }
    
    // Использование userID...
}
```

#### 4. Управление ресурсами

```go
func resourceManager(ctx context.Context) {
    // Выделяем ресурс
    res := acquireExpensiveResource()
    
    // Гарантируем освобождение ресурса
    defer releaseResource(res)
    
    // Канал для сигнализации о завершении работы
    done := make(chan struct{})
    
    // Запускаем работу в отдельной горутине
    go func() {
        useResource(res)
        close(done)
    }()
    
    // Ожидаем завершения работы или отмены контекста
    select {
    case <-done:
        return
    case <-ctx.Done():
        // Контекст отменен, но releaseResource все равно будет вызван
        return
    }
}
```

### Лучшие практики использования контекстов

#### 1. Общие рекомендации

1. **Передавайте контекст первым параметром функции**:

   ```go
   func DoSomething(ctx context.Context, arg Arg) error { ... }
   ```

2. **Не храните контексты в структурах**:

   ```go
   // Плохо
   type Service struct {
       ctx context.Context
       // ...
   }
   
   // Хорошо
   type Service struct {
       // ...
   }
   
   func (s *Service) DoWork(ctx context.Context) { ... }
   ```

3. **Всегда вызывайте `cancel()`**:

   ```go
   ctx, cancel := context.WithTimeout(parentCtx, timeout)
   defer cancel() // Даже если таймаут уже сработал
   ```

4. **Проверяйте отмену в циклах и длительных операциях**:

   ```go
   for {
       select {
       case <-ctx.Done():
           return ctx.Err()
       default:
           // Продолжаем работу
       }
       // ...
   }
   ```

#### 2. Использование Value

1. **Применяйте пользовательские типы для ключей**:

   ```go
   type myKey int
   const (
       requestIDKey myKey = iota
       userKey
   )
   ```

2. **Ограничьте использование контекста для передачи значений**:
   - Используйте только для данных запроса
   - Не передавайте опциональные параметры функций
   - Не передавайте конфигурационные значения
   - Документируйте все ключи контекста
   - Контекст не должен использоваться для передачи опциональных параметров или конфигурации — только для данных, связанных с жизненным циклом запроса

3. **Проверяйте типы при извлечении значений**:

   ```go
   value, ok := ctx.Value(key).(ExpectedType)
   if !ok {
       // Обработка ошибки
   }
   ```

#### 3. Отмена и таймауты

1. **Устанавливайте реалистичные таймауты**:

   ```go
   // Разные операции требуют разных таймаутов
   ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
   ```

2. **Корректно обрабатывайте ошибки отмены**:

   ```go
   if err := operation(ctx); err != nil {
       if errors.Is(err, context.Canceled) {
           // Контекст отменен пользователем
       } else if errors.Is(err, context.DeadlineExceeded) {
           // Превышен таймаут
       } else {
           // Другая ошибка
       }
   }
   ```

3. **Отменяйте операции при ошибках**:

   ```go
   ctx, cancel := context.WithCancel(parentCtx)
   defer cancel()
   
   err := step1(ctx)
   if err != nil {
       cancel() // Сигнализируем об отмене другим горутинам
       return err
   }
   
   return step2(ctx)
   ```

### Взаимодействие с другими пакетами и API

#### 1. Стандартная библиотека

Многие пакеты стандартной библиотеки поддерживают контексты:

1. **net/http**:

   ```go
   // Клиент
   req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
   resp, err := http.DefaultClient.Do(req)
   
   // Сервер
   func handler(w http.ResponseWriter, r *http.Request) {
       ctx := r.Context() // Контекст прерывается при закрытии соединения
       // ...
   }
   ```

2. **database/sql**:

   ```go
   row := db.QueryRowContext(ctx, "SELECT * FROM users WHERE id = ?", id)
   ```

3. **os/exec**:

   ```go
   cmd := exec.CommandContext(ctx, "sleep", "5")
   err := cmd.Run()
   ```

#### 2. Сторонние библиотеки

Большинство современных Go-библиотек также поддерживают контексты:

1. **gRPC**:

   ```go
   resp, err := client.SomeRPC(ctx, req)
   ```

2. **MongoDB, Redis и другие драйверы баз данных**:

   ```go
   result, err := collection.Find(ctx, filter)
   ```

#### 3. Интеграция с API без поддержки контекстов

```go
func adaptor(ctx context.Context, legacyAPI func() (Result, error)) (Result, error) {
    resultCh := make(chan Result, 1)
    errCh := make(chan error, 1)
    
    go func() {
        result, err := legacyAPI()
        if err != nil {
            errCh <- err
            return
        }
        resultCh <- result
    }()
    
    select {
    case result := <-resultCh:
        return result, nil
    case err := <-errCh:
        return Result{}, err
    case <-ctx.Done():
        return Result{}, ctx.Err()
    }
}
```

### Примеры сложных сценариев использования

#### 1. Каскадная отмена

```go
func processWithSteps(ctx context.Context, data []Item) error {
    // Создаем контекст с таймаутом для всей операции
    opCtx, opCancel := context.WithTimeout(ctx, 30*time.Second)
    defer opCancel()
    
    // Результаты и ошибки от шагов
    results := make(chan Result, len(data))
    errs := make(chan error, len(data))
    
    // Запускаем шаги
    for _, item := range data {
        go func(item Item) {
            // Для каждого шага создаем подконтекст с меньшим таймаутом
            stepCtx, stepCancel := context.WithTimeout(opCtx, 5*time.Second)
            defer stepCancel()
            
            res, err := processStep(stepCtx, item)
            if err != nil {
                errs <- err
                return
            }
            results <- res
        }(item)
    }
    
    // Собираем результаты
    var processedResults []Result
    for i := 0; i < len(data); i++ {
        select {
        case res := <-results:
            processedResults = append(processedResults, res)
        case err := <-errs:
            // При первой ошибке отменяем все операции
            opCancel()
            return err
        case <-opCtx.Done():
            return opCtx.Err()
        }
    }
    
    return finalizeResults(processedResults)
}
```

#### 2. Контексты с приоритетами

```go
func prioritizedOperation(ctx context.Context, highPriority bool) error {
    // Создаем контекст со значением приоритета
    ctx = context.WithValue(ctx, priorityKey, highPriority)
    
    return executeWithPriority(ctx)
}

func executeWithPriority(ctx context.Context) error {
    // Извлекаем приоритет
    highPriority, _ := ctx.Value(priorityKey).(bool)
    
    // Выбираем таймаут в зависимости от приоритета
    var timeout time.Duration
    if highPriority {
        timeout = 10 * time.Second
    } else {
        timeout = 5 * time.Second
    }
    
    // Создаем подконтекст с соответствующим таймаутом
    timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()
    
    // Выбираем очередь в зависимости от приоритета
    var queue string
    if highPriority {
        queue = "high_priority"
    } else {
        queue = "normal"
    }
    
    return processInQueue(timeoutCtx, queue)
}
```

#### 3. Контекст в долгоживущих процессах

```go
func startWorker(ctx context.Context) {
    // Канал для периодических задач
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    // Канал для сигнала перезагрузки
    reloadCh := make(chan struct{}, 1)
    
    // Загружаем начальную конфигурацию
    config := loadConfig()
    
    // Запускаем слежение за конфигурацией
    go watchForConfigChanges(ctx, reloadCh)
    
    for {
        select {
        case <-ctx.Done():
            // Завершаем работу при отмене контекста
            log.Println("Worker stopping due to context cancellation")
            return
            
        case <-ticker.C:
            // Периодическая задача
            taskCtx, taskCancel := context.WithTimeout(ctx, 30*time.Second)
            err := periodicTask(taskCtx, config)
            taskCancel()
            
            if err != nil {
                log.Printf("Periodic task error: %v", err)
            }
            
        case <-reloadCh:
            // Перезагрузка конфигурации
            newConfig := loadConfig()
            if err := validateConfig(newConfig); err != nil {
                log.Printf("Invalid config: %v, keeping old config", err)
                continue
            }
            config = newConfig
            log.Println("Configuration reloaded")
        }
    }
}

func watchForConfigChanges(ctx context.Context, reloadCh chan<- struct{}) {
    // Настройка наблюдения за файлом конфигурации или другими источниками
    // ...
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-configChanged:
            // Отправляем сигнал перезагрузки
            select {
            case reloadCh <- struct{}{}:
                // Сигнал отправлен
            default:
                // Канал заполнен, предыдущий сигнал еще не обработан
            }
        }
    }
}
```

### Производительность и ограничения

#### 1. Производительность

- Создание и распространение контекстов имеет низкие накладные расходы
- `WithValue` использует линейный поиск по цепочке контекстов; глубокие цепочки valueCtx могут негативно влиять на скорость поиска значений
- Глубокие деревья контекстов с множеством значений могут стать узким местом
- Отмена распространяется за O(n), где n - количество дочерних контекстов

#### 2. Ограничения

1. **Безопасность типов**:
   - `Value()` возвращает `interface{}`, требуя дополнительного приведения типов
   - Нет статической проверки ключей при компиляции

2. **Иммутабельность**:
   - Невозможно изменить существующий контекст
   - Для добавления значений необходимо создавать новый контекст

3. **Распространение значений**:
   - Значения доступны только вниз по дереву, но не наверх или по горизонтали
   - Нет возможности "удалить" значение из цепочки контекстов

4. **Отладка**:
   - Отслеживание распространения контекстов может быть сложным
   - Сложно визуализировать иерархию контекстов

### Будущее контекстов в Go

1. **Обобщенная версия с Go 1.18+**:

   ```go
   // Экспериментальная реализация с использованием дженериков
   func WithTypedValue[T any](parent Context, key interface{}, val T) Context {
       return context.WithValue(parent, key, val)
   }
   
   func GetTypedValue[T any](ctx Context, key interface{}) (T, bool) {
       val, ok := ctx.Value(key).(T)
       return val, ok
   }
   ```

2. **Альтернативы и дополнения**:
   - Structured logging libraries (zerolog, zap) для передачи контекстных данных
   - Error wrapping в стиле `errors.Is` и `errors.As` для более богатого контекста ошибок
   - Использование `errgroup` для групповой отмены и ожидания

## Связанные темы

[[Коммуникация и синхронизация горутин]]
[[Горутины. Внутреннее устройство горутин]]
[[Go Runtime. Составляющие части Go Runtime]]
[[Каналы. Внутреннее устройство каналов]]

## Источники

1. [Go Context Package Documentation](https://golang.org/pkg/context/)
2. [Go Blog: Context and Cancellation of goroutines](https://blog.golang.org/context)
3. [Go Blog: Context and structs](https://blog.golang.org/context-and-structs)
4. [Effective Go](https://golang.org/doc/effective_go.html)
5. [Go source code: src/context/context.go](https://github.com/golang/go/blob/master/src/context/context.go)
6. [Context Package Semantics in Go](https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html)
7. [Go Concurrency Patterns: Context](https://blog.golang.org/context)
8. [Understanding the context package in golang](https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39)
9. [50 Shades of Go: Traps, Gotchas, and Common Mistakes](http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/)
