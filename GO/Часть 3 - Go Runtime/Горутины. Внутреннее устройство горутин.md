# Горутины. Внутреннее устройство горутин

## Краткий обзор

Горутины (goroutines) — легковесные потоки выполнения в Go, управляемые планировщиком Go Runtime. В отличие от потоков ОС, горутины имеют малый размер стека (начинается с 2KB и может расти до 1GB), эффективно мультиплексируются на меньшее количество потоков ОС и имеют низкую стоимость создания и переключения контекста. Внутренне горутина представлена структурой `g`, содержащей стек, контекст выполнения и состояние. Горутины взаимодействуют через каналы и другие примитивы синхронизации. Эффективность горутин достигается благодаря кооперативной многозадачности с возможностью вытеснения, динамическому управлению стеком и модели планирования M:N.

## Подробный разбор

### Концепция горутин

Горутины — это основа конкурентного программирования в Go, предоставляющая простой способ запуска параллельных задач:

1. **Определение**: горутина — это независимо выполняемая функция в программе Go
2. **Синтаксис**: `go f(args)` запускает функцию `f` как новую горутину
3. **Отличия от потоков ОС**:
   - Меньший размер (изначально ~2KB против ~2MB для потоков ОС)
   - Управление в пользовательском пространстве (не зависит от системного планировщика)
   - Намного более низкие затраты на создание и уничтожение
   - Возможность запуска тысяч или миллионов горутин в одной программе

### Внутренняя структура горутины

Горутина в Go Runtime представлена структурой `g` (определение приблизительное и может меняться в разных версиях Go):

```go
type g struct {
    // Стек
    stack       stack   // Границы стека: [stack.lo, stack.hi)
    stackguard0 uintptr // для проверки переполнения стека
    stackguard1 uintptr // для использования с cgo

    // Информация о состоянии выполнения
    _panic       *_panic      // внутренняя структура паники
    _defer       *_defer      // цепочка отложенных вызовов
    m            *m           // текущий M, выполняющий горутину
    sched        gobuf        // сохраненное состояние для планирования
    syscallsp    uintptr      // sp для вызывающего системный вызов
    syscallpc    uintptr      // pc для вызывающего системный вызов
    param        unsafe.Pointer // для передачи параметров g → g
    atomicstatus uint32      // статус горутины
    goid         int64       // уникальный идентификатор горутины (начиная с Go 1.20 обсуждается отказ от публичного goid, это не часть стабильного API)
    
    // Дополнительные поля
    waitreason waitReason    // причина блокировки (если заблокирована)
    preempt     bool         // отметка для асинхронного вытеснения
    lockedm     muintptr     // заблокированный M (для OS callbacks)
    
    // Связь с очередями планировщика
    schedlink    guintptr    // указатель на следующую g в списке
    
    // GC-связанные поля
    gcAssistBytes int64      // количество памяти, за которую g помогла GC
    
    // Прочие поля...
}
```

### Стек горутины

Одно из ключевых отличий горутин — их динамически изменяемый стек:

1. **Размер и рост**:
   - Начальный размер: ~2KB (в современных версиях Go)
   - Максимальный размер: 1GB
   - Динамический рост по мере необходимости (stack splitting происходит только при необходимости)
   - Stack shrinking (уменьшение стека) реализовано с Go 1.4+

2. **Split stacks (разделенные стеки)**:
   - Проверка переполнения стека в прологе каждой функции
   - При недостатке места — выделение нового, большего стека
   - Копирование данных со старого стека на новый

3. **Механизм проверки границы стека**:
   - Каждая функция содержит пролог для проверки `stackguard0`
   - Если SP (Stack Pointer) ниже `stackguard0` — вызов `morestack`
   - `morestack` сохраняет состояние, выделяет новый стек и возобновляет выполнение

4. **Преимущества динамического стека**:
   - Экономия памяти: маленькие горутины используют мало памяти
   - Масштабируемость: возможность запуска большого количества горутин
   - Адаптивность: размер подстраивается под реальные потребности

### Жизненный цикл горутины

Горутина проходит через несколько состояний в течение своего существования:

1. **Создание**:
   - Вызов `go f(args)` компилируется в вызов `runtime.newproc`
   - Выделяется структура `g` и стек
   - Начальные регистры инициализируются для выполнения функции `f`
   - Горутина помещается в очередь планировщика

2. **Выполнение**:
   - Планировщик выбирает горутину из очереди
   - Контекст горутины загружается в M (поток ОС)
   - Выполнение продолжается до точки вытеснения или блокировки

3. **Блокировка**:
   - При блокирующих операциях (I/O, каналы, мьютексы) горутина сохраняет свое состояние
   - Поток M освобождается для выполнения других горутин
   - Заблокированная горутина помечается соответствующей причиной ожидания

4. **Разблокировка**:
   - Когда условие блокировки снимается, горутина помещается обратно в очередь
   - Планировщик в будущем выберет горутину для выполнения

5. **Завершение**:
   - При выходе из функции горутины
   - Структура `g` помещается в пул для переиспользования
   - Стек освобождается

### Внутренние состояния горутины

Горутина может находиться в различных состояниях, определяемых полем `atomicstatus`:

1. **`_Gidle`** (0) — Горутина выделена, но еще не инициализирована
2. **`_Grunnable`** (1) — В очереди, готова к выполнению
3. **`_Grunning`** (2) — Выполняется на M
4. **`_Gsyscall`** (3) — Выполняет системный вызов
5. **`_Gwaiting`** (4) — Заблокирована, ожидает условия
6. **`_Gdead`** (6) — Не используется (помещена в пул или еще не выделена)
7. **`_Gcopystack`** (8) — Стек копируется, не выполняется
8. **`_Gscan`** (0x1000) — Модификатор: GC сканирует стек

Переходы между состояниями строго контролируются планировщиком и примитивами синхронизации.

### Планирование и вытеснение горутин

Механизмы, контролирующие выполнение горутин:

1. **Кооперативное вытеснение**:
   - До Go 1.14: в определенных точках программы (вызовы функций, GC)
   - Горутины с интенсивными вычислениями могли блокировать планировщик

2. **Асинхронное вытеснение** (с Go 1.14):
   - Использует сигналы ОС (SIGURG) для прерывания длинных горутин
   - Позволяет вытеснять горутины, выполняющие циклы или длительные вычисления
   - Точки вызова функций больше не обязательны для вытеснения

3. **Точки вытеснения**:
   - Вызовы функций (проверка в прологе)
   - Возвраты из функций
   - Барьеры сборщика мусора
   - Циклы и вычисления (с асинхронным вытеснением)

4. **Квант времени**:
   - Нет фиксированного кванта времени как в ОС
   - Вытеснение может происходить через ~10мс для CPU-интенсивных горутин (контролируется `sysmon`)

### Взаимодействие с GMP-моделью

Горутины (G) существуют как часть GMP-модели Go Runtime:

1. **Связь G ↔ M**:
   - Горутина (G) может выполняться только на M (потоке ОС)
   - Один M выполняет одну G в определенный момент времени
   - Связь G → M хранится в полях `g.m` и `m.curg`

2. **Связь G ↔ P**:
   - P (процессор) — абстракция, обеспечивающая контекст выполнения
   - P имеет локальную очередь горутин (runqueue)
   - G планируется на P, который затем связывается с M

3. **Переключение контекста горутин**:
   - Гораздо дешевле, чем переключение потоков ОС
   - Не требует переключения в режим ядра
   - Переключение выполняется функцией `runtime.gogo`
   - Сохранение/восстановление регистров и указателей стека

### Стоимость горутин

Преимущества и затраты на использование горутин:

1. **Затраты памяти**:
   - Начальный размер: ~2KB на горутину
   - Структура `g`: ~400-500 байт
   - Общие накладные расходы: ~2.5KB на новую горутину

2. **Затраты создания**:
   - Аллокация памяти для `g` и стека
   - Инициализация состояния и регистров
   - Помещение в очередь планировщика
   - В целом ~1-2 мкс (в сотни раз быстрее создания потока ОС)

3. **Переключение контекста**:
   - ~200 нс (наносекунд) между горутинами
   - В 10-100 раз быстрее, чем между потоками ОС
   - Переключение между горутинами не требует перехода в режим ядра, но может быть дороже при взаимодействии с cgo или системными вызовами

4. **Масштабируемость**:
   - Теоретически: миллионы горутин на современном оборудовании
   - Практически: сотни тысяч горутин вполне реально использовать

### Оптимизации в работе с горутинами

Техники оптимизации при использовании большого количества горутин:

1. **Пул воркеров**:
   - Ограничение количества одновременно выполняющихся горутин
   - Переиспользование горутин для выполнения задач

2. **Использование буферизованных каналов**:
   - Уменьшение блокировок при операциях с каналами
   - Контроль скорости производителей и потребителей

3. **Избегание блокирующих операций**:
   - Использование неблокирующих I/O
   - Разделение длительных операций на более короткие

4. **Контроль за размером стека**:
   - Избегание глубокой рекурсии
   - Осторожность с большими локальными переменными

5. **Профилирование горутин**:
   - `go tool trace` для анализа поведения горутин
   - `runtime.NumGoroutine()` для мониторинга количества горутин

### Внутренние особенности реализации

Некоторые низкоуровневые детали реализации горутин:

1. **Пул горутин**:
   - Завершенные горутины помещаются в пул для повторного использования (пул используется только для завершённых g)
   - Повторное использование стека минимизирует накладные расходы на аллокацию

2. **Основная горутина (`g0`)**:
   - Специальная горутина для каждого M
   - Используется для планирования, системных вызовов и других функций runtime

3. **Stack unwinding**:
   - Механизм для обработки паник и восстановления
   - Выполняет отложенные функции в обратном порядке

4. **Парковка и распарковка**:
   - Механизм для временной остановки и возобновления горутин
   - Используется для реализации примитивов синхронизации

5. **Системные горутины**:
   - Специальные горутины для GC, `sysmon` и других служебных задач
   - Имеют особые свойства и приоритеты

### Примеры внутреннего кода

Примеры низкоуровневых функций для работы с горутинами:

1. **Создание новой горутины**:

   ```go
   // runtime/proc.go
   func newproc(siz int32, fn *funcval) {
       argp := add(unsafe.Pointer(&fn), sys.PtrSize)
       gp := getg()
       pc := getcallerpc()
       systemstack(func() {
           newg := newproc1(fn, argp, siz, gp, pc)
           pp := getg().m.p.ptr()
           runqput(pp, newg, true)
       })
   }
   ```

2. **Парковка горутины**:

   ```go
   // runtime/proc.go
   func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
       mp := acquirem()
       gp := mp.curg
       // Сохранение состояния и переход в _Gwaiting
       // ...
       releasem(mp)
       mcall(park_m)
   }
   ```

3. **Переключение горутин**:

   ```go
   // runtime/asm_amd64.s (пример для amd64)
   TEXT runtime·gogo(SB), NOSPLIT, $0-8
       MOVQ    buf+0(FP), BX   // gobuf
       MOVQ    gobuf_g(BX), DX
       MOVQ    0(DX), CX       // проверка, что g != nil
       // Загрузка регистров из gobuf
       MOVQ    gobuf_sp(BX), SP
       MOVQ    gobuf_bp(BX), BP
       MOVQ    gobuf_pc(BX), BX
       JMP    BX              // переход к коду горутины
   ```

## Связанные темы

[[Процессы и потоки ОС]]
[[Go Runtime. Составляющие части Go Runtime]]
[[Go Scheduler]]
[[Коммуникация и синхронизация горутин]]
[[Куча и стек. Escape Analysis]]

## Источники

1. [The Go Memory Model](https://golang.org/ref/mem)
2. [Go's work-stealing scheduler](https://rakyll.org/scheduler/)
3. [Go: Goroutine, OS Thread and CPU Management](https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a)
4. [Illustrated Tales of Go Runtime Scheduler](https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b)
5. [The Go scheduler](https://morsmachine.dk/go-scheduler)
6. [Go's Garbage Collector: Go GC](https://blog.golang.org/ismmkeynote)
7. [Go source code (runtime package)](https://github.com/golang/go/tree/master/src/runtime)
8. [Debugging performance issues in Go programs](https://github.com/golang/go/wiki/Performance)
9. [The Go Programming Language Specification](https://golang.org/ref/spec)
10. [Scheduling In Go (Parts 1-3)](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
