# Процессы и потоки ОС

## Краткий обзор

Процесс — это экземпляр выполняющейся программы с выделенными ресурсами (память, файловые дескрипторы), имеющий собственное адресное пространство. Потоки — это единицы выполнения внутри процесса, разделяющие адресное пространство процесса, но имеющие свой стек и регистры. В современных ОС (Linux, macOS, Windows) потоки реализованы как "lightweight processes" (LWP), и различие между процессом и потоком на уровне ядра минимально — оба имеют идентификатор, но потоки разделяют адресное пространство. Операционная система планирует выполнение потоков через сложные гибридные планировщики (например, CFS в Linux), которые распределяют процессорное время между потоками с учетом приоритетов, fairness и других факторов. Процессы взаимодействуют через IPC-механизмы (пайпы, сокеты, разделяемая память), а переключение контекста между потоками — это сохранение и восстановление состояния потока, что имеет определённую стоимость для производительности, несмотря на аппаратное ускорение (например, TSS на x86).

## Подробный разбор

### Процессы

Процесс — это экземпляр программы во время выполнения, включающий:

1. **Адресное пространство** — виртуальное адресное пространство процесса (в современных ОС обычно 64-битное), которое отображается на физическую память через страничную таблицу.
2. **Сегменты памяти**:
   - Сегмент кода (text) — содержит исполняемые инструкции (только чтение)
   - Сегмент данных — инициализированные глобальные и статические переменные
   - Сегмент BSS — неинициализированные глобальные и статические переменные
   - Куча (heap) — динамически выделяемая память
   - Стек — локальные переменные, аргументы функций, адреса возврата
3. **Состояние процесса** — может быть: готов к выполнению, выполняется, заблокирован, завершен.
4. **Контекст процесса** — информация, необходимая для возобновления выполнения.
5. **Ресурсы ОС**:
   - Файловые дескрипторы
   - Сокеты
   - Семафоры, мьютексы
   - Права доступа
   - PID (идентификатор процесса)

В UNIX-подобных системах процессы создаются через системные вызовы `fork()` и `exec()`. `fork()` создает новый процесс, который является копией родительского, а `exec()` заменяет образ процесса новой программой.

### Потоки (Threads)

Поток — это единица выполнения внутри процесса:

1. **Разделяемые ресурсы** с другими потоками процесса:
   - Адресное пространство
   - Глобальные переменные
   - Файловые дескрипторы
   - Сигналы и блокировки сигналов
   - Код программы

2. **Собственные ресурсы**:
   - Стек выполнения
   - Набор регистров процессора
   - Счетчик команд (PC — Program Counter)
   - TID (идентификатор потока)
   - Локальное хранилище потока (Thread Local Storage, TLS)
   - Состояние ошибок (errno в POSIX)

Потоки могут быть:

- **Пользовательскими** (user-level threads) — управляются библиотекой пользовательского пространства
- **Потоками ядра** (kernel-level threads) — управляются непосредственно ОС
- **Гибридными** (M:N threading) — комбинация обоих подходов (как в Go)

### Планировщик ОС

Планировщик ОС отвечает за распределение процессорного времени между потоками:

1. **Стратегии планирования**:
   - Современные ядра используют гибридные алгоритмы (например, Completely Fair Scheduler (CFS) в Linux, Hybrid Scheduler в Windows)
   - Циклическое планирование (Round-robin)
   - Планирование по приоритетам
   - Многоуровневые очереди с обратной связью (Multilevel feedback queue)
   - Планирование в реальном времени

2. **Процесс планирования**:
   - Поток выполняется определенный квант времени
   - По истечении кванта времени происходит прерывание таймера
   - Планировщик выбирает другой поток для выполнения
   - Контекст текущего потока сохраняется, загружается контекст нового
   - Современные процессоры поддерживают аппаратное ускорение context switch (например, через TSS на x86), но стоимость всё равно высока из-за кэшей и TLB

3. **Приоритеты потоков** могут быть:
   - Статическими (заданными)
   - Динамическими (изменяющимися во время выполнения)

4. **Вытеснение (preemption)** — способность ОС принудительно забрать CPU у выполняющегося потока.

### Взаимодействие процессов (IPC)

Процессы взаимодействуют через механизмы IPC (Inter-Process Communication):

1. **Файлы и файловая система** — простейший способ обмена данными
2. **Сигналы** — асинхронные уведомления, отправляемые процессу
3. **Пайпы (pipes)** — однонаправленные каналы передачи данных
4. **Именованные пайпы (FIFOs)** — двунаправленные каналы с именем в файловой системе
5. **Сокеты** — конечные точки двунаправленной коммуникации (локальные и сетевые)
6. **Разделяемая память** — область памяти, доступная нескольким процессам
7. **Очереди сообщений** — буферизованный обмен сообщениями
8. **Семафоры и мьютексы** — примитивы синхронизации
9. **RPC (Remote Procedure Call)** — вызов процедур в другом адресном пространстве

### Память процессов и потоков

Каждый процесс имеет:

1. **Виртуальное адресное пространство** — непрерывный диапазон адресов, отображаемый на физическую память через страничные таблицы.
2. **Страничную организацию памяти** — виртуальная память разделена на страницы (обычно 4 КБ), которые могут быть загружены в физическую память или выгружены на диск.

Потоки в одном процессе:

1. **Разделяют** большую часть адресного пространства (куча, глобальные переменные)
2. **Имеют собственные стеки** — обычно от нескольких КБ до нескольких МБ
3. **Могут иметь TLS** — область памяти для хранения данных, специфичных для потока

### Переключение контекста (Context Switching)

Переключение контекста — это процесс сохранения состояния выполняющегося потока и загрузки состояния другого потока:

1. **Что сохраняется**:
   - Значения регистров процессора
   - Счетчик команд (PC)
   - Указатель стека (SP)
   - Указатель на страничные таблицы
   - Состояние FPU (блока с плавающей точкой)

2. **Стоимость переключения контекста**:
   - Прямые затраты: время выполнения инструкций сохранения/восстановления
   - Непрямые затраты: инвалидация кэшей процессора, TLB (Translation Lookaside Buffer)

3. **Типичная стоимость**:
   - Между потоками одного процесса: ~1-10 мкс
   - Между разными процессами: ~10-100 мкс
   - Полный контекстный переход может занимать тысячи процессорных циклов

4. **Ключевые факторы, влияющие на стоимость**:
   - Аппаратная поддержка переключения контекста
   - Размер рабочего набора потока (working set)
   - Количество регистров в архитектуре
   - Эффективность реализации планировщика

### Связь с Go

Понимание процессов и потоков ОС критически важно для работы с Go, поскольку:

1. **Go-программа выполняется как один процесс ОС** (за исключением случаев с явным созданием дочерних процессов)
2. **Go Runtime использует M:N модель потоков** — множество горутин (G) выполняются на меньшем количестве потоков ОС (M)
3. **Go Scheduler** работает в пользовательском пространстве и планирует горутины на потоки, минимизируя переключения контекста на уровне ОС
4. **Go Runtime может создавать дополнительные потоки ОС** для обслуживания блокирующих системных вызовов (например, sysmon, netpoller, cgo)
5. **Стоимость переключения между горутинами** значительно ниже, чем между потоками ОС

## Связанные темы

[[Go Runtime. Составляющие части Go Runtime]]
[[Go Scheduler]]
[[Горутины. Внутреннее устройство горутин]]
[[Коммуникация и синхронизация горутин]]
[[Контексты. Работа с контекстами]]

## Источники

1. Operating System Concepts (Silberschatz, Galvin, Gagne)
2. Modern Operating Systems (Tanenbaum, Bos)
3. The Linux Programming Interface (Michael Kerrisk)
4. [Go Scheduler: MS, PS & GS](https://povilasv.me/go-scheduler/)
5. [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
6. [Analysis of the Go runtime scheduler (Paper by Neil Deshpande et al.)](https://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf)
7. [Linux Kernel Source Documentation on Process Scheduling](https://www.kernel.org/doc/html/latest/scheduler/index.html)
