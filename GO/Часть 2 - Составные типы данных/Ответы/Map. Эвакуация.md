# Ответы: Map. Эвакуация

## 1. Что такое эвакуация в контексте map Go?

Эвакуация в Go — это процесс перемещения элементов из старой хеш-таблицы в новую при изменении размера map. Особенность Go в том, что эвакуация выполняется инкрементально (постепенно), а не одномоментно:

1. Когда map нуждается в росте, сразу выделяется новая таблица бакетов
2. Данные перемещаются небольшими порциями при последующих операциях с map
3. Старые данные помечаются специальными маркерами tophash для отслеживания состояния эвакуации
4. В течение эвакуации map корректно обрабатывает запросы, проверяя и старую, и новую таблицы

Это обеспечивает предсказуемое и равномерное время выполнения операций.

## 2. Почему Go использует инкрементальное рехеширование?

Go использует инкрементальное рехеширование по нескольким причинам:

1. **Предсказуемое время выполнения**: избегает длительных пауз при работе с большими map
2. **Более равномерное распределение нагрузки**: рехеширование "размазывается" по многим операциям
3. **Меньше заметных задержек**: пользователь не ощущает резкого падения производительности
4. **Лучшая работа в реальном времени**: критично для систем с требованиями к отзывчивости
5. **Устойчивость к DoS-атакам**: атакующий не может вызвать длительную блокировку одной операцией
6. **Более эффективное использование CPU**: меньшие пики потребления процессорного времени

Эта стратегия значительно улучшает поведение map в реальных системах, особенно при большом объеме данных.

## 3. Как происходит процесс миграции данных при увеличении размера map?

Процесс миграции данных в Go включает следующие шаги:

1. **Инициация роста**:

   ```go
   // Выделение новой таблицы бакетов удвоенного размера
   newbuckets := newarray(buckettype, 1<<(h.B+1))
   h.oldbuckets = h.buckets  // Сохранение указателя на старые бакеты
   h.buckets = newbuckets    // Установка указателя на новые бакеты
   h.nevacuate = 0           // Сброс прогресса эвакуации
   ```

2. **Постепенная эвакуация** при последующих операциях:

   ```go
   func evacuate(h *hmap, oldbucket uintptr) {
       // Вычисление X и Y позиций (при удвоении размера)
       newbit := h.noldbuckets() 
       
       // Для каждого элемента в старом бакете
       for _, k, v в старом бакете и его overflow:
           // Определение, куда переместить элемент (X или Y бакет)
           hash := alg.hash(k, h.hash0)
           if hash&newbit != 0 {
               // Перемещение в Y бакет (верхняя половина)
               dst = Y
               b.tophash[i] = evacuatedY
           } else {
               // Перемещение в X бакет (нижняя половина)
               dst = X
               b.tophash[i] = evacuatedX
           }
           
           // Копирование элемента в новую позицию
           // и маркировка в оригинальном бакете
       }
   }
   ```

3. **Завершение эвакуации**: когда все бакеты обработаны, oldbuckets устанавливается в nil.

## 4. Какие специальные значения tophash используются для отслеживания состояния эвакуации?

Go использует специальные значения tophash для отслеживания состояния эвакуации:

```go
const (
    emptyRest      = 0  // ячейка и все следующие пусты
    emptyOne       = 1  // ячейка пуста
    evacuatedX     = 2  // элемент эвакуирован в бакет X (нижняя половина)
    evacuatedY     = 3  // элемент эвакуирован в бакет Y (верхняя половина)
    evacuatedEmpty = 4  // ячейка была пуста и эвакуирована
    minTopHash     = 5  // минимальное значение для обычного tophash
)
```

Значения 2, 3 и 4 используются для обозначения эвакуированных элементов:

- `evacuatedX`: элемент перемещен в нижнюю половину новой таблицы
- `evacuatedY`: элемент перемещен в верхнюю половину новой таблицы
- `evacuatedEmpty`: пустая ячейка, учтенная при эвакуации

Эти маркеры позволяют корректно перенаправлять операции во время рехеширования.

## 5. В каких ситуациях происходит рехеширование map?

Рехеширование в Go запускается в двух основных случаях:

1. **Превышение коэффициента загрузки**:

   ```go
   // Средняя загрузка бакета > 6.5 элементов
   if !h.growing() && overLoadFactor(h.count+1, h.B) {
       hashGrow(h)
   }
   ```

   Здесь map удваивает свой размер для снижения средней нагрузки.

2. **Слишком много overflow-бакетов**:

   ```go
   // Число overflow-бакетов непропорционально велико
   if !h.growing() && tooManyOverflowBuckets(h.noverflow, h.B) {
       hashGrow(h)
   }
   ```

   В этом случае выполняется "same-size" рехеширование для оптимизации структуры.

Дополнительно, map малого размера может быть автоматически увеличена при вставке первых элементов, если изначально была создана с нулевой емкостью.

## 6. Как Go определяет, в какой из новых бакетов (X или Y) переместить элемент?

При удвоении размера map каждый старый бакет "расщепляется" на два новых. Решение, куда именно переместить элемент, основано на дополнительном бите хеша:

```go
// Получаем дополнительный бит, который не учитывался в старой таблице
newbit := h.noldbuckets() // обычно равен 1 << h.B (размер старой таблицы)

// Решаем, куда перемещать элемент
hash := alg.hash(key, h.hash0)
if hash & newbit != 0 {
    // Бит установлен - перемещаем в Y-бакет (верхняя половина новой таблицы)
    // индекс = oldbucket + 2^B
    dst = Y
    b.tophash[i] = evacuatedY
} else {
    // Бит не установлен - перемещаем в X-бакет (нижняя половина, индекс = oldbucket)
    dst = X
    b.tophash[i] = evacuatedX
}
```

Этот алгоритм гарантирует равномерное распределение элементов между двумя новыми бакетами и обеспечивает однозначность при поиске.

## 7. Что такое равноразмерное рехеширование (same size growth) и когда оно применяется?

Равноразмерное рехеширование (same-size growth) — это особый тип рехеширования, при котором количество бакетов остается неизменным (B не увеличивается), но данные перераспределяются для оптимизации структуры:

```go
func hashGrow(h *hmap) {
    bigger := uint8(1) // По умолчанию - удвоение размера
    
    // Проверка условий для равноразмерного рехеширования
    if !overLoadFactor(h.count+1, h.B) {
        // Если проблема не в количестве элементов, а в избытке overflow-бакетов
        bigger = 0                // Не увеличиваем B
        h.flags |= sameSizeGrow   // Устанавливаем флаг
    }
    
    // Создаем новый массив бакетов того же размера
    oldbuckets := h.buckets
    newbuckets := newarray(buckettype, 1<<(h.B+bigger)) 
    // ...
}
```

Равноразмерное рехеширование применяется, когда:

1. Средний коэффициент загрузки в норме (<6.5 элементов на бакет)
2. Но образовалось непропорционально много overflow-бакетов
3. Обычно это результат многочисленных удалений или неравномерного распределения хешей

Цель этой операции — "спрямить" цепочки overflow-бакетов и улучшить локальность данных.

## 8. Как Go отслеживает прогресс эвакуации?

Go отслеживает прогресс эвакуации с помощью поля `nevacuate` в структуре hmap:

```go
type hmap struct {
    // ...
    nevacuate  uintptr  // индекс прогресса эвакуации
    // ...
}
```

Это поле хранит индекс следующего бакета, подлежащего эвакуации:

1. Изначально устанавливается в 0 при начале рехеширования
2. Увеличивается по мере эвакуации бакетов
3. Когда достигает размера старой таблицы (h.noldbuckets()), эвакуация завершена

Пример использования:

```go
// Продвижение эвакуации
func growWork(h *hmap, bucket uintptr) {
    // Эвакуируем бакет, к которому был доступ
    evacuate(h, bucket)
    
    // Эвакуируем следующий бакет в очереди
    evacuate(h, h.nevacuate)
    
    // Находим следующий неэвакуированный бакет
    for h.nevacuate < h.noldbuckets() {
        if !evacuated(h.oldbuckets, h.nevacuate) {
            break
        }
        h.nevacuate++
    }
    
    // Проверяем, завершена ли эвакуация
    if h.nevacuate == h.noldbuckets() {
        h.oldbuckets = nil  // Освобождаем старые бакеты
        // ...
    }
}
```

## 9. Какие операции с map могут вызвать продвижение процесса эвакуации?

Процесс эвакуации продвигается во время следующих операций с map:

1. **Доступ для чтения** (mapaccess):

   ```go
   // Если map находится в процессе роста, выполняем эвакуацию одного бакета
   if h.growing() {
       growWork(h, bucket)
   }
   ```

2. **Запись в map** (mapassign):

   ```go
   // При записи также продвигаем эвакуацию
   if h.growing() {
       growWork(h, bucket)
   }
   ```

3. **Удаление из map** (mapdelete):

   ```go
   // При удалении также продвигаем эвакуацию
   if h.growing() {
       growWork(h, bucket)
   }
   ```

4. **Инициализация итератора** (mapiterinit): перед началом итерации

Это обеспечивает равномерное продвижение эвакуации при нормальном использовании map. Каждая операция помогает "перенести" небольшую часть данных, распределяя нагрузку.

## 10. Каковы преимущества инкрементального подхода к рехешированию по сравнению с одномоментным?

Преимущества инкрементального рехеширования:

1. **Предсказуемая производительность**: отсутствие длительных пауз, более стабильное время отклика
2. **Равномерное распределение нагрузки**: операция "размазывается" по многим другим операциям
3. **Меньшее пиковое потребление памяти**: можно начать освобождать старые бакеты до завершения миграции
4. **Лучшая работа в системах реального времени**: критично для приложений с жесткими требованиями к отзывчивости
5. **Устойчивость к DoS-атакам**: атакующий не может вызвать длительную блокировку
6. **Более эффективное использование кеша**: меньшие порции данных лучше вписываются в кеш
7. **Сохранение отзывчивости программы**: пользователь не заметит "заикания" приложения
8. **Более разумное использование CPU**: меньшие пики нагрузки на процессор

Недостатки:

1. Более сложная реализация
2. Временное использование дополнительной памяти на протяжении всего процесса эвакуации
3. Дополнительные проверки при доступе к элементам во время эвакуации

В целом, инкрементальный подход обеспечивает лучший пользовательский опыт и более стабильную производительность.
