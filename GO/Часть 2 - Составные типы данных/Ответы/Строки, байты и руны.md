# Ответы: Строки, байты и руны

## 1. Как внутренне устроены строки в Go? Какая структура используется для их представления?

Строки в Go представляют собой неизменяемую последовательность байтов. Внутренне реализованы как структура `StringHeader` из пакета `reflect`, которая содержит указатель на массив байтов (`Data`) и длину строки в байтах (`Len`).

## 2. Почему строки в Go неизменяемы? Какие преимущества это дает?

Неизменяемость строк обеспечивает безопасность при передаче, упрощает конкурентное использование (не требуются блокировки), позволяет оптимизировать память (переиспользование, интернирование) и повышает производительность. Также обеспечивает предсказуемое поведение при доступе к строкам через переменные или при срезах строки.

## 3. В чем разница между байтами (byte) и рунами (rune) в Go?

`byte` — это псевдоним для `uint8`, представляет один байт и используется для работы на уровне байтов. `rune` — псевдоним для `int32`, представляет один Unicode-символ (code point) и используется для корректной обработки многобайтовых символов.

## 4. Как Go обрабатывает Unicode и многобайтовые символы в строках?

Go использует UTF-8 в качестве кодировки по умолчанию. Многобайтовые символы представлены последовательностью байтов согласно спецификации UTF-8. Для работы с отдельными символами используется тип `rune` и пакет `unicode/utf8`, который предоставляет функции для корректного декодирования, обработки и валидации UTF-8 последовательностей.

## 5. Что происходит при индексации строки? Почему нужно быть осторожным при работе с не-ASCII символами?

При индексации строки (`s[i]`) мы получаем доступ к конкретному байту, а не символу. Для не-ASCII символов, которые могут занимать несколько байтов, простая индексация может привести к получению части символа, а не целого символа. Для корректной работы с символами нужно использовать `for range` или пакет `unicode/utf8`.

## 6. Какие есть оптимальные способы конкатенации строк в Go?

1. Оператор `+` для небольшого количества строк
2. `strings.Builder` для большого количества конкатенаций (наиболее эффективный)
3. `bytes.Buffer` для смешанных типов данных
4. `fmt.Sprintf` при необходимости форматирования (но менее эффективный)
5. `strings.Join` для объединения слайса строк

## 7. Как работает преобразование между строками, байтами и рунами?

- `string([]byte)` — создает строку из слайса байтов (копирование)
- `[]byte(string)` — создает слайс байтов из строки (копирование)
- `string([]rune)` — преобразует руны в UTF-8 и создает строку
- `[]rune(string)` — декодирует UTF-8 строку в слайс рун
- `string('A')` — создает однобайтовую строку из руны
Каждое преобразование выполняет копирование данных, что важно для понимания производительности.

## 8. Какие оптимизации компилятор Go выполняет для операций со строками?

1. Интернирование строковых литералов (одинаковые литералы используют общий адрес в памяти)
2. Оптимизация конкатенации при компиляции для строковых литералов
3. Оптимизация `range` для строк с преобразованием в руны
4. Устранение лишних аллокаций при выполнении срезов строк
5. Использование SSE/AVX инструкций процессора для операций со строками

## 9. Как правильно итерировать по символам строки, а не по байтам?

```go
for i, r := range s {
    // i - индекс первого байта символа
    // r - сам символ в виде руны (int32)
}
```

или

```go
for i, w := 0, 0; i < len(s); i += w {
    r, width := utf8.DecodeRuneInString(s[i:])
    w = width
    // Обрабатываем руну r
}
```

## 10. Какие проблемы могут возникнуть при сравнении строк с не-ASCII символами?

1. Простое сравнение (`==`) сравнивает байты, игнорируя нормализацию Unicode (например, составные символы)
2. Разные формы нормализации Unicode для одного и того же текста дадут разные байтовые последовательности
3. Разные языки имеют разные правила сортировки и сравнения
4. Регистрозависимость может работать некорректно для многих языков

Для локализованного сравнения лучше использовать пакет `golang.org/x/text/collate`.
