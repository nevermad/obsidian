# Коллизии. Алгоритмы разрешения коллизий

## Краткий обзор

Коллизии в хеш-таблицах Go возникают, когда разные ключи дают одинаковые хеш-значения или попадают в один бакет. Go использует комбинацию нескольких стратегий для эффективного разрешения коллизий: бакеты фиксированного размера (до 8 пар ключ-значение), цепочки переполнения (overflow buckets) для дополнительных элементов и инкрементальное рехеширование при превышении порога заполнения. Особенность реализации в том, что Go применяет двухуровневую фильтрацию: сначала по верхним битам хеша (tophash), затем по полному сравнению ключей, что оптимизирует производительность. Эффективность разрешения коллизий критически влияет на производительность операций с map, особенно при большом количестве данных.

## Подробный разбор

### Природа коллизий в хеш-таблицах

Коллизии являются неизбежным явлением в хеш-таблицах по двум фундаментальным причинам:

1. **Принцип голубятни (Pigeonhole principle)**: Если хешируемых ключей больше, чем возможных значений хеш-функции, коллизии гарантированы
2. **Равномерное распределение**: Даже хорошая хеш-функция даёт случайное распределение, что приводит к коллизиям с определённой вероятностью

В Go коллизии возникают на двух уровнях:

1. **Коллизии бакетов**: Когда разные ключи отображаются в один бакет (младшие B бит хеша совпадают)
2. **Коллизии хешей**: Когда разные ключи дают одинаковое полное хеш-значение (крайне редко)

### Стратегия разрешения коллизий в Go

Go использует комбинированный подход к разрешению коллизий:

#### 1. Бакеты с фиксированной ёмкостью

Основа реализации — бакеты, способные хранить до 8 пар ключ-значение:

```go
// Упрощенная структура бакета
type bmap struct {
    tophash [8]uint8       // Старшие биты хеша для быстрой фильтрации
    // За этим следуют неявные поля:
    // keys     [8]keytype   // Массив ключей
    // values   [8]valuetype // Массив значений
    // overflow *bmap        // Указатель на дополнительный бакет
}
```

Бакеты позволяют размещать несколько элементов, имеющих коллизию, в одном месте, без дополнительных поисков по памяти.

#### 2. Цепочки переполнения (Overflow buckets)

Когда бакет заполняется (более 8 элементов), создается дополнительный бакет переполнения:

```go
// Псевдокод добавления элемента в переполненный бакет
func mapassign(h *hmap, key interface{}) {
    // ... поиск бакета и проверка наличия свободного места ...
    
    // Если бакет заполнен, ищем свободное место в цепочке overflow
    for b.overflow != nil {
        b = b.overflow
        // ... поиск свободного места в overflow-бакете ...
    }
    
    // Если и в цепочке переполнения нет места, создаем новый overflow-бакет
    if все бакеты полны {
        ovf := h.newoverflow()
        b.overflow = ovf
        // ... размещаем элемент в новом overflow-бакете ...
    }
}
```

Этот подход аналогичен методу цепочек (chaining) в классической теории хеш-таблиц, но с оптимизациями для локальности памяти.

#### 3. Двухуровневая фильтрация

Go оптимизирует поиск элемента в бакете с помощью двухуровневой фильтрации:

```go
// Псевдокод поиска ключа в бакете
func bucketsearch(b *bmap, hash uint32, key interface{}) (value interface{}, ok bool) {
    // Вычисляем tophash (верхние 8 бит хеша)
    top := uint8(hash >> 24)
    
    // Быстрая фильтрация по tophash (не требует сравнения ключей)
    for i := 0; i < 8; i++ {
        if b.tophash[i] == top {
            // Только для потенциальных совпадений выполняем полное сравнение
            k := add(unsafe.Pointer(b), dataOffset+i*keysize)
            if keyequal(k, key) {
                // Ключи совпали, возвращаем значение
                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*keysize+i*valuesize)
                return v, true
            }
        }
    }
    
    // Если не найдено, проверяем overflow-бакеты
    if b.overflow != nil {
        return bucketsearch(b.overflow, hash, key)
    }
    
    return nil, false
}
```

Эта стратегия значительно сокращает количество полных сравнений ключей, особенно в случаях, когда многие ключи попадают в один бакет.

### Управление эффективностью хеш-таблицы

#### Коэффициент заполнения (Load Factor)

Go оптимизирует производительность map, контролируя коэффициент заполнения:

```go
// Из runtime/map.go
// Оценка необходимости роста map
func mapassign(h *hmap, key unsafe.Pointer) unsafe.Pointer {
    // ...
    
    // Проверка условий для роста
    if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
        hashGrow(h)
        // ...
    }
    
    // ...
}

// Функция проверки коэффициента заполнения
func overLoadFactor(count int, B uint8) bool {
    // Порог загрузки при 13/2 элементов на бакет (6.5 в среднем)
    return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
}
```

Когда средняя загрузка бакета превышает 6.5 элементов, Go инициирует рост таблицы.

#### Типы роста таблицы

Go поддерживает два типа роста таблицы:

1. **Обычный рост (doubling)**: Удвоение количества бакетов (`h.B++`)
2. **Равноразмерный рост (same size growth)**: Сохранение количества бакетов, но перебалансировка элементов

```go
// Из runtime/map.go
func hashGrow(h *hmap) {
    // Вычисляем новое значение B
    bigger := uint8(1)
    if !overLoadFactor(h.count+1, h.B) {
        // Если нет перегрузки, но слишком много overflow бакетов,
        // выполняем равноразмерный рост для уменьшения цепочек
        bigger = 0
        h.flags |= sameSizeGrow
    }
    
    // Создаем новую таблицу бакетов
    oldbuckets := h.buckets
    newbuckets := newarray(buckettype, 1<<(h.B+bigger))
    
    // Обновляем состояние map
    h.B += bigger
    h.oldbuckets = oldbuckets
    h.buckets = newbuckets
    h.nevacuate = 0
    h.noverflow = 0
    
    // ...
}
```

Равноразмерный рост используется, когда коэффициент заполнения в норме, но образовалось слишком много цепочек переполнения.

### Сравнение с другими алгоритмами разрешения коллизий

#### Открытая адресация vs. Метод цепочек

Go использует модифицированный метод цепочек, который сочетает преимущества обоих классических подходов:

| Алгоритм | Преимущества | Недостатки | Как реализовано в Go |
|---|---|---|---|
| **Открытая адресация** | Более эффективное использование памяти, лучшая локальность | Кластеризация, сложная реализация удаления | В рамках одного бакета для 8 элементов |
| **Метод цепочек** | Простота, надежность при высокой загрузке | Дополнительные указатели, разбросанность данных | Между бакетами с оптимизацией размещения |

#### Линейное пробирование vs. Квадратичное пробирование vs. Двойное хеширование

Внутри бакета Go использует простой линейный поиск по tophash, что близко к линейному пробированию:

```go
// Псевдокод поиска по tophash
for i := 0; i < bucketCnt; i++ {
    if tophash[i] == top {
        // Проверяем совпадение ключа
    }
}
```

В отличие от квадратичного пробирования или двойного хеширования, этот подход:

- Более эффективен для кеш-памяти (линейное сканирование)
- Проще реализовать
- Работает хорошо для малого количества элементов (до 8)

### Особенности и рекомендации

#### Выбор хороших ключей для уменьшения коллизий

Для оптимальной производительности map в Go следует:

1. **Использовать примитивные типы**: числа и строки оптимизированы для хеширования
2. **Равномерно распределенные ключи**: избегать ключей, отличающихся только в нескольких битах
3. **Неизменяемые ключи**: изменение ключа после вставки в map приведет к некорректному поведению

```go
// Антипример: использование структуры с изменяемыми полями
type BadKey struct {
    ID   int
    Data []byte // изменяемый слайс
}

// Хороший пример: использование неизменяемых ключей
type GoodKey struct {
    ID   int
    Hash [32]byte // фиксированный массив
}
```

#### Предварительное резервирование ёмкости

Для уменьшения количества рехешрований:

```go
// Выделение map с указанием начальной ёмкости
m := make(map[string]int, 1000)
```

Это уменьшит частоту инкрементального рехеширования при добавлении элементов.

## Связи с другими темами

- [[Map. Внутреннее устройство]] — общая структура и организация map
- [[Map. Хэширование]] — как вычисляются хеши ключей
- [[Map. Бакеты]] — подробнее о структуре бакетов и как они используются
- [[Map. Эвакуация]] — процесс перемещения данных при рехешировании
- [[Производительность составных типов]] — влияние коллизий на производительность

## Источники информации

1. [Go Runtime: map.go](https://github.com/golang/go/blob/master/src/runtime/map.go)
2. [Russ Cox on Maps implementation](https://research.swtch.com/hwmm)
3. [Keith Randall's talk on Go map internals](https://www.youtube.com/watch?v=Tl7mi9QmLns)
4. [Go Blog: Maps in Action](https://go.dev/blog/maps)
5. [MIT OpenCourseWare: Hash Tables](https://www.youtube.com/watch?v=0M_kIqhwbFo)
6. [The Go Memory Model](https://golang.org/ref/mem)
7. [Analyzing Go's Map Implementation](https://medium.com/@sauravprakash/deep-dive-into-maps-in-go-c9538a1cf234)
8. [Dave Cheney: 5 things you don't know about maps in Go](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)
9. [Optimizing Hash Functions for Performance](https://www.youtube.com/watch?v=UQnFGES5Z_E)
