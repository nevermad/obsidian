# Map. Хэширование

## Краткий обзор

Хеширование в Go — это фундаментальный процесс преобразования данных произвольного размера в фиксированную битовую последовательность, который обеспечивает эффективную работу map. Go использует различные стратегии хеширования в зависимости от типа ключа, включая специализированные алгоритмы для строк и целых чисел. Ключевыми аспектами хеширования в Go являются: использование seed-значения для защиты от DoS-атак, оптимизация для различных архитектур (включая аппаратные инструкции на современных процессорах), эффективное распределение ключей по бакетам для минимизации коллизий и метод отбора битов хеша для разных целей (выбор бакета и фильтрация по tophash).

## Подробный разбор

### Принципы хеширования в Go

Хеширование в runtime Go базируется на следующих принципах:

1. **Детерминированность**: одинаковые входные данные всегда дают одинаковый результат
2. **Распределенность**: равномерное распределение хешей по всему диапазону значений
3. **Лавинный эффект**: небольшое изменение во входных данных приводит к значительному изменению хеша
4. **Эффективность**: быстрые вычисления даже для сложных типов данных
5. **Защита от атак**: использование seed-значения для предотвращения целенаправленных атак

### Алгоритмы хеширования для различных типов

Go использует разные хеш-функции в зависимости от типа ключа:

#### Целые числа

Для целых чисел применяются эффективные хеш-функции на основе побитовых операций:

```go
// Упрощенная версия хеширования для uint64
func hashUint64(x uint64, seed uint32) uint32 {
    // Смешивание с seed
    h := uint64(seed) + (x * 0x9ddfea08eb382d69)
    // Битовые манипуляции для улучшения распределения
    h ^= h >> 44
    h *= 0x9ddfea08eb382d69
    h ^= h >> 41
    h *= 0x9ddfea08eb382d69
    h ^= h >> 22
    return uint32(h)
}
```

Для разных размеров целых чисел применяются вариации этой функции.

#### Строки

Для строк Go использует оптимизированный алгоритм хеширования, адаптированный для различных архитектур:

```go
// Псевдокод хеширования строк
func hashString(s string, seed uint32) uint32 {
    if len(s) == 0 {
        return seed
    }
    
    // На современных процессорах используется аппаратное ускорение
    if hasAESInstructions() {
        return aesHash(s, seed)
    }

    // Стандартная реализация для других случаев
    h := seed
    for i := 0; i < len(s); i++ {
        h = h*16777619 ^ uint32(s[i])
    }
    return h
}
```

Go использует аппаратное ускорение на процессорах с поддержкой AES-NI, что значительно повышает производительность хеширования строк.

#### Составные типы

Для составных типов (структуры, массивы) Go рекурсивно хеширует компоненты:

```go
// Псевдокод хеширования структуры
func hashStruct(s struct, seed uint32) uint32 {
    h := seed
    
    // Хеширование полей структуры
    for каждого поля f в s {
        // Хеширование поля в зависимости от его типа
        fieldHash := hash(f, h)
        
        // Комбинирование хешей полей
        h = combine(h, fieldHash)
    }
    
    return h
}
```

Функция `combine` обеспечивает правильное смешивание хешей, чтобы разные комбинации полей давали различные финальные хеш-значения.

#### Интерфейсы

Для интерфейсов хеширование включает как тип, так и значение:

```go
func hashInterface(i interface{}, seed uint32) uint32 {
    // Получаем информацию о типе и значении
    typeInfo := reflect.TypeOf(i)
    value := reflect.ValueOf(i).Interface()
    
    // Хешируем тип
    h := hashString(typeInfo.String(), seed)
    
    // Хешируем значение в зависимости от его конкретного типа
    valueHash := hash(value, h)
    
    return combine(h, valueHash)
}
```

### Использование seed-значения

Каждая map в Go содержит уникальное seed-значение `hash0`, которое инициализируется при создании map:

```go
// Из runtime/map.go
func makemap(t *maptype, hint int, h *hmap) *hmap {
    // ...
    
    // Псевдослучайное seed для хеш-функции
    h.hash0 = fastrand()
    
    // ...
}
```

Это seed-значение:

1. **Предотвращает DoS-атаки**: Злоумышленник не может предсказать, какие ключи вызовут коллизии
2. **Рандомизирует распределение**: Даже если хеш-функция имеет слабости, seed добавляет случайность
3. **Уникально для каждой map**: Разные экземпляры map используют разные seed-значения

### Получение битов хеша для различных целей

Go использует различные биты хеша для разных целей:

```go
// Псевдокод из runtime/map.go
hash := alg.hash(key, h.hash0)

// Младшие B бит - для выбора бакета
bucketMask := bucketShift(h.B) - 1
bucket := hash & bucketMask

// Старшие 8 бит - для tophash (быстрая фильтрация)
top := uint8(hash >> (ptrSize*8 - 8))
```

1. **Выбор бакета**: Используются младшие B бит хеша, где B - логарифм количества бакетов (h.B)
2. **Значение tophash**: Используются старшие 8 бит хеша для быстрого отсеивания несовпадений

Такое разделение позволяет:

- Эффективно распределять элементы по бакетам
- Быстро фильтровать элементы внутри бакета без полного сравнения ключей

### Оптимизации хеширования

Go реализует несколько ключевых оптимизаций хеширования:

1. **Аппаратное ускорение**:

   ```go
   // Использование AES-NI инструкций на поддерживающих процессорах
   func aesHash(p unsafe.Pointer, s uintptr, seed uint32) uint32 {
       // Использует AESENC/AESENCLAST инструкции
       // ...
   }
   ```

2. **Специализированные функции для встроенных типов**:

   ```go
   // Из runtime/map.go
   // Различные алгоритмы для разных типов
   type typeAlg struct {
       // ...
       hash func(unsafe.Pointer, uintptr) uintptr
       // ...
   }
   ```

3. **Оптимизация распределения функций хеширования**:
   - Функции хеширования компилируются для каждого используемого типа ключа
   - Это позволяет устранить виртуальные вызовы и улучшить inline-оптимизацию

### Требования к эффективному хешированию в Go

Для создания пользовательских типов, эффективно работающих в качестве ключей map, необходимо:

1. **Реализовать метод сравнения**:

   ```go
   type Key struct {
       // ...
   }
   
   func (k1 Key) Equal(k2 Key) bool {
       // Сравнение ключей
   }
   ```

2. **Обеспечить стабильность ключей**:
   - Ключи не должны изменяться после добавления в map
   - Необходимо использовать копии, а не указатели, если данные могут меняться

## Связи с другими темами

- [[Map. Внутреннее устройство]] — как хеширование используется в map
- [[Map. Коллизии. Алгоритмы разрешения коллизий]] — что происходит при одинаковых хешах
- [[Map. Бакеты]] — как хеши определяют размещение в бакетах
- [[Производительность составных типов]] — влияние хеширования на производительность
- [[Структуры. Pointer receiver. Value receiver]] — особенности работы со структурами как ключами

## Источники информации

1. [Go Runtime: map.go](https://github.com/golang/go/blob/master/src/runtime/map.go)
2. [Go Runtime: hash.go](https://github.com/golang/go/blob/master/src/runtime/hash.go)
3. [Go Runtime: hash_x86.go](https://github.com/golang/go/blob/master/src/runtime/hash_x86.go)
4. [Go Blog: Maps in Action](https://go.dev/blog/maps)
5. [Keith Randall's Talk on Go Maps](https://www.youtube.com/watch?v=Tl7mi9QmLns)
6. [Mechanical Sympathy: Hardware and Software Working Together](https://mechanical-sympathy.blogspot.com/2012/03/native-cc-data-structures-are-not.html)
7. [AES-NI Hashing in Go](https://www.youtube.com/watch?v=DgcQT_ItxHM)
8. [Damian Gryski: Go Hashing Algorithms](https://github.com/dgryski/go-farm)
9. [Go Standard Library: hash package](https://golang.org/pkg/hash/)
