# Эвакуация

## Краткий обзор

Эвакуация в Go — это инкрементальный процесс переноса данных из старой хеш-таблицы в новую при изменении размера map. В отличие от традиционных реализаций, Go выполняет рехеширование постепенно: новые бакеты создаются сразу, но данные перемещаются небольшими порциями во время обычных операций с map. Это обеспечивает предсказуемое время выполнения всех операций. Процесс эвакуации включает перераспределение каждой пары ключ-значение в новые бакеты на основе дополнительного бита хеша, маркировку состояния ячеек специальными значениями tophash и отслеживание прогресса миграции. Go также поддерживает два типа рехеширования: увеличение размера вдвое и равноразмерное рехеширование для оптимизации цепочек переполнения.

## Подробный разбор

### Причины рехеширования и эвакуации

В Go рехеширование map (и последующая эвакуация данных) инициируется в двух случаях:

1. **Высокая средняя загрузка бакетов**: Когда средняя загрузка бакета превышает 6.5 элементов (из 8 возможных)
2. **Большое количество overflow-бакетов**: Когда образуется слишком много overflow-бакетов, даже если средняя загрузка не превышена

```go
// Псевдокод проверки необходимости роста map
func (h *hmap) needsToGrow() bool {
    // Проверка средней загрузки бакетов
    if h.count > 8*loadFactor*bucketShift(h.B) {
        return true
    }
    
    // Проверка количества overflow-бакетов
    if h.noverflow >= uint16(1<<(h.B&15)) {
        return true
    }
    
    return false
}
```

Где `loadFactor` в Go установлен как 6.5/8 = 0.8125, а `bucketShift(h.B)` возвращает `1 << h.B` (количество основных бакетов).

### Типы рехеширования

Go поддерживает два типа рехеширования:

1. **Обычное рехеширование (doubling)**: Увеличение количества бакетов в два раза (h.B++)
2. **Равноразмерное рехеширование (same size)**: Перераспределение без изменения размера для оптимизации цепочек overflow

```go
// Инициализация процесса рехеширования
func hashGrow(h *hmap) {
    // Определяем тип рехеширования
    bigger := uint8(1)
    if !overLoadFactor(h.count+1, h.B) {
        // Равноразмерное рехеширование
        bigger = 0
        h.flags |= sameSizeGrow
    }
    
    // Сохраняем старые бакеты
    oldbuckets := h.buckets
    
    // Создаем новую таблицу бакетов
    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
    
    // Обновляем состояние map
    h.B += bigger        // Увеличиваем размер (или не изменяем при same size)
    h.flags |= growing   // Устанавливаем флаг роста
    h.oldbuckets = oldbuckets  // Сохраняем указатель на старые бакеты
    h.buckets = newbuckets     // Устанавливаем указатель на новые бакеты
    h.nevacuate = 0            // Сбрасываем прогресс эвакуации
    h.noverflow = 0            // Сбрасываем счетчик overflow-бакетов
    
    // Настраиваем nextOverflow если необходимо
    if nextOverflow != nil {
        h.extra.nextOverflow = nextOverflow
    }
}
```

### Инкрементальная эвакуация

Ключевая особенность Go — инкрементальное рехеширование. Вместо единовременного переноса всех данных, эвакуация происходит постепенно:

```go
// Эвакуация одного или нескольких бакетов
func evacuate(h *hmap, oldbucket uintptr) {
    // Получаем указатель на старый бакет
    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
    
    // Вычисляем индексы новых бакетов (x и y)
    newbit := h.noldbuckets() // Дополнительный бит для выбора нового бакета
    
    // Создаем указатели на x и y бакеты
    // При равноразмерном рехешировании используется только x
    var (
        x      *bmap        // Бакет x (новый бакет с тем же индексом, что и старый)
        y      *bmap        // Бакет y (новый бакет с установленным дополнительным битом)
        xi int              // Индекс эвакуации для бакета x
        yi int              // Индекс эвакуации для бакета y
    )
    
    // Подготавливаем бакеты назначения
    x = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
    if !h.sameSizeGrow() {
        // При обычном рехешировании нужны оба бакета x и y
        y = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
    }
    
    // Эвакуация всех элементов из старого бакета и его overflow-цепочки
    for ; b != nil; b = b.overflow(t) {
        // Обрабатываем все ячейки в бакете
        for i := uintptr(0); i < bucketCnt; i++ {
            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
            v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
            
            // Проверяем состояние tophash
            top := b.tophash[i]
            if isEmpty(top) {
                // Ячейка пуста - маркируем как эвакуированную
                b.tophash[i] = evacuatedEmpty
                continue
            }
            
            // Маркируем ячейку как эвакуированную
            b.tophash[i] = evacuatedX
            
            // Определяем, куда перемещать элемент: в x или y бакет
            // Это зависит от дополнительного бита хеша
            if !h.sameSizeGrow() {
                // Вычисляем хеш ключа
                hash := t.hasher(k, uintptr(h.hash0))
                
                // Проверяем дополнительный бит
                if hash&newbit != 0 {
                    // Бит установлен - перемещаем в y бакет
                    b.tophash[i] = evacuatedY
                    
                    // Добавляем элемент в y бакет
                    if yi == bucketCnt {
                        // y бакет заполнен, создаем overflow бакет
                        y = h.newoverflow(t, y)
                        yi = 0
                    }
                    
                    // Копируем данные в новую ячейку
                    y.tophash[yi] = top
                    typedmemmove(t.key, add(unsafe.Pointer(y), dataOffset+yi*uintptr(t.keysize)), k)
                    typedmemmove(t.elem, add(unsafe.Pointer(y), dataOffset+bucketCnt*uintptr(t.keysize)+yi*uintptr(t.valuesize)), v)
                    yi++
                    continue
                }
            }
            
            // Добавляем элемент в x бакет
            if xi == bucketCnt {
                // x бакет заполнен, создаем overflow бакет
                x = h.newoverflow(t, x)
                xi = 0
            }
            
            // Копируем данные в новую ячейку
            x.tophash[xi] = top
            typedmemmove(t.key, add(unsafe.Pointer(x), dataOffset+xi*uintptr(t.keysize)), k)
            typedmemmove(t.elem, add(unsafe.Pointer(x), dataOffset+bucketCnt*uintptr(t.keysize)+xi*uintptr(t.valuesize)), v)
            xi++
        }
    }
    
    // В этот момент бакет полностью эвакуирован
}
```

Эвакуация выполняется инкрементально в нескольких ключевых местах:

1. **При доступе к map** (mapaccess)
2. **При изменении map** (mapassign)
3. **При удалении из map** (mapdelete)
4. **При выполнении итерации** (mapiterinit, mapiternext)

### Маркировка и отслеживание состояния эвакуации

Go использует специальные значения `tophash` для отслеживания состояния эвакуации:

```go
// Константы для маркировки состояния ячеек
const (
    emptyRest      = 0  // Ячейка пуста, и все следующие тоже пусты
    emptyOne       = 1  // Ячейка пуста
    evacuatedX     = 2  // Ключ/значение эвакуированы в бакет X (нижняя половина)
    evacuatedY     = 3  // Ключ/значение эвакуированы в бакет Y (верхняя половина)
    evacuatedEmpty = 4  // Ячейка была пуста и отмечена как эвакуированная
    minTopHash     = 5  // Минимальное значение tophash для обычных ключей
)
```

Эти маркеры позволяют:
1. Знать, что элемент уже перемещен в новую таблицу
2. Определить, в какой именно бакет (X или Y) был перемещен элемент
3. Корректно обрабатывать доступ к map в момент рехеширования

### Механизм перераспределения при увеличении размера

При увеличении размера map вдвое (h.B++), каждый старый бакет расщепляется на два новых бакета:

```
 Старая таблица (размер 2^B):              Новая таблица (размер 2^(B+1)):
 +----------------+                         +----------------+
 | Бакет 0        |      ------->          | Бакет 0 (X)    |
 +----------------+     /                   +----------------+
 | Бакет 1        |    /                    | Бакет 1 (X)    |
 +----------------+   /                     +----------------+
 | ...            |  /                      | ...            |
 +----------------+ /                       +----------------+
 | Бакет i        | ---                     | Бакет i (X)    |
 +----------------+    \                    +----------------+
 | ...            |     \                   | ...            |
 +----------------+      \                  +----------------+
                          ------->          | Бакет i+2^B (Y)|
                                           +----------------+
                                           | ...            |
                                           +----------------+
```

Принцип перераспределения основан на дополнительном бите хеша:

```go
// Определение, в какой бакет (X или Y) попадет ключ
func evacuateKey(key interface{}, hash uintptr, newbit uintptr) (xoryFlag uint8) {
    // Если (hash & newbit) == 0, то ключ остается в бакете X
    // Если (hash & newbit) != 0, то ключ перемещается в бакет Y
    if hash&newbit == 0 {
        return evacuatedX
    }
    return evacuatedY
}
```

Здесь `newbit` равен `1 << h.B`, то есть дополнительному биту, который появляется при увеличении размера map вдвое.

### Отслеживание прогресса эвакуации

Go отслеживает прогресс эвакуации с помощью поля `nevacuate` в структуре `hmap`:

```go
// Определение, завершена ли эвакуация
func (h *hmap) growing() bool {
    return h.oldbuckets != nil
}

// Продвижение эвакуации на несколько шагов
func (h *hmap) growWork(bucket uintptr) {
    // Эвакуируем текущий бакет
    evacuate(h, bucket)
    
    // Эвакуируем еще один бакет по порядку
    evacuate(h, h.nevacuate)
    
    // Продвигаем указатель прогресса
    h.nevacuate++
    
    // Если все бакеты эвакуированы, завершаем процесс
    if h.nevacuate >= h.noldbuckets() {
        h.oldbuckets = nil  // Освобождаем ссылку на старые бакеты
        h.extra.oldoverflow = nil  // Освобождаем ссылку на старые overflow-бакеты
        h.flags &^= growing  // Снимаем флаг роста
    }
}
```

Поле `nevacuate` содержит индекс следующего бакета, подлежащего эвакуации. Когда `nevacuate` достигает общего количества бакетов, эвакуация считается завершенной.

### Доступ к map во время эвакуации

Важная особенность — обе таблицы (старая и новая) остаются доступными во время эвакуации:

```go
// Псевдокод поиска ключа в map во время эвакуации
func mapaccess(h *hmap, key interface{}) (value interface{}, ok bool) {
    // ... вычисление хеша и индекса бакета ...
    
    // Проверяем, идет ли рехеширование
    if h.growing() {
        // Вычисляем индекс в старой таблице
        oldbucket := bucket & (h.noldbuckets() - 1)
        
        // Проверяем, был ли эвакуирован этот бакет
        if !evacuated(h.oldbuckets, oldbucket) {
            // Бакет еще не эвакуирован, ищем в старой таблице
            b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
        }
        
        // Продвигаем эвакуацию
        if outdated {
            // Эвакуируем несколько бакетов
            growWork(h, oldbucket)
        }
    }
    
    // ... поиск ключа в бакете ...
}
```

Этот механизм обеспечивает согласованность данных во время рехеширования:
1. Новые данные всегда добавляются в новую таблицу
2. Поиск сначала проверяет, эвакуирован ли соответствующий бакет
3. В зависимости от состояния, поиск происходит либо в старой, либо в новой таблице

### Равноразмерное рехеширование

Особый случай — равноразмерное рехеширование (same size growth), которое выполняется, когда количество overflow-бакетов становится слишком большим:

```go
// Проверка на необходимость равноразмерного рехеширования
func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
    // Если B < 16, то пороговое значение равно 2^B
    // Если B >= 16, то пороговое значение равно 2^15
    return noverflow >= uint16(1<<min(B, 15))
}
```

При равноразмерном рехешировании:
1. Количество бакетов не меняется (h.B остается тем же)
2. Создается новый массив бакетов того же размера
3. Перераспределение выполняется для уменьшения длины цепочек overflow
4. Используется только бакет X для перемещения всех элементов (бакет Y не задействован)

Это позволяет оптимизировать структуру map без увеличения ее размера.

### Безопасная очистка

После завершения эвакуации, старые бакеты и связанные с ними структуры данных могут быть безопасно удалены:

```go
// Проверка завершения эвакуации и очистка
func (h *hmap) checkEvacuated() {
    if h.nevacuate >= h.noldbuckets() {
        // Все бакеты эвакуированы
        h.oldbuckets = nil  // Освобождаем ссылку на старые бакеты
        h.extra.oldoverflow = nil  // Освобождаем ссылку на старые overflow-бакеты
        h.flags &^= growing  // Снимаем флаг роста
    }
}
```

Сборщик мусора Go автоматически освободит память, занимаемую старыми бакетами, когда на них не останется ссылок.

## Связи с другими темами

- [[Map. Внутреннее устройство]] — общая структура map, частью которой является эвакуация
- [[Map. Хэширование]] — как хеш-значения используются для распределения элементов
- [[Map. Коллизии. Алгоритмы разрешения коллизий]] — как избыток коллизий приводит к рехешированию
- [[Map. Бакеты]] — устройство бакетов, с которыми работает механизм эвакуации
- [[Производительность составных типов]] — влияние инкрементальной эвакуации на производительность

## Источники информации

1. [Go Runtime: map.go](https://github.com/golang/go/blob/master/src/runtime/map.go)
2. [Keith Randall's talk on Go Map Internals](https://www.youtube.com/watch?v=Tl7mi9QmLns)
3. [Go Blog: Maps in Action](https://go.dev/blog/maps)
4. [Go Runtime Map Internals Analysis](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)
5. [Inside the Map Implementation](https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html)
6. [Map Growth and Rehashing in Go](https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed)
7. [Incremental Resizing in Hash Tables](https://en.wikipedia.org/wiki/Hash_table#Incremental_resizing)
8. [Go Maps Under the Hood](https://www.digitalocean.com/community/tutorials/understanding-maps-in-go)
9. [Optimization Techniques in Go](https://www.youtube.com/watch?v=GRr4xeMn1uU) 