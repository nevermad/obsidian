# Slice. Внутреннее устройство

## Краткий обзор

Slice (срез) в Go — это динамическая структура данных, представляющая собой "окно просмотра" в базовый массив. В отличие от массивов, которые имеют фиксированную длину и являются частью типа, слайсы имеют переменную длину и состоят из трех компонентов: указателя на базовый массив, длины и емкости. Слайсы обеспечивают гибкость при работе с последовательностями данных, позволяя эффективно добавлять, удалять и изменять элементы. Внутренняя реализация слайсов оптимизирована для минимизации аллокаций памяти и максимальной производительности при сохранении удобного API.

## Подробный разбор

### Отличия массивов и слайсов

#### Массивы в Go

Массивы в Go имеют следующие характеристики:

1. **Фиксированная длина**: Размер массива является частью его типа

   ```go
   var a [5]int // Тип [5]int
   var b [10]int // Тип [10]int - другой тип!
   ```

2. **Передача по значению**: При передаче массива в функцию создается его копия

   ```go
   func modify(arr [5]int) {
       arr[0] = 100 // Изменяет копию, не оригинал
   }
   ```

3. **Размещение в памяти**: Массивы обычно размещаются на стеке, если компилятор не определит необходимость размещения в куче

   ```go
   // Вероятно, будет на стеке
   var smallArray [10]int
   
   // Вероятно, будет в куче
   var largeArray [10000]int
   ```

4. **Сравнимость**: Массивы одинакового типа можно сравнивать с помощью операторов `==` и `!=`

   ```go
   a := [3]int{1, 2, 3}
   b := [3]int{1, 2, 3}
   fmt.Println(a == b) // true
   ```

#### Слайсы в Go

Слайсы имеют следующие характеристики:

1. **Динамическая длина**: Размер слайса может изменяться во время выполнения

   ```go
   s := []int{1, 2, 3}
   s = append(s, 4, 5) // Теперь s содержит [1, 2, 3, 4, 5]
   ```

2. **Передача по ссылке**: Слайсы передаются по ссылке (технически, по значению, но значение содержит указатель)

   ```go
   func modify(slice []int) {
       slice[0] = 100 // Изменяет оригинальный слайс
   }
   ```

3. **Размещение в памяти**: Структура слайса (заголовок) обычно на стеке, но базовый массив часто в куче

   ```go
   // Заголовок на стеке, данные вероятно в куче
   s := make([]int, 1000)
   ```

4. **Несравнимость**: Слайсы нельзя напрямую сравнивать с помощью `==` и `!=` (кроме сравнения с `nil`)

   ```go
   a := []int{1, 2, 3}
   // fmt.Println(a == b) // Ошибка компиляции
   fmt.Println(a == nil) // false - это допустимо
   ```

### Внутреннее устройство слайсов

#### Структура слайса

Внутренне слайс представлен структурой `reflect.SliceHeader`:

```go
type SliceHeader struct {
    Data uintptr // указатель на базовый массив
    Len  int     // количество элементов в слайсе
    Cap  int     // емкость базового массива от начала слайса
}
```

Визуально это можно представить так:

```
Слайс: +--------+------+------+
       | Data   | Len  | Cap  |
       +---|----+------+------+
           |
           v
Массив: +-----+-----+-----+-----+-----+-----+
        |  0  |  1  |  2  |  3  |  4  |  5  |
        +-----+-----+-----+-----+-----+-----+
```

#### Создание слайсов

Существует несколько способов создания слайсов:

1. **Литеральная нотация**:

   ```go
   s := []int{1, 2, 3, 4, 5}
   ```

2. **Функция make**:

   ```go
   s := make([]int, 5)      // len=5, cap=5
   s := make([]int, 0, 10)  // len=0, cap=10
   ```

3. **Срез массива или другого слайса**:

   ```go
   a := [5]int{1, 2, 3, 4, 5}
   s := a[1:4]  // [2, 3, 4], len=3, cap=4
   ```

4. **Нулевое значение**:

   ```go
   var s []int  // nil slice, len=0, cap=0
   ```

#### Операции со слайсами

##### Срезы (slicing)

Операция среза создает новый слайс, указывающий на тот же базовый массив:

```go
s := []int{1, 2, 3, 4, 5}
s1 := s[1:3]  // [2, 3], len=2, cap=4
```

Важно понимать, что при срезе:

- Создается новый заголовок слайса
- Указатель Data смещается на соответствующее количество элементов
- Len устанавливается как high - low
- Cap устанавливается как cap(original) - low

##### Добавление элементов (append)

Функция `append` добавляет элементы к слайсу:

```go
s := []int{1, 2, 3}
s = append(s, 4, 5)  // [1, 2, 3, 4, 5]
```

Внутренняя работа `append`:

1. Проверяет, достаточно ли емкости для добавления элементов
2. Если емкости достаточно, добавляет элементы в существующий массив
3. Если емкости недостаточно, выделяет новый массив с увеличенной емкостью, копирует элементы и добавляет новые

##### Копирование слайсов (copy)

Функция `copy` копирует элементы из одного слайса в другой:

```go
src := []int{1, 2, 3, 4, 5}
dst := make([]int, 3)
n := copy(dst, src)  // n = 3, dst = [1, 2, 3]
```

### Расширенные концепции слайсов (CTO Level)

#### Стратегия роста емкости

Когда емкости слайса недостаточно для операции `append`, Go выделяет новый массив с увеличенной емкостью. Алгоритм роста емкости в Go:

```go
// Псевдокод алгоритма роста емкости
func growSlice(oldCap, newLen int) int {
    if oldCap == 0 {
        return newLen
    }
    
    // Удваиваем емкость для небольших слайсов
    newCap := oldCap * 2
    
    // Для больших слайсов увеличиваем на 25%
    if newCap > 1024 {
        newCap = oldCap + oldCap/4
    }
    
    // Убеждаемся, что новая емкость достаточна
    if newCap < newLen {
        newCap = newLen
    }
    
    return newCap
}
```

Реальный алгоритм в Go немного сложнее и учитывает размер элемента и выравнивание памяти.

#### Внутренняя реализация в runtime

В исходном коде Go (runtime/slice.go) можно найти реальную реализацию операций со слайсами:

```go
// Упрощенная версия реальной реализации append
func growslice(et *_type, old slice, cap int) slice {
    newcap := old.cap
    doublecap := newcap + newcap
    if cap > doublecap {
        newcap = cap
    } else {
        if old.cap < 1024 {
            newcap = doublecap
        } else {
            for newcap < cap {
                newcap += newcap / 4
            }
        }
    }
    
    // Выравнивание и другие оптимизации...
    
    var p unsafe.Pointer
    if et.ptrdata == 0 {
        p = mallocgc(capmem, nil, false)
        memclrNoHeapPointers(p, capmem)
    } else {
        p = mallocgc(capmem, et, true)
    }
    
    memmove(p, old.array, lenmem)
    
    return slice{p, old.len, newcap}
}
```

#### Оптимизации компилятора для слайсов

Компилятор Go выполняет ряд оптимизаций для операций со слайсами:

1. **Bounds Check Elimination (BCE)**: Устранение проверок границ в циклах

   ```go
   // Компилятор может устранить проверку границ для s[i]
   for i := 0; i < len(s); i++ {
       sum += s[i]
   }
   ```

2. **Предварительное выделение памяти**: Оптимизация аллокаций при известном размере

   ```go
   // Компилятор может оптимизировать это в одну аллокацию
   s := make([]int, 0, n)
   for i := 0; i < n; i++ {
       s = append(s, i)
   }
   ```

3. **Escape Analysis**: Определение, когда слайс может быть размещен на стеке

   ```go
   // Может быть размещен на стеке, если не "убегает"
   func sum(values []int) int {
       result := 0
       for _, v := range values {
           result += v
       }
       return result
   }
   ```

#### Производительность и оптимизации

##### Предварительное выделение памяти

Для оптимальной производительности рекомендуется предварительно выделять память:

```go
// Неэффективно: многократные аллокации
var data []int
for i := 0; i < 10000; i++ {
    data = append(data, i)
}

// Эффективно: однократное выделение
data := make([]int, 0, 10000)
for i := 0; i < 10000; i++ {
    data = append(data, i)
}
```

##### Повторное использование слайсов

Для минимизации сборки мусора можно повторно использовать слайсы:

```go
// Очистка слайса без выделения новой памяти
data = data[:0]
```

##### Избегание ненужных копий

При работе с большими слайсами важно избегать ненужных копий:

```go
// Неэффективно: копирует весь слайс
func processLarge(data []int) []int {
    result := data // Создает новый заголовок, но указывает на тот же массив
    // Если result изменится и потребуется рост, будет скопирован весь data
    return append(result, 42)
}

// Эффективно: создает новый слайс с нужной емкостью
func processLargeEfficient(data []int) []int {
    result := make([]int, len(data), len(data)+1)
    copy(result, data)
    return append(result, 42)
}
```

#### Подводные камни при работе со слайсами

##### Неожиданные изменения базового массива

Поскольку несколько слайсов могут указывать на один базовый массив, изменения в одном слайсе могут влиять на другие:

```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3]  // [2, 3]
s2[0] = 42     // Изменяет s1[1]
fmt.Println(s1) // [1, 42, 3, 4, 5]
```

##### Неожиданное поведение append

Функция `append` может изменить базовый массив, если есть достаточная емкость:

```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3]  // [2, 3], cap=4
s2 = append(s2, 6)  // [2, 3, 6], изменяет s1[3]
fmt.Println(s1) // [1, 2, 3, 6, 5]
```

Но если емкости недостаточно, создается новый массив:

```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3]  // [2, 3], cap=4
s2 = append(s2, 6, 7, 8)  // Превышает емкость, создается новый массив
s2[0] = 42  // Не влияет на s1
fmt.Println(s1) // [1, 2, 3, 4, 5]
```

##### Утечки памяти со слайсами

Слайсы могут вызывать утечки памяти, если маленький слайс ссылается на большой базовый массив:

```go
func getFirstN(data []int, n int) []int {
    return data[:n]  // Возвращает маленький слайс, но удерживает весь базовый массив
}

// Лучший подход
func getFirstNCopy(data []int, n int) []int {
    result := make([]int, n)
    copy(result, data[:n])
    return result
}
```

#### Внутренние детали реализации в runtime

##### Выделение памяти для слайсов

Go использует разные стратегии выделения памяти в зависимости от размера слайса:

1. **Tiny аллокации** (< 16 байт): Используется специальный аллокатор для маленьких объектов
2. **Малые аллокации** (16-32KB): Используются размерные классы и span'ы
3. **Большие аллокации** (>32KB): Выделяются напрямую из кучи

```go
// Упрощенная логика выделения памяти для слайса
func mallocSlice(et *_type, len, cap int) unsafe.Pointer {
    size := uintptr(cap) * et.size
    if size <= maxSmallSize {
        // Малая аллокация
        return smallAlloc(size)
    }
    // Большая аллокация
    return largeAlloc(size)
}
```

##### Оптимизации для слайсов с элементами-указателями

Для слайсов, содержащих указатели, runtime применяет специальные оптимизации:

1. **Барьеры записи**: Для корректной работы сборщика мусора
2. **Специальная обработка при копировании**: Учитывает указатели для корректной работы GC

```go
// Псевдокод для копирования слайса с указателями
func copySlice(toPtr, fromPtr unsafe.Pointer, toLen, fromLen int, width uintptr) int {
    n := fromLen
    if toLen < n {
        n = toLen
    }
    
    if width == ptrSize {
        // Оптимизированное копирование для слайсов указателей
        memmove(toPtr, fromPtr, uintptr(n)*ptrSize)
        // Барьеры записи для GC
        bulkBarrierPreWrite(toPtr, uintptr(n)*ptrSize)
    } else {
        // Обычное копирование
        memmove(toPtr, fromPtr, uintptr(n)*width)
    }
    
    return n
}
```

#### Оптимизации на уровне ассемблера

Некоторые операции со слайсами оптимизированы на уровне ассемблера для максимальной производительности:

1. **Копирование**: Использует оптимизированные инструкции для копирования блоков памяти
2. **Очистка**: Использует специальные инструкции для быстрой очистки памяти
3. **SIMD-инструкции**: Для операций с числовыми слайсами

```asm
// Пример ассемблерного кода для копирования на x86-64
TEXT runtime·memmove(SB), NOSPLIT, $0-24
    MOVQ    to+0(FP), DI
    MOVQ    from+8(FP), SI
    MOVQ    n+16(FP), CX
    
    // Проверка на перекрытие
    CMPQ    SI, DI
    JLS     back
    
    // Прямое копирование
    CLD
    REP; MOVSB
    RET
    
back:
    // Обратное копирование для перекрывающихся областей
    ADDQ    CX, SI
    ADDQ    CX, DI
    STD
    DECQ    SI
    DECQ    DI
    REP; MOVSB
    CLD
    RET
```

### Практические шаблоны и оптимизации (CTO Level)

#### Пул слайсов для повторного использования

Для высоконагруженных систем можно реализовать пул слайсов:

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        buffer := make([]byte, 0, 4096)
        return &buffer
    },
}

func processRequest() {
    // Получаем буфер из пула
    bufPtr := bufferPool.Get().(*[]byte)
    buf := (*bufPtr)[:0] // Сбрасываем длину, сохраняя емкость
    
    // Используем буфер...
    
    // Возвращаем в пул
    bufferPool.Put(bufPtr)
}
```

#### Оптимизация для append с известным количеством элементов

Когда известно точное количество добавляемых элементов, можно оптимизировать append:

```go
// Неоптимально: может вызвать несколько перевыделений
for _, item := range items {
    result = append(result, process(item))
}

// Оптимально: однократное выделение
result := make([]T, 0, len(items))
for _, item := range items {
    result = append(result, process(item))
}
```

#### Использование небезопасных операций для максимальной производительности

В критических по производительности участках можно использовать пакет `unsafe`:

```go
// Преобразование []byte в string без копирования
func bytesToStringFast(b []byte) string {
    return *(*string)(unsafe.Pointer(&reflect.SliceHeader{
        Data: uintptr(unsafe.Pointer(&b[0])),
        Len:  len(b),
        Cap:  len(b),
    }))
}

// В Go 1.20+ более безопасный способ:
func bytesToStringFast(b []byte) string {
    return unsafe.String(unsafe.SliceData(b), len(b))
}
```

#### Оптимизация фильтрации слайсов

Эффективная фильтрация без создания промежуточных слайсов:

```go
// Фильтрация на месте
func filterInPlace(s []int, keep func(int) bool) []int {
    n := 0
    for _, x := range s {
        if keep(x) {
            s[n] = x
            n++
        }
    }
    return s[:n]
}
```

#### Использование слайсов фиксированного размера для стековых аллокаций

Для небольших слайсов можно использовать массивы фиксированного размера:

```go
// Вероятно, будет размещен в куче
func processItems(items []int) []int {
    result := make([]int, 0, len(items))
    // ...
    return result
}

// Вероятно, будет размещен на стеке
func processItemsStack(items []int) []int {
    var buffer [64]int // Фиксированный размер на стеке
    result := buffer[:0]
    
    for i, item := range items {
        if i >= len(buffer) {
            // Переходим к динамическому выделению только при необходимости
            temp := make([]int, len(result), len(items))
            copy(temp, result)
            result = temp
        }
        result = append(result, item*2)
    }
    
    return result
}
```

#### Оптимизация сортировки слайсов

Для часто сортируемых слайсов можно использовать специализированные алгоритмы:

```go
// Оптимизация для почти отсортированных слайсов
func sortOptimized(data []int) {
    // Проверяем, почти ли отсортирован слайс
    isSorted := true
    for i := 1; i < len(data); i++ {
        if data[i] < data[i-1] {
            isSorted = false
            break
        }
    }
    
    if isSorted {
        // Используем insertion sort для почти отсортированных данных
        for i := 1; i < len(data); i++ {
            for j := i; j > 0 && data[j] < data[j-1]; j-- {
                data[j], data[j-1] = data[j-1], data[j]
            }
        }
    } else {
        // Используем стандартную сортировку
        sort.Ints(data)
    }
}
```

## Связанные заметки

- [[Базовые типы данных]]
- [[Указатели]]
- [[Куча и стек. Escape Analysis]]
- [[Строки. Байты. Руны]]
- [[Map. Внутреннее устройство]]

## Источники

- [Go Slices: usage and internals](https://go.dev/blog/slices-intro)
- [Go Specification: Slice types](https://golang.org/ref/spec#Slice_types)
- [Go Specification: Slice expressions](https://golang.org/ref/spec#Slice_expressions)
- [Go Specification: Making slices, maps and channels](https://golang.org/ref/spec#Making_slices_maps_and_channels)
- [Go Specification: Appending to and copying slices](https://golang.org/ref/spec#Appending_and_copying_slices)
- [Go Source Code: runtime/slice.go](https://github.com/golang/go/blob/master/src/runtime/slice.go)
- [Go Source Code: runtime/malloc.go](https://github.com/golang/go/blob/master/src/runtime/malloc.go)
- [Go 101: Slices in Go](https://go101.org/article/slice.html)
- [Dave Cheney: Slices from the ground up](https://dave.cheney.net/2018/07/12/slices-from-the-ground-up)
- [Russ Cox: Arrays, slices (and strings): The mechanics of 'append'](https://blog.golang.org/slices)
- [Go Internals: Slices](https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md)
- [Go Performance Optimizations](https://github.com/dgryski/go-perfbook)
