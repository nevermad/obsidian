# Массивы и их отличия от Slice

## Краткий обзор

Массив в Go — это фиксированная последовательность элементов одного типа, размер которой определяется на этапе компиляции и является частью типа массива. В отличие от слайсов, массивы в Go — это значения, а не ссылки, поэтому при присваивании или передаче массива в функцию создается полная копия. Основные отличия массивов от слайсов: массивы имеют фиксированный размер, являются значениями, а не ссылками, более эффективны для небольших последовательностей данных фиксированного размера, но гораздо менее гибкие. Компилятор может оптимизировать размещение массивов на стеке, а не в куче, что повышает производительность, но ограничивает применимость.

## Подробный разбор

### Определение и инициализация массивов

В Go массив — это нумерованная последовательность элементов одного типа с фиксированной длиной. Размер массива является частью его типа:

```go
// Объявление массива из 5 целых чисел
var arr [5]int

// Объявление с инициализацией
arr2 := [3]string{"Go", "Rust", "C++"}

// Инициализация с автоматическим определением размера
arr3 := [...]int{1, 2, 3, 4, 5} // Компилятор определит размер 5

// Инициализация с пропусками
arr4 := [10]int{0: 5, 2: 10, 5: 15} // [5 0 10 0 0 15 0 0 0 0]
```

### Внутреннее представление массивов

Массивы в Go представлены непрерывным блоком памяти. В отличие от C/C++, название массива в Go не является указателем на первый элемент, а представляет весь массив как значение:

```go
// Внутреннее представление массива [5]int: [размер: 5*8 байт]
// [элемент0][элемент1][элемент2][элемент3][элемент4]
//    8 байт   8 байт    8 байт     8 байт    8 байт
```

Из-за такого представления при присваивании массива происходит копирование всех его элементов:

```go
a := [5]int{1, 2, 3, 4, 5}
b := a  // Создается полная копия массива a
b[0] = 10 // Изменение b не влияет на a
fmt.Println(a[0]) // Выведет 1
fmt.Println(b[0]) // Выведет 10
```

### Ключевые отличия массивов от слайсов

#### 1. Тип и размер

**Массивы**:

- Размер является частью типа: `[5]int` и `[10]int` — это разные типы
- Размер определяется на этапе компиляции
- Фиксированная длина, которая не может быть изменена

**Слайсы**:

- Все слайсы одного базового типа имеют одинаковый тип: `[]int`
- Динамический размер, который может меняться во время выполнения
- Могут расти и уменьшаться

#### 2. Семантика присваивания

**Массивы**:

- Семантика значений (value semantics)
- При присваивании массива создается его полная копия
- Изменение элементов копии не влияет на оригинал

```go
a := [3]int{1, 2, 3}
b := a  // Полное копирование всех элементов
b[0] = 99
fmt.Println(a) // [1 2 3]
fmt.Println(b) // [99 2 3]
```

**Слайсы**:

- Семантика ссылок (reference semantics)
- При присваивании слайса создается ссылка на тот же базовый массив
- Изменение элементов в копии влияет на оригинал

```go
a := []int{1, 2, 3}
b := a  // Создание ссылки на тот же базовый массив
b[0] = 99
fmt.Println(a) // [99 2 3]
fmt.Println(b) // [99 2 3]
```

#### 3. Передача в функции

**Массивы**:

- Передаются по значению, создавая полную копию
- Изменения в функции не влияют на оригинал
- Передача больших массивов неэффективна из-за копирования

```go
func modify(arr [3]int) {
    arr[0] = 100 // Изменяется только локальная копия
}

a := [3]int{1, 2, 3}
modify(a)
fmt.Println(a) // [1 2 3] - оригинал не изменился
```

**Слайсы**:

- Передаются по ссылке (технически, копируется дескриптор слайса)
- Изменения в функции отражаются на оригинале
- Эффективны для передачи даже больших коллекций

```go
func modify(slc []int) {
    slc[0] = 100 // Изменяется оригинальный базовый массив
}

a := []int{1, 2, 3}
modify(a)
fmt.Println(a) // [100 2 3] - оригинал изменился
```

#### 4. Размещение в памяти и производительность

**Массивы**:

- Компилятор может размещать небольшие массивы на стеке
- Не требуют дополнительных аллокаций в куче
- Меньше нагрузка на сборщик мусора
- Лучшая локальность данных (cache locality)

**Слайсы**:

- Базовый массив обычно размещается в куче
- Требуют аллокации памяти во время выполнения
- Создают дополнительную нагрузку на сборщик мусора
- Могут иметь проблемы с локальностью при многократном расширении

#### 5. Использование в интерфейсах и возможности

**Массивы**:

- Не реализуют никаких встроенных интерфейсов (например, не могут напрямую использоваться с `range`)
- Нельзя добавлять или удалять элементы
- Не поддерживают `append`, `copy` и другие функции слайсов

**Слайсы**:

- Реализуют множество функциональности через встроенные функции
- Поддерживают `append`, `copy`, срезы
- Могут быть переданы функциям, ожидающим вариативные параметры (`...T`)

### Оптимизации компилятора для массивов

Компилятор Go выполняет ряд оптимизаций для массивов:

1. **Escape-анализ**:
   - Небольшие массивы, которые не "убегают" из функции (не передаются наружу), размещаются на стеке
   - Это избавляет от необходимости сборки мусора для таких массивов

2. **Инлайнинг операций**:
   - Операции с массивами фиксированного размера могут быть инлайнены компилятором
   - Границы массива проверяются на этапе компиляции, а не во время выполнения

3. **Оптимизация копирования**:
   - Для небольших массивов компилятор может генерировать более эффективный код копирования
   - Для больших массивов может использоваться оптимизированный `memmove`

### Когда использовать массивы, а когда слайсы

**Массивы лучше использовать, когда**:

- Размер коллекции заранее известен и никогда не меняется
- Требуется хранение на стеке для повышения производительности
- Данные должны быть скопированы, а не разделены по ссылке
- Используются небольшие коллекции с частыми аллокациями и освобождениями

```go
// Эффективное использование массива для небольших фиксированных данных
func generateID() [16]byte {
    var id [16]byte
    // Заполнение массива...
    return id // Копирование всего массива, но это нормально для небольших данных
}
```

**Слайсы лучше использовать, когда**:

- Размер коллекции может меняться
- Требуется добавление или удаление элементов
- Нужна передача коллекции без копирования данных
- Работа с подпоследовательностями данных (через срезы)

```go
// Эффективное использование слайса для динамической коллекции
func processRecords(records []Record) []Result {
    results := make([]Result, 0, len(records)) // Предварительное выделение ёмкости
    for _, r := range records {
        results = append(results, processRecord(r))
    }
    return results
}
```

### Производительность и бенчмарки

Сравнение производительности массивов и слайсов на практических примерах:

```go
// Бенчмарк для массива
func BenchmarkArray(b *testing.B) {
    for i := 0; i < b.N; i++ {
        arr := [1000]int{}
        for j := 0; j < 1000; j++ {
            arr[j] = j
        }
        _ = arr
    }
}

// Бенчмарк для слайса
func BenchmarkSlice(b *testing.B) {
    for i := 0; i < b.N; i++ {
        slice := make([]int, 1000)
        for j := 0; j < 1000; j++ {
            slice[j] = j
        }
        _ = slice
    }
}
```

Результаты бенчмарков обычно показывают, что для небольших фиксированных размеров массивы имеют преимущество в производительности, но это преимущество становится незначительным или даже отрицательным при больших размерах.

### Особые случаи использования массивов

#### 1. Структуры с фиксированными массивами

Массивы часто используются внутри структур для представления фиксированных данных:

```go
type IPv4Address struct {
    Octets [4]byte
}

type Color struct {
    RGBA [4]uint8 // R, G, B, Alpha
}

// Массив как часть ключа map
type CacheKey struct {
    ID   [16]byte // UUID
    Type uint8
}
```

#### 2. Массивы для кросс-платформенной совместимости по ABI

Массивы фиксированного размера могут быть важны при работе с C-библиотеками и FFI:

```go
// #include <openssl/md5.h>
import "C"

type MD5Hash [16]byte // Совместимо с типом из C
```

#### 3. Оптимизация памяти и аллокаций

Массивы могут использоваться для избежания лишних аллокаций в высоконагруженных системах:

```go
// Буферный пул с фиксированным размером буфера
type Buffer struct {
    data [4096]byte
    size int
}

func (b *Buffer) Write(p []byte) (n int, err error) {
    // Реализация, использующая фиксированный буфер без аллокаций
}
```

## Связи с другими темами

- [[Slice. Внутреннее устройство]] — Подробный разбор слайсов и их сравнение с массивами
- [[Строки. Байты. Руны]] — Байтовые массивы и их использование для строк
- [[Map. Внутреннее устройство]] — Использование массивов в качестве ключей map
- [[Производительность и оптимизация]] — Оптимизация использования массивов и слайсов
- [[Аллокации и управление памятью]] — Различия в аллокации массивов и слайсов

## Источники информации

1. [Спецификация языка Go](https://golang.org/ref/spec#Array_types)
2. [Эффективный Go: Слайсы](https://golang.org/doc/effective_go#slices)
3. [Go Blog: Arrays, slices (and strings): The mechanics of 'append'](https://blog.golang.org/slices)
4. [Go 101: Массивы и слайсы](https://go101.org/article/container.html)
5. [Dave Cheney: The Difference Between Arrays and Slices in Go](https://dave.cheney.net/2018/07/12/slices-from-the-ground-up)
