# Map. Внутреннее устройство

## Краткий обзор

Map в Go — это высокооптимизированная реализация хеш-таблицы, обеспечивающая среднее время доступа O(1) для операций поиска, вставки и удаления. Внутреннее устройство основано на массиве бакетов, каждый из которых может хранить до 8 пар ключ-значение. Go использует инкрементальное рехеширование для поддержания производительности при росте map. Ключевой особенностью реализации является оптимизация размещения данных в памяти для улучшения локальности кеша и предсказуемости выполнения операций. Механизм хеширования включает специализированные функции для различных типов данных и случайное начальное значение (seed) для защиты от DoS-атак.

## Подробный разбор

### Базовая структура map в Go

Runtime-представление map в Go (из исходного кода Go в runtime/map.go):

```go
type hmap struct {
    count     int           // количество элементов в map
    flags     uint8         // флаги (итерация, запись и др.)
    B         uint8         // логарифм количества бакетов (2^B = количество бакетов)
    noverflow uint16        // примерное количество overflow-бакетов
    hash0     uint32        // seed для хеш-функции
    buckets   unsafe.Pointer // указатель на массив из 2^B бакетов
    oldbuckets unsafe.Pointer // бакеты до роста (при рехешировании)
    nevacuate  uintptr      // индекс прогресса эвакуации
    extra     *mapextra     // дополнительные поля
}

type mapextra struct {
    overflow    *[]*bmap    // указатели на overflow бакеты
    oldoverflow *[]*bmap    // указатели на старые overflow бакеты
    nextOverflow *bmap      // следующий свободный overflow бакет
}
```

Каждый бакет (`bmap`) может содержать до 8 пар ключ-значение и имеет следующую структуру:

```go
// Упрощённая структура бакета
type bmap struct {
    tophash [8]uint8   // верхние байты хеша для быстрого сравнения
    // Далее следуют:
    // 1. Массив ключей: [8]keytype
    // 2. Массив значений: [8]valuetype
    // 3. Указатель на overflow бакет: *bmap
}
```

### Оптимизация размещения данных

Особенность реализации map в Go — оптимизация размещения данных в памяти:

1. **Группировка данных по типу**: вместо чередования пар ключ-значение, в бакете сначала размещены все хеш-значения (`tophash`), затем все ключи, затем все значения
2. **Локальность кеша**: такое расположение повышает вероятность попадания в кеш процессора
3. **Предсказуемость доступа**: размещение однотипных данных вместе улучшает эффективность предсказания переходов

### Процесс доступа к элементам map

Алгоритм поиска ключа:

1. Вычисление хеша ключа с использованием `hash0` как seed
2. Определение номера бакета на основе младших битов хеша
3. Сравнение старших битов хеша (tophash) со значениями в бакете для быстрой фильтрации
4. Только при совпадении tophash — сравнение самих ключей
5. При отсутствии ключа в основном бакете — проверка в цепочке overflow-бакетов

```go
// Псевдокод процесса поиска
hash := hasher(key, h.hash0)
bucket := hash & (1<<h.B - 1)
b := (*bmap)(buckets + bucket*bucketsize)
top := uint8(hash >> 24)

// Поиск в основном бакете
for i := 0; i < 8; i++ {
    if b.tophash[i] == top {
        k := b.keys[i]
        if k == key { // Полное сравнение ключей
            return b.values[i]
        }
    }
}

// Поиск в overflow бакетах
for b.overflow != nil {
    b = b.overflow
    // ... аналогичный поиск
}
```

### Алгоритмы хеширования

Go использует различные хеш-функции в зависимости от типа ключа:

1. **Для целых чисел**: оптимизированное хеширование с использованием побитовых операций
2. **Для строк**: специализированный алгоритм мемхеширования с возможностью аппаратного ускорения
3. **Для сложных типов**: рекурсивное хеширование компонентов
4. **Для интерфейсов**: комбинация хеша типа и значения

Каждый `hmap` содержит случайное значение `hash0`, которое используется как seed для хеширования, что предотвращает атаки на коллизии хешей.

### Управление ростом и рехеширование

Map автоматически увеличивается, когда:

1. **Достигнут порог загрузки**: средняя загрузка бакета превышает 6.5 элементов
2. **Много overflow-бакетов**: количество бакетов переполнения становится слишком большим

Процесс рехеширования:

1. Выделяется новый массив бакетов в 2 раза больше текущего (`2^(B+1)`)
2. Устанавливается указатель `oldbuckets` на старые бакеты
3. Новые операции используют новые бакеты
4. Данные постепенно перемещаются из `oldbuckets` в новые бакеты при обращении к map
5. Когда все данные перемещены, `oldbuckets` освобождается

Особенность рехеширования:

```go
// Часть рехеширования (упрощенный псевдокод)
func growWork(h *hmap, bucket uintptr) {
    // Эвакуируем до 2 бакетов за раз
    evacuate(h, bucket)
    if h.oldbuckets != nil {
        evacuate(h, h.nevacuate)
    }
}
```

Инкрементальное рехеширование гарантирует, что даже при больших map нет длительных пауз, связанных с перераспределением всех данных.

### Особенности и ограничения map

1. **Неупорядоченность**: порядок обхода элементов map намеренно рандомизирован
2. **Неконкурентность**: map не потокобезопасна, одновременное чтение/запись вызывает панику
3. **Требования к ключам**: ключи должны быть сравнимыми типами (не могут быть map, slice, function)
4. **Оптимизация для nil-проверок**: проверка на nil выполняется перед доступом к map

## Связи с другими темами

- [[Slice. Внутреннее устройство]] — сравнение с другими составными типами
- [[Map. Хэширование]] — алгоритмы хеширования и их особенности
- [[Map. Коллизии. Алгоритмы разрешения коллизий]] — как Go обрабатывает коллизии
- [[Map. Бакеты]] — подробности о структуре и использовании бакетов
- [[Map. Эвакуация]] — перемещение данных при рехешировании
- [[Производительность составных типов]] — оптимизация использования map

## Источники информации

1. [Go Runtime Map Implementation](https://github.com/golang/go/blob/master/src/runtime/map.go)
2. [Go Blog: Maps in Action](https://go.dev/blog/maps)
3. [Keith Randall's talk about Map Internals](https://golang.org/s/gocon-tokyo-2019-map)
4. [Dave Cheney: How the Go runtime implements maps efficiently](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)
5. [Go Maps Implementation - Run Time Analysis](https://medium.com/i0exception/runtime-overhead-of-using-go-maps-29189152354c)
6. [Robert Griesemer's Talk on Go Maps Design](https://www.youtube.com/watch?v=Tl7mi9QmLns)
7. [Go Docs: Map Types](https://golang.org/ref/spec#Map_types)
8. [Inside the Map Implementation by Keith Randall](https://www.youtube.com/watch?v=uCR_A-Bphl0)
