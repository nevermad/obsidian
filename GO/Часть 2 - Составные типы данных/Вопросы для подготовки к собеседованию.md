# Вопросы для подготовки к собеседованию: Часть 2 - Составные типы данных

Этот список вопросов охватывает все темы из второй части материалов и поможет подготовиться к собеседованию. Вопросы организованы по темам и расположены от базовых концепций к более сложным.

## Строки, байты и руны

1. Как внутренне устроены строки в Go? Какая структура используется для их представления?
2. Почему строки в Go неизменяемы? Какие преимущества это дает?
3. В чем разница между байтами (byte) и рунами (rune) в Go?
4. Как Go обрабатывает Unicode и многобайтовые символы в строках?
5. Что происходит при индексации строки? Почему нужно быть осторожным при работе с не-ASCII символами?
6. Какие есть оптимальные способы конкатенации строк в Go?
7. Как работает преобразование между строками, байтами и рунами?
8. Какие оптимизации компилятор Go выполняет для операций со строками?
9. Как правильно итерировать по символам строки, а не по байтам?
10. Какие проблемы могут возникнуть при сравнении строк с не-ASCII символами?

## Массивы и их отличия от Slice

1. Чем массивы в Go отличаются от массивов в других языках программирования?
2. Какие основные отличия между массивами и слайсами в Go?
3. Почему размер является частью типа массива в Go?
4. Как работает передача массивов в функции? Почему это может быть неэффективно?
5. В каких случаях стоит использовать массивы вместо слайсов?
6. Какие оптимизации компилятор выполняет для массивов?
7. Как размещаются массивы в памяти (стек vs куча)?
8. Как работает сравнение массивов в Go?
9. Какие типичные ошибки возникают при работе с массивами?
10. Как эффективно инициализировать массивы фиксированного размера?

## Slice. Внутреннее устройство

1. Как внутренне устроены слайсы в Go? Из каких компонентов они состоят?
2. Что такое длина и емкость слайса? Как они используются?
3. Что происходит при вызове функции append? Когда выделяется новый базовый массив?
4. Как работает алгоритм роста емкости слайса при append?
5. Какие потенциальные проблемы могут возникнуть при работе со слайсами, которые ссылаются на один и тот же базовый массив?
6. Как оптимально предварительно выделить память для слайса?
7. Как работает функция copy для слайсов?
8. Какие типичные утечки памяти связаны со слайсами?
9. Как создать слайс, который не ссылается на исходный массив?
10. Как эффективно удалить элемент из середины слайса?

## Map. Внутреннее устройство

1. Как внутренне устроена map в Go? Что такое hmap структура?
2. Какая временная сложность у основных операций с map (чтение, запись, удаление)?
3. Почему порядок итерации по map не определен и может меняться?
4. Какие требования предъявляются к типам, используемым в качестве ключей map?
5. Как создать map с предварительно выделенной емкостью? Когда это полезно?
6. Почему map не потокобезопасна в Go? Какие проблемы могут возникнуть при конкурентном доступе?
7. Какие существуют способы безопасной работы с map в многопоточной среде?
8. Как эффективно проверить наличие ключа в map?
9. Какие способы существуют для итерации по map?
10. Как работают вложенные map? Какие потенциальные проблемы с ними связаны?

## Map. Хеширование

1. Какие алгоритмы хеширования используются в Go для разных типов ключей?
2. Что такое seed-значение (hash0) в map и зачем оно нужно?
3. Как Go защищает от атак, основанных на коллизиях хешей?
4. Как вычисляется индекс бакета на основе хеша ключа?
5. Что такое tophash и как он используется для оптимизации поиска?
6. Какие аппаратные оптимизации может использовать Go для ускорения хеширования?
7. Как создать эффективный пользовательский тип в качестве ключа map?
8. Какие типы данных лучше всего подходят для использования в качестве ключей map?
9. Как работает хеширование для составных типов данных (структур, массивов)?
10. Какое влияние оказывает качество хеш-функции на производительность map?

## Map. Бакеты

1. Что такое бакеты в реализации map Go и какую роль они играют?
2. Почему бакеты в Go хранят до 8 пар ключ-значение?
3. Как устроена внутренняя структура бакета?
4. Что такое overflow-бакеты и когда они создаются?
5. Как оптимизировано размещение данных внутри бакета для улучшения локальности кеша?
6. Как происходит поиск ключа внутри бакета?
7. Как обрабатываются коллизии внутри одного бакета?
8. Какой алгоритм используется для выбора бакета на основе хеша?
9. Как влияет заполненность бакетов на производительность map?
10. Какие оптимизации реализованы для ускорения поиска в бакетах?

## Map. Коллизии и алгоритмы их разрешения

1. Какие виды коллизий могут возникать в map Go?
2. Какие алгоритмы разрешения коллизий используются в Go?
3. Чем метод цепочек в Go отличается от классической реализации?
4. Как Go определяет необходимость увеличения размера map для минимизации коллизий?
5. Как реализована двухуровневая фильтрация при поиске элементов?
6. Что такое коэффициент заполнения (load factor) и какое значение используется в Go?
7. Как коллизии влияют на производительность операций с map?
8. Какие типы роста map существуют в Go и когда они применяются?
9. Как можно минимизировать вероятность коллизий при проектировании своего приложения?
10. Какие проблемы безопасности связаны с предсказуемыми коллизиями?

## Map. Эвакуация

1. Что такое эвакуация в контексте map Go?
2. Почему Go использует инкрементальное рехеширование?
3. Как происходит процесс миграции данных при увеличении размера map?
4. Какие специальные значения tophash используются для отслеживания состояния эвакуации?
5. В каких ситуациях происходит рехеширование map?
6. Как Go определяет, в какой из новых бакетов (X или Y) переместить элемент?
7. Что такое равноразмерное рехеширование (same size growth) и когда оно применяется?
8. Как Go отслеживает прогресс эвакуации?
9. Какие операции с map могут вызвать продвижение процесса эвакуации?
10. Каковы преимущества инкрементального подхода к рехешированию по сравнению с одномоментным?

## Производительность составных типов

1. Какая временная сложность (Big O) у основных операций для разных составных типов в Go?
2. Как правильно выбрать между массивом, слайсом и map для конкретной задачи?
3. Какие оптимизации можно применить для уменьшения количества аллокаций при работе со слайсами?
4. Как эффективно работать со строками в Go? Какие подходы позволяют минимизировать аллокации?
5. Как предварительное выделение емкости влияет на производительность слайсов и map?
6. Какие факторы влияют на производительность map в Go?
7. Как локальность данных и эффективность кеша процессора влияют на производительность составных типов?
8. Какие инструменты и методики можно использовать для профилирования и оптимизации кода, работающего с составными типами?
9. Какие типичные ошибки приводят к снижению производительности при работе с составными типами?
10. Как оптимально реализовать часто используемые алгоритмы (поиск, сортировка, агрегация) для различных составных типов?

## Дополнительные продвинутые вопросы

1. Как реализовать потокобезопасную map в Go? Какие существуют подходы и их trade-offs?
2. Каковы особенности использования составных типов в качестве ключей map?
3. Как эффективно реализовать кэш с возможностью эвакуации старых элементов?
4. Как работать с большими объемами данных, не вызывая проблем с GC?
5. Какие особенности есть у операций со строками в контексте интернационализации?
6. Как реализовать собственную оптимизированную структуру данных на основе составных типов Go?
7. Какие существуют альтернативные реализации map и слайсов в экосистеме Go?
8. Как эффективно сериализовать и десериализовать составные типы?
9. Как изменилась реализация составных типов в разных версиях Go?
10. Как правильно бенчмаркить код, работающий с составными типами данных?

## Связанные заметки

- [[Строки. Байты. Руны]]
- [[Массивы и их отличия от Slice]]
- [[Slice. Внутреннее устройство]]
- [[Map. Внутреннее устройство]]
- [[Map. Хэширование]]
- [[Map. Бакеты]]
- [[Map. Коллизии. Алгоритмы разрешения коллизий]]
- [[Map. Эвакуация]]
- [[Производительность составных типов]]
