# Примитивы синхронизации. Пакет sync. Мультиплексирование (select)

## Краткий обзор

Go предоставляет различные примитивы синхронизации через пакет `sync`, включая мьютексы, RWMutex, WaitGroup, Once, Cond, Pool и атомарные операции. Эти инструменты используются для синхронизации доступа к разделяемым ресурсам между горутинами. Конструкция `select` обеспечивает мультиплексирование операций с каналами, позволяя горутинам ожидать операции с несколькими каналами одновременно. Правильное использование примитивов синхронизации критично для построения корректных многопоточных программ без состояний гонки данных или взаимных блокировок.

## Подробный разбор

### Пакет sync

Пакет `sync` предоставляет примитивы синхронизации низкого уровня для координации горутин. Важно помнить принцип Go: _"Do not communicate by sharing memory; instead, share memory by communicating"_, однако в некоторых случаях примитивы синхронизации предпочтительнее каналов.

#### Mutex

Mutex (взаимное исключение) используется для защиты доступа к разделяемым ресурсам, гарантируя, что только одна горутина может получить доступ к ресурсу одновременно.

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}
```

**Внутреннее устройство Mutex**:

```go
type Mutex struct {
    state int32  // Состояние мьютекса: незаблокирован, заблокирован, ожидают, проснулся
    sema  uint32 // Семафор для блокировки горутин
}
```

Мьютекс в Go использует сочетание спинлока и семафора для обеспечения эффективности:

1. **Быстрый путь**: Попытка получить блокировку без ожидания, используя атомарные операции
2. **Спинлок**: Кратковременное активное ожидание блокировки перед переходом к полной блокировке
3. **Блокировка через семафор**: Окончательное приостановление горутины при долгом ожидании

Состояние мьютекса представлено как битовое поле:

- **Бит 0**: Заблокирован (1) или не заблокирован (0)
- **Бит 1**: Пробуждение (woken)
- **Бит 2-31**: Счетчик ожидающих горутин

#### RWMutex (Читатель-Писатель Мьютекс)

RWMutex позволяет нескольким "читателям" параллельно читать данные, но только одному "писателю" модифицировать данные.

```go
type Cache struct {
    rwmu  sync.RWMutex
    items map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.rwmu.RLock()
    defer c.rwmu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.rwmu.Lock()
    defer c.rwmu.Unlock()
    c.items[key] = value
}
```

**Внутреннее устройство RWMutex**:

```go
type RWMutex struct {
    w           Mutex  // Блокировка для писателей
    writerSem   uint32 // Семафор для писателей
    readerSem   uint32 // Семафор для читателей
    readerCount int32  // Количество активных читателей
    readerWait  int32  // Количество читателей, которых ожидает писатель
}
```

Интересные детали RWMutex:

1. Писатели имеют приоритет над читателями
2. Новые читатели блокируются, если есть ожидающий писатель
3. RWMutex не имеет максимального количества одновременных читателей

#### WaitGroup

WaitGroup используется для ожидания завершения группы горутин.

```go
func processItems(items []int) {
    var wg sync.WaitGroup
    
    for _, item := range items {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            process(i)
        }(item)
    }
    
    wg.Wait() // Блокирует до завершения всех горутин
}
```

**Внутреннее устройство WaitGroup**:

```go
type WaitGroup struct {
    noCopy noCopy
    state1 [3]uint32 // Счетчик ожидания, счетчик семафора, флаги
}
```

Структура включает счетчик (сколько горутин осталось) и семафор для блокировки. Внутреннее представление использует 64-битное слово состояния:

- **Старшие 32 бита**: Счетчик горутин
- **Младшие 32 бита**: Счетчик ожидающих + флаги состояния

#### Once

Once гарантирует, что функция будет выполнена только один раз.

```go
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

**Внутреннее устройство Once**:

```go
type Once struct {
    done uint32
    m    Mutex
}
```

Once использует атомарную переменную `done` и мьютекс для защиты инициализации:

1. Атомарная проверка `done` (fast path)
2. Захват мьютекса, если `done` == 0
3. Повторная проверка `done` под защитой мьютекса (double-checked locking)
4. Выполнение функции и установка `done` = 1

#### Cond (Условная переменная)

Cond используется для ожидания или сигнализации о событиях между горутинами.

```go
type Queue struct {
    cond *sync.Cond
    data []interface{}
}

func NewQueue() *Queue {
    return &Queue{
        cond: sync.NewCond(&sync.Mutex{}),
    }
}

func (q *Queue) Push(item interface{}) {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    q.data = append(q.data, item)
    q.cond.Signal() // Уведомить одного ожидающего
}

func (q *Queue) Pop() interface{} {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    
    for len(q.data) == 0 {
        q.cond.Wait() // Ждем, пока очередь не станет непустой
    }
    
    item := q.data[0]
    q.data = q.data[1:]
    return item
}
```

**Внутреннее устройство Cond**:

```go
type Cond struct {
    noCopy  noCopy
    L       Locker  // Захваченная блокировка
    notify  notifyList
}
```

Cond содержит:

1. **L**: Locker (обычно Mutex), который должен быть захвачен при вызове методов Cond
2. **notify**: Внутренняя очередь для трекинга ожидающих горутин

#### Pool

Pool предоставляет кэш временных объектов, которые могут быть сохранены и извлечены.

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func ProcessRequest() {
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)
    }()
    
    // Использовать buf...
}
```

**Внутреннее устройство Pool**:

```go
type Pool struct {
    noCopy     noCopy
    local      unsafe.Pointer // local fixed-size per-P pool
    localSize  uintptr        // size of the local array
    victim     unsafe.Pointer // victim cache
    victimSize uintptr        // size of the victim array
    New        func() interface{}
}
```

Pool реализует:

1. Локальные пулы для каждого P (процессора) Go рантайма
2. "Victim cache" для временного хранения объектов между циклами GC
3. Объекты в пуле могут быть удалены сборщиком мусора при любом вызове GC

#### sync.Map

Тип `sync.Map` - это конкурентно-безопасная реализация карты, оптимизированная для случаев, когда множество горутин читают данные, а записи выполняются редко.

```go
var userCache sync.Map

func GetUser(id string) (*User, bool) {
    if user, ok := userCache.Load(id); ok {
        return user.(*User), true
    }
    return nil, false
}

func SetUser(id string, user *User) {
    userCache.Store(id, user)
}
```

**Внутреннее устройство sync.Map**:

```go
type Map struct {
    mu Mutex
    read atomic.Value // readOnly структура
    dirty map[interface{}]*entry
    misses int
}
```

`sync.Map` использует две карты:

1. **read**: Быстрая неблокирующая карта для чтения
2. **dirty**: Полная карта, защищенная мьютексом

Алгоритм `sync.Map`:

1. Чтение сначала проверяет `read` карту без блокировок
2. Если ключа нет в `read`, происходит захват мьютекса и поиск в `dirty`
3. После определенного числа промахов, `dirty` становится новой `read` картой
4. Удаление помечает записи как удаленные, а не физически их удаляет

### Atomic операции

Пакет `sync/atomic` предоставляет низкоуровневые атомарные операции памяти для примитивных типов.

```go
var counter int64

func increment() {
    atomic.AddInt64(&counter, 1)
}

func getCount() int64 {
    return atomic.LoadInt64(&counter)
}
```

**Основные операции**:

1. **Load**: Атомарное чтение
2. **Store**: Атомарная запись
3. **Add**: Атомарное добавление
4. **CompareAndSwap (CAS)**: Атомарная условная замена
5. **Swap**: Атомарный обмен значениями

**Внутренняя реализация** атомарных операций зависит от архитектуры и использует специальные инструкции процессора (например, LOCK префикс на x86, LDREX/STREX на ARM).

### Мультиплексирование с помощью select

Оператор `select` позволяет горутине ждать операций на нескольких каналах.

```go
func process(done <-chan struct{}, inputs <-chan int, outputs chan<- int) {
    for {
        select {
        case <-done:
            return
        case input, ok := <-inputs:
            if !ok {
                return
            }
            select {
            case outputs <- input * 2:
                // Успешно отправили результат
            case <-done:
                return
            }
        }
    }
}
```

#### Внутреннее устройство select

`select` компилируется в серию вызовов рантайма, которые реализуют следующие шаги:

1. **Подготовка случаев**: Создание списка всех каналов и операций.
2. **Перемешивание порядка**: Случайное перемешивание случаев для предотвращения голодания.
3. **Попытка неблокирующих операций**: Проверка всех каналов на готовность.
4. **Блокировка, если необходимо**: Если ни один канал не готов (и нет default), горутина блокируется, ожидая любого из каналов.

Примерный путь выполнения `select` в рантайме:

```
select → runtime.selectgo → runtime.selectnbsend/selectnbrecv → runtime.chansend/chanrecv
```

#### Правила работы select

1. Если несколько каналов готовы, выбирается случайный.
2. Если нет готовых каналов:
   - Если есть `default`, выполняется ветка `default`.
   - Если нет `default`, горутина блокируется до готовности любого канала.
3. `select{}` (пустой select) блокируется навсегда.
4. Все выражения каналов вычисляются слева направо, сверху вниз.

#### Типичные шаблоны использования select

1. **Тайм-аут**:

```go
select {
case result := <-ch:
    // Обработка результата
case <-time.After(1 * time.Second):
    // Обработка тайм-аута
}
```

2. **Неблокирующие отправка/получение**:

```go
select {
case ch <- value:
    // Значение отправлено
default:
    // Канал заблокирован, действуем иначе
}
```

3. **Мультиплексирование нескольких источников**:

```go
select {
case v1 := <-ch1:
    // Обработка v1
case v2 := <-ch2:
    // Обработка v2
case v3 := <-ch3:
    // Обработка v3
}
```

4. **Отмена операций**:

```go
select {
case result := <-workCh:
    // Обработка результата
case <-cancelCh:
    // Операция отменена
}
```

### Проблемы синхронизации

#### Deadlock (Взаимная блокировка)

Взаимная блокировка возникает, когда две или более горутины циклически ожидают ресурсы, удерживаемые друг другом.

```go
func deadlockExample() {
    var mu1, mu2 sync.Mutex
    
    go func() {
        mu1.Lock()
        time.Sleep(1 * time.Millisecond)
        mu2.Lock() // Потенциальный deadlock
        // ...
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        mu2.Lock()
        time.Sleep(1 * time.Millisecond)
        mu1.Lock() // Потенциальный deadlock
        // ...
        mu1.Unlock()
        mu2.Unlock()
    }()
}
```

**Предотвращение deadlock**:

1. Всегда захватывать мьютексы в одинаковом порядке
2. Использовать тайм-ауты или контексты для ограничения времени ожидания
3. Применять `sync/atomic` вместо мьютексов, где возможно
4. Использовать иерархию блокировок

#### Race Condition (Состояние гонки)

Состояние гонки возникает при одновременном доступе к общим данным без надлежащей синхронизации.

```go
func raceExample() {
    counter := 0
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // Гонка данных
        }()
    }
    
    wg.Wait()
    fmt.Println(counter) // Вероятно не 1000
}
```

**Обнаружение и предотвращение гонок**:

1. Использовать флаг `-race` при компиляции и тестировании
2. Применять подходящие примитивы синхронизации (mutex, atomic)
3. Предпочитать неизменяемые данные
4. Минимизировать разделяемое состояние

#### Livelock

Livelock возникает, когда горутины активно выполняются, но не продвигаются в своей работе.

```go
func livelockExample() {
    var wg sync.WaitGroup
    var resource int
    ch1 := make(chan struct{})
    ch2 := make(chan struct{})
    
    wg.Add(2)
    go func() {
        defer wg.Done()
        for {
            select {
            case <-ch1:
                resource++
                ch2 <- struct{}{}
            }
        }
    }()
    
    go func() {
        defer wg.Done()
        for {
            select {
            case <-ch2:
                resource--
                ch1 <- struct{}{}
            }
        }
    }()
    
    ch1 <- struct{}{} // Запуск livelock
    wg.Wait()
}
```

**Предотвращение livelock**:

1. Добавлять случайные задержки между повторными попытками
2. Использовать механизмы нарастающей задержки (exponential backoff)
3. Приоритизировать доступ к ресурсам

#### Starvation (Голодание)

Голодание возникает, когда горутина не может получить достаточно ресурсов для своей работы.

```go
func starvationExample() {
    var mu sync.Mutex
    
    // Горутина с высоким приоритетом
    go func() {
        for {
            mu.Lock()
            time.Sleep(100 * time.Millisecond)
            mu.Unlock()
        }
    }()
    
    // Горутина с низким приоритетом
    go func() {
        for {
            mu.Lock()
            // Долгая работа
            time.Sleep(1 * time.Second)
            mu.Unlock()
        }
    }()
}
```

**Предотвращение голодания**:

1. Использовать RWMutex для параллельного чтения
2. Ограничивать время удержания блокировок
3. Применять более специализированные структуры данных (например, lock-free)
4. Использовать механизмы честного планирования

### Сравнение примитивов синхронизации и каналов

| Примитивы sync | Каналы |
|----------------|--------|
| Низкоуровневые | Высокоуровневые |
| Ручная синхронизация | Синхронизация через сообщения |
| Оптимальны для разделяемого состояния | Оптимальны для передачи данных |
| Лучше для тонкой настройки | Лучше для выразительности |
| Более производительны для простых случаев | Более выразительны для сложных паттернов |

**Рекомендации по выбору**:

- Используйте каналы для передачи данных между горутинами
- Используйте примитивы sync для защиты разделяемого состояния
- Выбирайте каналы для управления потоком выполнения горутин
- Выбирайте примитивы sync для тонкой настройки производительности

## Связи с другими темами

- [[Горутины. Внутреннее устройство горутин. Различные модели многозадачности]]
- [[Каналы. Внутреннее устройство каналов. Аксиомы каналов]]
- [[Go Scheduler]]
- [[Контексты. Работа с контекстами]]

## Источники

1. [Go Documentation: sync package](https://golang.org/pkg/sync/)
2. [Go Documentation: Effective Go - Concurrency](https://golang.org/doc/effective_go#concurrency)
3. [Go Source Code: src/sync](https://github.com/golang/go/tree/master/src/sync)
4. [The Go Memory Model](https://golang.org/ref/mem)
5. [Go 101: Atomic Operations](https://go101.org/article/concurrent-atomic-operation.html)
6. [Go 101: Channel Use Cases](https://go101.org/article/channel-use-cases.html)
7. [Russ Cox's Blog: Real Go Interfaces](https://research.swtch.com/interfaces)
8. [Visualizing Concurrency in Go](https://divan.dev/posts/go_concurrency_visualize/)
9. [Go Documentation: Data Race Detector](https://golang.org/doc/articles/race_detector.html)
