# Контексты. Работа с контекстами

## Краткий обзор

Контекст в Go — это примитив для управления временем жизни горутин, передачи дедлайнов, сигналов отмены и значений по дереву вызовов. Пакет `context` предоставляет несколько типов контекстов: пустой, с отменой, с таймаутом, с дедлайном и с значениями. Контексты образуют дерево, где дочерние контексты наследуют свойства родительских, но могут также добавлять свои. Контексты широко используются в HTTP-серверах, при работе с базами данных, в RPC и других асинхронных операциях для контроля их выполнения и предотвращения утечек ресурсов.

## Подробный разбор

### Основы контекстов

Контекст в Go реализован через интерфейс `Context`:

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

Методы интерфейса `Context`:

1. **Deadline()** - возвращает время, когда контекст будет отменен автоматически (если установлено)
2. **Done()** - возвращает канал, который закрывается при отмене контекста
3. **Err()** - возвращает ошибку, указывающую причину отмены контекста
4. **Value()** - возвращает значение, ассоциированное с ключом, или nil

### Типы контекстов

#### Пустой контекст (context.Background, context.TODO)

Пустой контекст является корнем иерархии контекстов. Он никогда не отменяется, не имеет значений и не имеет дедлайна.

```go
// context.Background() - для корневых контекстов
rootCtx := context.Background()

// context.TODO() - для мест, где еще не решено, какой контекст использовать
tempCtx := context.TODO()
```

Разница между ними:

- `Background()` используется для корневых контекстов (HTTP-сервер, главная горутина)
- `TODO()` указывает, что здесь должен быть контекст, но пока неясно, какой именно

#### Контекст с отменой (context.WithCancel)

Контекст с отменой можно явно отменить вызовом функции отмены.

```go
ctx, cancel := context.WithCancel(parentCtx)
defer cancel() // Важно всегда вызывать cancel

// В другой горутине или по какому-то условию
if shouldCancel {
    cancel()
}
```

При вызове `cancel()`:

1. Закрывается канал `ctx.Done()`
2. Отменяются все дочерние контексты
3. `ctx.Err()` начинает возвращать `context.Canceled`

#### Контекст с таймаутом (context.WithTimeout)

Контекст с таймаутом автоматически отменяется после указанного времени.

```go
// Контекст, который отменится через 100мс
ctx, cancel := context.WithTimeout(parentCtx, 100*time.Millisecond)
defer cancel() // Важно всегда вызывать, даже если таймаут уже наступил
```

#### Контекст с дедлайном (context.WithDeadline)

Контекст с дедлайном отменяется в указанный момент времени.

```go
deadline := time.Now().Add(5 * time.Minute)
ctx, cancel := context.WithDeadline(parentCtx, deadline)
defer cancel()
```

Отличие от контекста с таймаутом: дедлайн задает абсолютное время, а не относительное.

#### Контекст со значениями (context.WithValue)

Контекст со значениями позволяет передавать данные вниз по дереву вызовов.

```go
type contextKey string

ctx := context.WithValue(parentCtx, contextKey("user_id"), "12345")

// Получение значения
userID, ok := ctx.Value(contextKey("user_id")).(string)
```

Важные правила при использовании `WithValue`:

1. Ключи должны быть сравнимыми (comparable) типами
2. Рекомендуется использовать пользовательские типы для ключей, а не встроенные
3. Значения должны быть безопасными для использования несколькими горутинами

### Внутреннее устройство контекстов

Контексты в Go имеют разные внутренние реализации для различных типов:

#### emptyCtx

```go
type emptyCtx int

func (emptyCtx) Deadline() (deadline time.Time, ok bool) { return }
func (emptyCtx) Done() <-chan struct{} { return nil }
func (emptyCtx) Err() error { return nil }
func (emptyCtx) Value(key interface{}) interface{} { return nil }
```

Это реализация для `Background()` и `TODO()`. Это просто заглушка, которая ничего не делает.

#### cancelCtx

```go
type cancelCtx struct {
    Context
    mu       sync.Mutex
    done     atomic.Value
    children map[canceler]struct{}
    err      error
}
```

Это реализация для контекстов с отменой, таймаутом и дедлайном. Основные поля:

- `Context` - родительский контекст
- `done` - канал для сигнализации об отмене
- `children` - список дочерних контекстов, которые нужно отменить
- `err` - причина отмены

#### valueCtx

```go
type valueCtx struct {
    Context
    key, val interface{}
}
```

Это реализация для контекстов со значениями:

- `Context` - родительский контекст
- `key` - ключ значения
- `val` - само значение

### Иерархия контекстов

Контексты образуют древовидную структуру:

1. Родительский контекст создается первым
2. Дочерние контексты создаются на основе родительского
3. Отмена родительского контекста приводит к отмене всех дочерних
4. Отмена дочернего контекста не влияет на родительский
5. Значения передаются от родителя к детям (но не наоборот)

Визуально это выглядит так:

```
Background
    ├── WithValue(k1, v1)
    │       └── WithCancel
    │             └── WithTimeout
    └── WithCancel
            └── WithValue(k2, v2)
```

### Паттерны использования контекстов

#### Распространение отмены

```go
func process(ctx context.Context) error {
    // Создаем дочерний контекст
    childCtx, cancel := context.WithTimeout(ctx, 1*time.Second)
    defer cancel()
    
    // Запускаем подзадачу с дочерним контекстом
    errCh := make(chan error, 1)
    go func() {
        errCh <- subProcess(childCtx)
    }()
    
    // Ожидаем результат или отмену
    select {
    case err := <-errCh:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

#### Отмена долгих операций

```go
func longOperation(ctx context.Context) (Result, error) {
    result := Result{}
    
    // Проверяем отмену на каждом шаге
    for i := 0; i < 100; i++ {
        select {
        case <-ctx.Done():
            return result, ctx.Err()
        default:
            // Продолжаем работу
            time.Sleep(10 * time.Millisecond)
            // Обновляем результат
        }
    }
    
    return result, nil
}
```

#### Передача запрососпецифичных данных

```go
func httpHandler(w http.ResponseWriter, r *http.Request) {
    // Получение контекста запроса с таймаутом
    ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
    defer cancel()
    
    // Добавление информации о пользователе
    userID := extractUserID(r)
    ctx = context.WithValue(ctx, userIDKey, userID)
    
    // Использование контекста в сервисах
    result, err := someService.Process(ctx)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // Отправка ответа
    json.NewEncoder(w).Encode(result)
}
```

#### Прерывание долгих HTTP-запросов

```go
func makeAPIRequest(ctx context.Context, url string) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    return http.DefaultClient.Do(req)
}
```

### Context best practices

#### Правила использования контекстов

1. **Первый параметр функции**:

   ```go
   func DoSomething(ctx context.Context, arg Arg) error {
       // ...
   }
   ```

2. **Не хранить контексты в структурах**:

   ```go
   // Плохо:
   type Service struct {
       ctx context.Context
   }
   
   // Хорошо:
   type Service struct {
       // Нет поля ctx
   }
   
   func (s *Service) Process(ctx context.Context) {
       // ...
   }
   ```

3. **Не пропускать контекст**:

   ```go
   // Функция должна принимать контекст
   func (s *Server) Process(ctx context.Context, data []byte) {
       // И передавать его дальше
       results, err := s.store.Query(ctx, parseQuery(data))
       // ...
   }
   ```

4. **Отменять контексты**:

   ```go
   ctx, cancel := context.WithTimeout(parentCtx, timeout)
   defer cancel() // Всегда вызывать cancel
   ```

5. **Значения только для передачи запрососпецифичных данных**:

   ```go
   // Хорошо: трассировка запроса, идентификаторы пользователя, авторизационные токены
   ctx = context.WithValue(ctx, traceIDKey, traceID)
   
   // Плохо: параметры конфигурации, зависимости
   ctx = context.WithValue(ctx, dbConnKey, db) // Так не надо
   ```

#### Антипаттерны

1. **Игнорирование контекста**:

   ```go
   // Плохо:
   func process(ctx context.Context, data []byte) {
       // Контекст не используется
       time.Sleep(10 * time.Second)
       // ...
   }
   ```

2. **Создание контекстов без отмены**:

   ```go
   // Плохо:
   ctx := context.Background()
   go longRunningTask(ctx) // Эту горутину нельзя будет отменить
   ```

3. **Использование контекста после отмены**:

   ```go
   // Плохо:
   ctx, cancel := context.WithCancel(parentCtx)
   cancel()
   
   // Контекст уже отменен, но все равно используется
   result, err := service.Process(ctx)
   ```

4. **Неправильные типы ключей**:

   ```go
   // Плохо - использование встроенных типов как ключей
   ctx = context.WithValue(ctx, "user_id", userID)
   
   // Хорошо - пользовательский тип
   type contextKey string
   const userIDKey contextKey = "user_id"
   ctx = context.WithValue(ctx, userIDKey, userID)
   ```

### Context vs Каналы отмены

До появления `context` пакета, для отмены операций обычно использовались каналы:

```go
func oldStyleCancel() {
    done := make(chan struct{})
    go func() {
        // Закрыть канал при выходе
        defer close(done)
        // Работа...
    }()
    
    // Отмена по таймауту
    time.AfterFunc(1*time.Second, func() {
        close(done)
    })
}
```

Преимущества контекстов:

1. Стандартизованный интерфейс
2. Поддержка дерева отмены
3. Возможность передачи дедлайнов и значений
4. Встроенная поддержка в стандартной библиотеке

### Интеграция с базами данных и другими API

#### SQL с контекстом

```go
func queryUser(ctx context.Context, db *sql.DB, userID int) (*User, error) {
    // Запрос прервется при отмене контекста
    row := db.QueryRowContext(ctx, "SELECT * FROM users WHERE id = ?", userID)
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

#### gRPC с контекстом

```go
func (s *Server) FetchData(ctx context.Context, req *pb.Request) (*pb.Response, error) {
    // Проверка дедлайна
    if deadline, ok := ctx.Deadline(); ok {
        timeLeft := time.Until(deadline)
        if timeLeft < minProcessingTime {
            return nil, status.Errorf(codes.DeadlineExceeded, "insufficient time: %v", timeLeft)
        }
    }
    
    // Получение значений из контекста
    userID, _ := ctx.Value(userIDKey).(string)
    
    // Использование контекста для других вызовов
    data, err := s.database.Query(ctx, req.Query)
    if err != nil {
        return nil, err
    }
    
    return &pb.Response{Data: data}, nil
}
```

### Производительность и оптимизации

Контексты разработаны для быть легковесными, но есть некоторые особенности:

1. **Глубокое дерево значений**:
   - Каждый вызов `WithValue` создает новый `valueCtx`
   - Поиск значения требует прохода по всей цепочке родителей
   - Для часто используемых значений это может быть неэффективно

2. **Отмена контекста**:
   - Отмена распространяется на все дочерние контексты
   - При большом количестве дочерних контекстов это может занять время

3. **Оптимизации**:
   - Используйте контексты со значениями только когда необходимо
   - Группируйте связанные значения в одну структуру вместо множества `WithValue`
   - Используйте пул горутин для снижения накладных расходов на создание и отмену

### Мониторинг и отладка

Для отладки работы с контекстами полезны следующие практики:

1. **Логирование состояния контекста**:

   ```go
   func logContext(ctx context.Context) {
       if deadline, ok := ctx.Deadline(); ok {
           log.Printf("Context deadline: %v", deadline)
       }
       if err := ctx.Err(); err != nil {
           log.Printf("Context error: %v", err)
       }
   }
   ```

2. **Тестирование с отменой контекста**:

   ```go
   func TestWithCancel(t *testing.T) {
       ctx, cancel := context.WithCancel(context.Background())
       
       go func() {
           time.Sleep(10 * time.Millisecond)
           cancel()
       }()
       
       err := functionThatShouldRespectCancel(ctx)
       if err != context.Canceled {
           t.Errorf("Expected context.Canceled, got %v", err)
       }
   }
   ```

3. **Трассировка распространения контекста**:
   - Можно использовать пакеты трассировки (OpenTracing, OpenTelemetry)
   - Добавлять ID трассировки в контекст и отслеживать его распространение

## Связи с другими темами

- [[Горутины. Внутреннее устройство горутин. Различные модели многозадачности]]
- [[Каналы. Внутреннее устройство каналов. Аксиомы каналов]]
- [[Примитивы синхронизации. Пакет sync. Мультиплексирование (select)]]
- [[Конструкция defer]]

## Источники

1. [Go Documentation: context package](https://golang.org/pkg/context/)
2. [Go Blog: Context and cancellation of goroutines](https://blog.golang.org/context)
3. [Go Source Code: src/context](https://github.com/golang/go/tree/master/src/context)
4. [Go by Example: Context](https://gobyexample.com/context)
5. [Ardan Labs: Using Context Package in Go](https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html)
6. [GopherCon 2019: Understanding Context](https://www.youtube.com/watch?v=h2RdcrMLQAo)
7. [The Golang Standard Library: Context](https://medium.com/golangspec/context-pattern-in-go-8f3ee30d6a1e)
8. [Practical Go: Context in depth](https://dave.cheney.net/2017/01/26/context-is-for-cancelation)
