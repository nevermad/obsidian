// Файл: practice_sync.go

package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// Задача 1: Реализация потокобезопасного счетчика
// Используйте sync.Mutex для защиты счетчика при параллельном инкрементировании
// из 1000 горутин. Каждая горутина должна увеличить счетчик 100 раз.
// Ожидаемый итоговый результат: 100000
func task1() {
	var counter int
	// TODO: добавьте mutex

	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 100; j++ {
				// TODO: защитите увеличение счетчика с помощью mutex
				counter++
			}
		}()
	}
	wg.Wait()
	fmt.Println("Задача 1: Значение счетчика:", counter)
}

// Задача 2: Реализация пула воркеров
// Создайте пул из N воркеров, который обрабатывает M задач
// Задачи отправляются в канал, воркеры берут их из канала и выполняют
// Результаты выполнения собираются и выводятся в консоль
func task2() {
	numWorkers := 3
	numTasks := 10

	// TODO: реализуйте каналы для задач и результатов

	// TODO: запустите воркеров

	// TODO: отправьте задачи в канал

	// TODO: получите и выведите результаты

	fmt.Println("Задача 2: Все задачи выполнены")
}

// Задача 3: Мультиплексирование каналов с select
// Создайте программу, которая обрабатывает данные из трех каналов:
// - канал чисел (отправляет числа от 1 до 5)
// - канал строк (отправляет строки "one" до "five")
// - канал тайм-аута (срабатывает через 2 секунды)
// Используйте select для мультиплексирования каналов
func task3() {
	numbers := make(chan int, 5)
	strings := make(chan string, 5)
	timeout := make(chan bool, 1)

	// Заполнение каналов
	go func() {
		for i := 1; i <= 5; i++ {
			numbers <- i
			time.Sleep(300 * time.Millisecond)
		}
		close(numbers)
	}()

	go func() {
		words := []string{"one", "two", "three", "four", "five"}
		for _, word := range words {
			strings <- word
			time.Sleep(500 * time.Millisecond)
		}
		close(strings)
	}()

	go func() {
		time.Sleep(2 * time.Second)
		timeout <- true
		close(timeout)
	}()

	// TODO: реализуйте обработку данных из трех каналов с использованием select
	// При получении числа выведите "Получено число: <число>"
	// При получении строки выведите "Получена строка: <строка>"
	// При получении тайм-аута выведите "Тайм-аут!" и завершите работу программы
}

// Задача 4: Использование контекста для отмены операций
// Реализуйте функцию, которая запускает долгую операцию (1 секунда на итерацию)
// но с возможностью отмены через контекст. Должны быть обработаны оба случая:
// - Операция успешно завершена (5 итераций)
// - Операция отменена по тайм-ауту (через 3 секунды)
func task4() {
	// TODO: создайте контекст с тайм-аутом 3 секунды

	// TODO: запустите горутину, которая выполняет 5 итераций с задержкой 1 секунда
	// и проверяет сигнал отмены из контекста после каждой итерации

	// TODO: дождитесь завершения горутины или отмены через контекст

	fmt.Println("Задача 4: Завершена")
}

// Задача 5: Синхронизация доступа к карте с RWMutex
// Реализуйте потокобезопасную карту счетчиков с операциями:
// - Увеличение счетчика для ключа (требует блокировки записи)
// - Получение значения счетчика для ключа (требует блокировки чтения)
// - Получение суммы всех счетчиков (требует блокировки чтения)
type SafeCounter struct {
	// TODO: добавьте поля для карты и RWMutex
}

// TODO: реализуйте методы для SafeCounter:
// - Increment(key string) - увеличивает счетчик для ключа
// - Get(key string) int - возвращает значение счетчика для ключа
// - Sum() int - возвращает сумму всех счетчиков

func task5() {
	// TODO: создайте экземпляр SafeCounter

	// TODO: запустите горутины, которые увеличивают счетчики для разных ключей

	// TODO: запустите горутины, которые читают значения счетчиков

	// TODO: запустите горутины, которые получают сумму всех счетчиков

	// TODO: дождитесь завершения всех горутин и выведите результаты

	fmt.Println("Задача 5: Завершена")
}

// Задача 6: Реализация однократного выполнения с Once
// Создайте сервис, который инициализируется только один раз,
// даже при попытке инициализации из разных горутин
type Service struct {
	// TODO: добавьте поля для хранения данных сервиса и sync.Once
}

// TODO: реализуйте метод Init(), который инициализирует сервис только один раз

func task6() {
	// TODO: создайте экземпляр сервиса

	// TODO: запустите несколько горутин, которые пытаются инициализировать сервис

	// TODO: дождитесь завершения всех горутин и проверьте, что сервис инициализирован только один раз

	fmt.Println("Задача 6: Завершена")
}

// Задача 7: Координация горутин с использованием Cond
// Реализуйте паттерн "производитель-потребитель" с буфером ограниченного размера
// Производитель должен ждать, если буфер полон
// Потребитель должен ждать, если буфер пуст
// Используйте sync.Cond для координации
type Buffer struct {
	// TODO: добавьте поля для буфера, мьютекса и условных переменных
}

// TODO: реализуйте методы:
// - Put(value int) - добавляет значение в буфер, ждет если буфер полон
// - Get() int - извлекает значение из буфера, ждет если буфер пуст

func task7() {
	// TODO: создайте буфер

	// TODO: запустите производителей

	// TODO: запустите потребителей

	// TODO: дождитесь завершения и выведите результаты

	fmt.Println("Задача 7: Завершена")
}

func main() {
	fmt.Println("Практические задачи по синхронизации горутин")

	// Раскомментируйте задачу, которую хотите выполнить
	// task1()
	// task2()
	// task3()
	// task4()
	// task5()
	// task6()
	// task7()
}
