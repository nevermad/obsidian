Каналы: 1. Что такое каналы в Go и какую проблему они решают?	Каналы в Go — это тип данных, который позволяет горутинам безопасно обмениваться данными без явной блокировки. Они реализуют принцип CSP (Communicating Sequential Processes), предложенный Тони Хоаром. Каналы решают проблему координации и синхронизации работы параллельных горутин, обеспечивая безопасный обмен данными и избавляя разработчика от низкоуровневых деталей синхронизации.
Каналы: 2. В чем разница между буферизованными и небуферизованными каналами?	**Небуферизованные каналы (dataqsiz = 0):**

- Операции отправки и получения синхронны
- Отправка блокируется до тех пор, пока другая горутина не готова получить данные
- Получение блокируется до тех пор, пока другая горутина не отправит данные

**Буферизованные каналы (dataqsiz > 0):**

- Операции отправки и получения асинхронны, пока буфер не заполнен/опустошен
- Отправка блокируется только когда буфер полон
- Получение блокируется только когда буфер пуст
- Имеют встроенный буфер для временного хранения данных
Каналы: 3. Как устроены каналы внутренне? Опишите структуру `hchan`	Внутренне канал в Go реализован как структура `hchan` в runtime:

<pre><code>type hchan struct {
    qcount   uint           // Общее количество элементов в буфере
    dataqsiz uint           // Размер буфера (0 для небуферизованных)
    buf      unsafe.Pointer // Указатель на буфер
    elemsize uint16         // Размер одного элемента
    closed   uint32         // Флаг закрытия канала (неатомарный)
    elemtype *_type         // Тип элементов канала
    sendx    uint           // Индекс отправки
    recvx    uint           // Индекс получения
    recvq    waitq          // Список горутин, ожидающих получения
    sendq    waitq          // Список горутин, ожидающих отправки
    lock     mutex          // Защищает все поля в hchan
}</code></pre>

Ключевые поля:

- `qcount`, `dataqsiz`, `buf` для управления буфером (кольцевой очередью)
- `recvq`, `sendq` очереди ожидающих горутин
- `lock` мьютекс для атомарности операций
- `closed` флаг закрытия канала
Каналы: 4. Что происходит при отправке и получении данных из канала на низком уровне?	**Отправка данных в канал (`ch <- value`):**

1. Блокировка мьютекса канала
2. Проверка, есть ли горутины, ожидающие получения:
   - Если есть, передать значение напрямую ожидающей горутине
   - Если нет, проверить буфер:
     - Если буфер не полон, добавить значение в буфер
     - Если буфер полон, поставить текущую горутину в очередь `sendq` и заблокировать
3. Разблокировка мьютекса канала

**Получение данных из канала (`value := <-ch`):**

1. Блокировка мьютекса канала
2. Проверка буфера:
   - Если буфер не пуст, извлечь значение из буфера
   - Если буфер пуст, проверить, есть ли горутины, ожидающие отправки:
     - Если есть, получить значение напрямую от ожидающей горутины
     - Если нет, поставить текущую горутину в очередь `recvq` и заблокировать
3. Разблокировка мьютекса канала
Каналы: 5. Какие аксиомы каналов существуют в Go?	1. **Отправка в нулевой канал блокирует навсегда**
2. **Получение из нулевого канала блокирует навсегда**
3. **Отправка в закрытый канал вызывает панику**
4. **Получение из закрытого канала возвращает нулевое значение и false**
5. **Закрытие закрытого канала вызывает панику**
6. **Закрытие нулевого канала вызывает панику**
Каналы: 6. Что произойдет при отправке в закрытый канал? А при чтении из закрытого канала?	**При отправке в закрытый канал**: вызывается паника "send on closed channel".

**При чтении из закрытого канала**:

- Если в буфере канала остались данные, они будут прочитаны в обычном порядке.
- Если буфер пуст, получение вернет нулевое значение типа канала.
- При использовании второго возвращаемого значения (`v, ok := <-ch`), `ok` будет `false` для закрытого пустого канала.
Каналы: 7. Что произойдет при закрытии уже закрытого канала?	При закрытии уже закрытого канала вызывается паника "close of closed channel". Это защищает от ситуаций, когда несколько горутин могут попытаться закрыть один и тот же канал.
Каналы: 8. Что такое направленные каналы и для чего они используются?	Направленные каналы ограничивают операции, которые можно выполнять с каналом:

<pre><code>chan<- T // Канал только для отправки
<-chan T // Канал только для получения</code></pre>

Они используются для ограничения возможностей работы с каналом в определенном контексте, что делает код более безопасным и понятным. Это особенно полезно в сигнатурах функций для явного указания, как функция взаимодействует с каналом.
Каналы: 9. Как работает итерация по каналу с помощью `range`?	<pre><code>for v := range ch {
    // Обработка значения v
}</code></pre>

Итерация с помощью `range` по каналу:

1. Читает значения из канала до его закрытия
2. Каждое прочитанное значение присваивается переменной `v` и выполняется тело цикла
3. Цикл автоматически завершается, когда канал закрывается и все значения из него прочитаны
4. Эквивалентно бесконечному циклу с чтением из канала и проверкой на закрытие
Каналы: 10. Какие оптимизации для каналов реализованы в Go runtime?	1. **Fast path для небуферизованных каналов**: Прямая передача данных между горутинами без копирования в буфер
2. **Перераспределение буфера**: Динамическое изменение размера буфера при необходимости
3. **Компиляторные оптимизации**: Встраивание операций с каналами и уменьшение overhead
4. **Lockless channels**: Экспериментальная функция для каналов без блокировок в определенных сценариях
5. **Оптимизация аллокаций**: Для маленьких элементов используется встроенное размещение в структуре канала
6. **Переиспользование каналов**: Очищенные каналы могут быть переиспользованы вместо создания новых
Контексты: 1. Что такое контекст в Go и какие проблемы он решает?	Контекст в Go — это примитив для управления временем жизни горутин, передачи дедлайнов, сигналов отмены и значений по дереву вызовов.

Контексты решают следующие проблемы:

1. **Управление временем жизни горутин** — позволяет изящно отменять операции
2. **Распространение дедлайнов и таймаутов** — устанавливает временные ограничения для операций
3. **Передача запрос-специфичных данных** — позволяет передавать метаданные по цепочке вызовов
4. **Предотвращение утечек ресурсов** — помогает очищать ресурсы при отмене операций
5. **Координация работы нескольких горутин** — обеспечивает согласованную отмену связанных операций
Контексты: 2. Какие методы предоставляет интерфейс `Context`?	Интерфейс `Context` предоставляет четыре метода:

<pre><code>type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}</code></pre>

1. **Deadline()** — возвращает время, когда контекст будет автоматически отменен (если установлено). Если дедлайн не установлен, ok будет false.
2. **Done()** — возвращает канал, который закрывается при отмене контекста или по истечению таймаута/дедлайна.
3. **Err()** — возвращает ошибку, описывающую причину отмены контекста (nil для активного контекста).
4. **Value(key)** — возвращает значение, ассоциированное с ключом, или nil, если значение не найдено.
Контексты: 3. Какие типы контекстов предоставляет пакет `context`?	Пакет `context` предоставляет несколько типов контекстов:

1. **Пустой контекст** (`emptyCtx`):
   - `context.Background()` — корневой контекст для всех дочерних
   - `context.TODO()` — для временного использования, когда неясно, какой контекст нужен

2. **Контекст с отменой** (`cancelCtx`):
   - `context.WithCancel(parent)` — возвращает контекст и функцию отмены

3. **Контекст с таймаутом** (`timerCtx`):
   - `context.WithTimeout(parent, timeout)` — контекст, отменяемый через указанное время

4. **Контекст с дедлайном** (`timerCtx`):
   - `context.WithDeadline(parent, time)` — контекст, отменяемый в указанный момент времени

5. **Контекст со значением** (`valueCtx`):
   - `context.WithValue(parent, key, value)` — контекст с добавленным ключ-значением
Контексты: 4. В чем разница между `context.Background()` и `context.TODO()`?	`context.Background()` и `context.TODO()` реализованы одинаково (как экземпляры `emptyCtx`), но имеют разное семантическое значение:

**context.Background()**:

- Используется как корневой контекст для всех дочерних контекстов
- Подходит для основных, долгоживущих операций (например, для основной функции сервера)
- Явно указывает, что это корень дерева контекстов
- Никогда не отменяется, не имеет значений и не имеет дедлайна

**context.TODO()**:

- Используется как временное решение, когда неясно, какой контекст следует использовать
- Указывает на "техническую задолженность" — код, который должен быть пересмотрен позже
- Служит как заполнитель, пока вы не решите, какой конкретно контекст нужен
- По реализации идентичен Background(), отличается только назначением
Контексты: 5. Как реализована отмена контекста? Что происходит при вызове функции отмены?	Отмена контекста реализована через структуру `cancelCtx` и связанную с ней функцию отмены:

<pre><code>type cancelCtx struct {
    Context
    mu       sync.Mutex
    done     atomic.Value // of chan struct{}
    children map[canceler]struct{}
    err      error
}</code></pre>

При вызове функции отмены происходит:

1. Блокировка мьютекса `mu` для защиты внутреннего состояния
2. Проверка, был ли контекст уже отменен (чтобы избежать повторной отмены)
3. Установка значения `err` в `context.Canceled`
4. Закрытие канала `done`, что сигнализирует о отмене
5. Отмена всех дочерних контекстов путем перебора `children`
6. Удаление из родительского контекста (если есть)
7. Разблокировка мьютекса

После отмены, `<-ctx.Done()` станет готовым, а `ctx.Err()` будет возвращать `context.Canceled` или `context.DeadlineExceeded`.
Контексты: 6. Как правильно использовать `context.WithValue`? Какие существуют ограничения?	`context.WithValue` создает новый контекст с добавленной парой ключ-значение:

<pre><code>ctx = context.WithValue(ctx, key, value)</code></pre>

**Правила и ограничения**:

1. **Типы ключей**:
   - Ключи должны быть сравнимыми (comparable) типами
   - Лучше использовать пользовательские типы для ключей, а не встроенные:

   ```go
   type contextKey string
   const userIDKey contextKey = "user_id"
   ```

2. **Назначение**:
   - Использовать только для запрос-специфичных данных, путешествующих через API и границы процессов
   - Подходит для: trace ID, request ID, авторизационная информация

3. **Что НЕ хранить в контекстах**:
   - Функциональные параметры
   - Глобальные конфигурации
   - Зависимости (БД, логгеры и т.д.)
   - Большие объекты данных

4. **Безопасность**:
   - Значения должны быть безопасными для использования несколькими горутинами
   - Значения не должны быть изменяемыми

5. **Производительность**:
   - Поиск значения требует линейного прохода по всей цепочке родительских контекстов
   - Частое извлечение значений из глубоких цепочек контекстов может быть неэффективным
Контексты: 7. Как устроена иерархия контекстов? Что происходит при отмене родительского контекста?	Контексты образуют древовидную структуру, где:

1. Родительский контекст создается первым
2. Дочерние контексты создаются на основе родительского
3. Дочерние контексты наследуют все свойства родителя, но могут добавлять свои

Визуально иерархия выглядит так:

<pre><code>Background
    ├── WithValue(k1, v1)
    │       └── WithCancel
    │             └── WithTimeout
    └── WithCancel
            └── WithValue(k2, v2)</code></pre>

**При отмене родительского контекста**:

1. Родительский контекст закрывает свой канал `done`
2. Все дочерние контексты автоматически отменяются
3. Сигнал отмены распространяется вниз по дереву
4. Все горутины, ожидающие на `<-ctx.Done()` любого из контекстов, разблокируются
5. Каждый контекст в иерархии получает ошибку отмены (доступную через `Err()`)

Важно: отмена дочернего контекста не влияет на родительский или на "братские" контексты.
Контексты: 8. Какие лучшие практики существуют при работе с контекстами?	1. **Первый параметр функции**:

   ```go
   func DoSomething(ctx context.Context, arg Arg) error {
       // ...
   }
   ```

2. **Не хранить контексты в структурах**:

   ```go
   // Плохо:
   type Service struct {
       ctx context.Context
   }
   
   // Хорошо:
   type Service struct {}
   
   func (s *Service) Process(ctx context.Context) {
       // ...
   }
   ```

3. **Всегда отменять контексты**:

   ```go
   ctx, cancel := context.WithTimeout(ctx, timeout)
   defer cancel() // Всегда вызывать, даже после истечения таймаута
   ```

4. **Проверять отмену в долгих операциях**:

   ```go
   for {
       select {
       case <-ctx.Done():
           return ctx.Err()
       default:
           // Продолжать работу
       }
   }
   ```

5. **Правильно передавать контекст**:

   ```go
   // Передавать контекст во все функции, которые могут блокироваться
   data, err := db.QueryContext(ctx, query)
   ```

6. **Группировать связанные значения**:

   ```go
   // Вместо множества WithValue вызовов
   type RequestData struct {
       TraceID string
       UserID  string
   }
   ctx = context.WithValue(ctx, requestDataKey, RequestData{...})
   ```

7. **Документировать ключи контекста**:

   ```go
   // Документировать какие ключи и типы значений ожидаются
   // Определять ключи как константы
   const (
       traceIDKey contextKey = "trace_id"
       userIDKey  contextKey = "user_id"
   )
   ```
Контексты: 9. Какие антипаттерны использования контекстов следует избегать?	1. **Игнорирование контекста**:

   ```go
   // Плохо: контекст не используется для управления временем жизни
   func process(ctx context.Context, data []byte) {
       time.Sleep(10 * time.Second) // Игнорирует отмену
   }
   ```

2. **Хранение контекстов в полях структур**:

   ```go
   // Плохо: контекст должен проходить через параметры
   type Service struct {
       ctx context.Context
   }
   ```

3. **Использование нетипизированных ключей**:

   ```go
   // Плохо: строковые ключи без типизации
   ctx = context.WithValue(ctx, "user_id", userID)
   
   // Хорошо:
   type contextKey string
   const userIDKey contextKey = "user_id"
   ctx = context.WithValue(ctx, userIDKey, userID)
   ```

4. **Хранение в контексте зависимостей**:

   ```go
   // Плохо: передача зависимостей через контекст
   ctx = context.WithValue(ctx, "db", database)
   ```

5. **Создание контекстов без отмены**:

   ```go
   // Плохо: нет возможности отменить долгую операцию
   ctx := context.Background()
   go longRunningTask(ctx) // Нельзя отменить
   ```

6. **Использование контекста после отмены**:

   ```go
   ctx, cancel := context.WithCancel(parentCtx)
   cancel()
   
   // Плохо: использование отмененного контекста
   result, err := service.Process(ctx)
   ```

7. **Потеря ошибок отмены**:

   ```go
   // Плохо: игнорирование ctx.Err()
   select {
   case <-ctx.Done():
       return nil // Должно быть return ctx.Err()
   }
   ```

8. **Создание "зомби" горутин**:

   ```go
   // Плохо: горутина может работать вечно
   go func() {
       for {
           // Нет проверки контекста
       }
   }(ctx)
   ```
Контексты: 10. Как контексты интегрируются с другими частями стандартной библиотеки (HTTP, SQL, и т.д.)?	### HTTP

**HTTP-сервер**:

<pre><code>func handler(w http.ResponseWriter, r *http.Request) {
    // Получение контекста запроса
    ctx := r.Context()
    
    // Можно создать дочерний с таймаутом
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    // Использование контекста
    results, err := db.QueryContext(ctx, query)
}</code></pre>

HTTP-сервер автоматически отменяет контекст запроса, когда клиент разрывает соединение.

**HTTP-клиент**:

<pre><code>req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, err := http.DefaultClient.Do(req)</code></pre>

Запрос будет отменен, если контекст отменяется, таймаут истекает или происходит дедлайн.

### SQL

<pre><code>// Запрос с контекстом
rows, err := db.QueryContext(ctx, "SELECT * FROM users WHERE id = ?", id)

// Выполнение с контекстом
result, err := db.ExecContext(ctx, "UPDATE users SET status = ? WHERE id = ?", status, id)

// Подготовленные запросы
stmt, err := db.PrepareContext(ctx, "SELECT * FROM users WHERE id = ?")
rows, err := stmt.QueryContext(ctx, id)</code></pre>

Операции с базой данных отменяются при отмене контекста, что освобождает ресурсы.

### gRPC

<pre><code>// Клиент
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()
resp, err := client.SomeMethod(ctx, req)

// Сервер
func (s *Server) SomeMethod(ctx context.Context, req *pb.Request) (*pb.Response, error) {
    // Использование контекста
    if err := ctx.Err(); err != nil {
        return nil, err
    }
}</code></pre>

gRPC полностью интегрирован с контекстами для отмены операций и передачи метаданных.

### io/fs

<pre><code>err := fs.WalkDir(fsys, ".", func(path string, d fs.DirEntry, err error) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        // Обработка директории
    }
})</code></pre>

### time

<pre><code>timer := time.NewTimer(time.Second)
select {
case <-ctx.Done():
    timer.Stop()
    return ctx.Err()
case <-timer.C:
    // Обработка таймаута
}</code></pre>

Стандартная библиотека Go последовательно использует контексты для отмены операций и управления временем жизни, что делает их универсальным механизмом для работы с асинхронными операциями.
Оператор select и мультиплексирование: 1. Что такое оператор `select` и для чего он используется?	Оператор `select` в Go позволяет горутине ожидать операций на нескольких каналах одновременно. Он предоставляет механизм мультиплексирования, позволяя программе реагировать на события из нескольких источников.

<pre><code>select {
case v1 := <-ch1:
    // Обработка данных из канала ch1
case ch2 <- v2:
    // Отправка данных в канал ch2
case <-time.After(1 * time.Second):
    // Обработка тайм-аута
default:
    // Выполняется, если ни один из каналов не готов
}</code></pre>

Оператор `select` используется для:

1. Ожидания операций на нескольких каналах
2. Реализации тайм-аутов
3. Неблокирующих операций с каналами через ветку default
4. Координации работы нескольких горутин
5. Реализации механизмов отмены операций
Оператор select и мультиплексирование: 2. Как `select` выбирает между несколькими готовыми каналами?	Если несколько каналов в `select` готовы для операций одновременно, Go выбирает случайную ветку из готовых. Это делается намеренно, чтобы избежать фаворитизма и потенциального голодания каналов.

Алгоритм выбора:

1. Go рантайм оценивает все ветки `select`
2. Определяет, какие из них готовы для операций (отправка/получение)
3. Если готово несколько веток, случайным образом выбирает одну из них
4. Рандомизация происходит через алгоритм псевдослучайного выбора, реализованный в runtime

Эта случайность является важной особенностью `select`, обеспечивающей справедливость между каналами.
Оператор select и мультиплексирование: 3. Что произойдет, если в `select` нет готовых каналов и нет ветки `default`?	Если в `select` нет готовых каналов и отсутствует ветка `default`, горутина блокируется до тех пор, пока хотя бы один из каналов не станет готовым для операции. Это позволяет горутине ожидать события без активного потребления ресурсов CPU.

<pre><code>select {
case val := <-ch1:
    // Обработка значения из ch1
case <-ch2:
    // Реакция на сигнал из ch2
}
// Эта строка не выполнится, пока один из каналов не станет готовым</code></pre>

Если ни один из каналов никогда не станет готовым (например, все каналы закрыты или никто в них не пишет), горутина останется заблокированной навсегда, что может привести к утечке горутин.
Оператор select и мультиплексирование: 4. Как реализован `select` внутренне в Go runtime?	`select` компилируется в серию вызовов рантайма, которые реализуют следующие шаги:

1. **Подготовка случаев**: Анализ всех веток `select` и создание списка операций с каналами.
2. **Перемешивание порядка**: Случайное перемешивание веток для обеспечения справедливости выбора.
3. **Проверка готовности**: Неблокирующая проверка всех каналов на готовность к операциям.
4. **Обработка готового канала** или **блокировка**:
   - Если есть готовый канал, выполняется соответствующая ветка
   - Если ни один канал не готов и нет ветки `default`, горутина блокируется до регистрации в очередях каналов

Основной путь исполнения в runtime:

<pre><code>select → runtime.selectgo → runtime.selectnbsend/selectnbrecv → runtime.chansend/chanrecv</code></pre>

Структуры данных:

- `scase` - представляет одну ветку select
- `pollorder` - массив с перемешанным порядком проверки каналов
- `lockorder` - массив, определяющий порядок блокировки каналов для предотвращения deadlock
Оператор select и мультиплексирование: 5. Какие типичные шаблоны использования `select` существуют?	1. **Тайм-аут**:

<pre><code>select {
case result := <-ch:
    // Обработка результата
case <-time.After(1 * time.Second):
    // Обработка тайм-аута
}</code></pre>

2. **Неблокирующие операции с каналами**:

<pre><code>select {
case ch <- value:
    // Значение отправлено
default:
    // Канал заблокирован, действуем иначе
}</code></pre>

3. **Мультиплексирование нескольких источников**:

<pre><code>select {
case msg1 := <-ch1:
    // Обработка сообщения из ch1
case msg2 := <-ch2:
    // Обработка сообщения из ch2
case msg3 := <-ch3:
    // Обработка сообщения из ch3
}</code></pre>

4. **Отмена операций**:

<pre><code>select {
case result := <-workCh:
    // Обработка результата
case <-cancelCh:
    // Операция отменена
}</code></pre>

5. **Бесконечный цикл с обработкой сигналов**:

<pre><code>for {
    select {
    case data := <-dataCh:
        // Обработка данных
    case <-quitCh:
        return
    }
}</code></pre>
Оператор select и мультиплексирование: 6. Как реализовать тайм-аут с помощью `select`?	Тайм-аут в Go реализуется комбинацией `select` и функции `time.After`, которая возвращает канал, который получит значение через указанное время:

<pre><code>func fetchWithTimeout(url string, timeout time.Duration) (*http.Response, error) {
    // Создаем канал для результата
    respCh := make(chan *http.Response)
    errCh := make(chan error)
    
    // Запускаем запрос в отдельной горутине
    go func() {
        resp, err := http.Get(url)
        if err != nil {
            errCh <- err
            return
        }
        respCh <- resp
    }()
    
    // Ожидаем результат с тайм-аутом
    select {
    case resp := <-respCh:
        return resp, nil
    case err := <-errCh:
        return nil, err
    case <-time.After(timeout):
        return nil, fmt.Errorf("request timed out after %v", timeout)
    }
}</code></pre>

В этом примере, если запрос не завершится до истечения тайм-аута, `<-time.After(timeout)` станет готовым, и мы вернем ошибку тайм-аута.
Оператор select и мультиплексирование: 7. Как реализовать неблокирующую отправку или получение с помощью `select`?	Неблокирующие операции с каналами реализуются с помощью ветки `default` в `select`:

**Неблокирующая отправка**:

<pre><code>func tryPut(ch chan int, value int) bool {
    select {
    case ch <- value:
        // Успешно отправили значение
        return true
    default:
        // Канал заблокирован, отправка невозможна
        return false
    }
}</code></pre>

**Неблокирующее получение**:

<pre><code>func tryGet(ch chan int) (int, bool) {
    select {
    case val := <-ch:
        // Успешно получили значение
        return val, true
    default:
        // Канал пуст или заблокирован, получение невозможно
        return 0, false
    }
}</code></pre>

Эти шаблоны позволяют проверить возможность операции с каналом без блокировки горутины. Если операция невозможна (канал полон или пуст), выполняется ветка `default`.
Оператор select и мультиплексирование: 8. Что произойдет, если использовать пустой `select {}`?	Пустой `select {}` без каких-либо веток (`case` или `default`) блокирует горутину навсегда. Поскольку нет ни одного случая для обработки и нет ветки `default`, горутина входит в бесконечное ожидание событий, которых никогда не произойдет.

<pre><code>func blockForever() {
    select {}
    // Этот код никогда не будет достигнут
}</code></pre>

Пустой `select` иногда используется намеренно, чтобы предотвратить завершение главной горутины, когда все остальные горутины должны работать бесконечно:

<pre><code>func main() {
    // Запускаем фоновые сервисы
    go service1()
    go service2()
    
    // Предотвращаем завершение программы
    select {}
}</code></pre>

Однако обычно лучше использовать более явные механизмы ожидания, такие как сигнальные каналы или WaitGroup.
Оператор select и мультиплексирование: 9. В каком порядке вычисляются выражения каналов в `select`?	Выражения каналов в `select` вычисляются слева направо, сверху вниз, до выполнения операции с каналом. Это важно понимать, потому что выражения могут иметь побочные эффекты.

<pre><code>select {
case c <- f():  // f() вызывается до проверки готовности канала c
    // ...
case v := <-d():  // d() вызывается до проверки готовности результирующего канала
    // ...
}</code></pre>

Порядок оценки:

1. Сначала вычисляются все выражения каналов (`c`, `f()`, `d()` в примере выше)
2. Затем проверяется готовность каналов
3. Если несколько каналов готовы, выбирается случайный
4. Выполняется соответствующая операция с каналом и код в выбранной ветке

Если вызов функции в выражении канала имеет побочные эффекты, они произойдут независимо от того, будет ли выбрана соответствующая ветка.
Оператор select и мультиплексирование: 10. Какие ограничения есть у оператора `select`?	1. **Только операции с каналами**: `select` может обрабатывать только операции чтения и записи в каналы. Другие операции должны быть в теле веток `case`.

2. **Нет условий в ветках `case`**: В отличие от `switch`, `select` не поддерживает условные выражения в ветках `case`.

<pre><code>// Неправильно:
select {
case x > 5:  // Ошибка компиляции
    // ...
}</code></pre>

3. **Нет проваливания (fallthrough)**: Нельзя использовать `fallthrough` между ветками `select`.

4. **Нет динамического количества веток**: Количество веток `case` должно быть известно на этапе компиляции.

5. **Коммуникация только через каналы**: Нет встроенной поддержки для других механизмов синхронизации (мьютексы, условные переменные).

6. **Нельзя закрыть канал через select**: `select` не предоставляет прямого синтаксиса для закрытия канала.

7. **Все выражения вычисляются**: Все выражения каналов вычисляются, даже если соответствующая ветка не будет выбрана.

8. **Только одна операция с каналом на ветку**: Каждая ветка `case` может содержать только одну операцию с каналом.

<pre><code>// Неправильно:
select {
case v1 := <-ch1, v2 := <-ch2:  // Ошибка компиляции
    // ...
}</code></pre>

9. **Нет приоритетов выбора**: При нескольких готовых каналах выбор случайный, нельзя задать приоритет.

10. **Нет прямого способа узнать, какая ветка была выбрана**: Нужно использовать дополнительные переменные или логику для отслеживания.
Примитивы синхронизации и пакет sync: 1. Какие примитивы синхронизации предоставляет пакет `sync`?	Пакет `sync` предоставляет следующие примитивы синхронизации:

- `Mutex` - мьютекс для защиты общих ресурсов от одновременного доступа
- `RWMutex` - мьютекс с разделением доступа на чтение и запись
- `WaitGroup` - ожидание завершения группы горутин
- `Once` - гарантированное однократное выполнение действия
- `Cond` - условная переменная для ожидания событий
- `Pool` - пул объектов для переиспользования
- `Map` - конкурентно-безопасная реализация карты

Также есть связанный пакет `sync/atomic`, предоставляющий атомарные операции для примитивных типов.
Примитивы синхронизации и пакет sync: 2. В чем разница между `Mutex` и `RWMutex`? Когда стоит использовать каждый из них?	**Mutex** предоставляет взаимное исключение: только одна горутина может захватить блокировку в определенный момент времени.

**RWMutex** (Read-Write Mutex) предоставляет более гранулярный контроль:

- Множество горутин могут одновременно захватить блокировку на чтение (`RLock`)
- Только одна горутина может захватить блокировку на запись (`Lock`)
- Блокировка на запись исключает любые блокировки на чтение

**Когда использовать:**

- **Mutex**: для простых сценариев, когда не нужно разделять чтение и запись, или когда операции чтения также изменяют состояние
- **RWMutex**: когда операции чтения значительно преобладают над операциями записи, и есть много горутин, читающих данные одновременно
Примитивы синхронизации и пакет sync: 3. Как устроен мьютекс внутри? Какие состояния он может иметь?	<pre><code>type Mutex struct {
    state int32  // Состояние мьютекса: незаблокирован, заблокирован, ожидают, проснулся
    sema  uint32 // Семафор для блокировки горутин
}</code></pre>

Состояние мьютекса закодировано в поле `state` как битовое поле:

- **Бит 0**: Заблокирован (1) или не заблокирован (0)
- **Бит 1**: Пробуждение (woken)
- **Бит 2-31**: Счетчик ожидающих горутин

Мьютекс в Go использует комбинированный подход:

1. **Быстрый путь**: Попытка получить блокировку без ожидания (атомарные операции)
2. **Спинлок**: Кратковременное активное ожидание блокировки
3. **Блокировка через семафор**: Полная блокировка горутины при долгом ожидании
Примитивы синхронизации и пакет sync: 4. Для чего предназначен `WaitGroup` и как им правильно пользоваться?	`WaitGroup` используется для ожидания завершения группы горутин. Он имеет счетчик, который может увеличиваться и уменьшаться.

Правильное использование:

<pre><code>func processItems(items []int) {
    var wg sync.WaitGroup
    
    for _, item := range items {
        wg.Add(1)  // Увеличение счетчика перед запуском горутины
        go func(i int) {
            defer wg.Done()  // Уменьшение счетчика при завершении (эквивалентно wg.Add(-1))
            process(i)
        }(item)
    }
    
    wg.Wait()  // Блокировка до обнуления счетчика
}</code></pre>

Ключевые правила:

1. `Add()` должен вызываться до запуска горутин
2. `Done()` должен вызываться в каждой горутине независимо от результата (обычно через defer)
3. `Wait()` блокирует вызывающую горутину до тех пор, пока счетчик не станет равен 0
4. Нельзя копировать `WaitGroup` после первого использования
5. `Wait()` должен вызываться после всех вызовов `Add()`
Примитивы синхронизации и пакет sync: 5. Что такое `sync.Once` и для каких задач он подходит?	`sync.Once` гарантирует, что функция будет выполнена только один раз, даже если `Do()` вызывается из разных горутин.

<pre><code>var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}</code></pre>

`sync.Once` подходит для:

1. Инициализации синглтонов
2. Отложенной инициализации ресурсоемких объектов
3. Регистрации, которая должна произойти только один раз
4. Создание соединений, которые должны быть инициализированы лишь однократно
5. Настройка, которая должна выполниться ровно один раз
Примитивы синхронизации и пакет sync: 6. Как работает условная переменная `sync.Cond`? Какие методы она предоставляет?	`sync.Cond` позволяет горутинам ожидать изменения какого-либо условия и получать сигналы об этих изменениях.

Методы:

- `NewCond(l Locker)` — создает новую условную переменную с заданным Locker
- `Wait()` — атомарно освобождает связанную блокировку и блокирует вызывающую горутину, затем снова захватывает блокировку при пробуждении
- `Signal()` — пробуждает одну из ожидающих горутин
- `Broadcast()` — пробуждает все ожидающие горутины

Пример использования (очередь):

<pre><code>type Queue struct {
    cond *sync.Cond
    data []interface{}
}

func NewQueue() *Queue {
    return &Queue{
        cond: sync.NewCond(&sync.Mutex{}),
    }
}

func (q *Queue) Push(item interface{}) {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    q.data = append(q.data, item)
    q.cond.Signal() // Уведомить одного ожидающего
}

func (q *Queue) Pop() interface{} {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    
    for len(q.data) == 0 {
        q.cond.Wait() // Ждем, пока очередь не станет непустой
    }
    
    item := q.data[0]
    q.data = q.data[1:]
    return item
}</code></pre>
Примитивы синхронизации и пакет sync: 7. Для чего используется `sync.Pool` и как она взаимодействует со сборщиком мусора?	`sync.Pool` предоставляет кэш временных объектов, которые могут быть сохранены и извлечены позже, избегая частых аллокаций и сборки мусора.

<pre><code>var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func ProcessRequest() {
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)
    }()
    
    // Использовать buf...
}</code></pre>

Взаимодействие со сборщиком мусора:

1. Объекты в пуле могут быть удалены в любой момент сборки мусора без уведомления
2. Все объекты в пуле очищаются при каждом запуске сборщика мусора
3. `sync.Pool` имеет "victim cache" для хранения объектов между циклами GC
4. Пул не подходит для долгосрочного хранения объектов или для объектов, требующих явного освобождения ресурсов
Примитивы синхронизации и пакет sync: 8. Какие атомарные операции предоставляет пакет `sync/atomic`?	Пакет `sync/atomic` предоставляет низкоуровневые атомарные операции памяти:

1. **Load** — атомарное чтение (например, `atomic.LoadInt64(&counter)`)
2. **Store** — атомарная запись (например, `atomic.StoreInt64(&counter, 42)`)
3. **Add** — атомарное добавление (например, `atomic.AddInt64(&counter, 1)`)
4. **Swap** — атомарный обмен значениями (например, `atomic.SwapInt64(&counter, 100)`)
5. **CompareAndSwap (CAS)** — атомарная условная замена (например, `atomic.CompareAndSwapInt64(&counter, old, new)`)

Эти операции доступны для типов: int32, int64, uint32, uint64, uintptr, unsafe.Pointer.

Также есть тип `atomic.Value` для атомарных операций с произвольными типами:

<pre><code>var config atomic.Value
config.Store(loadConfig())
// Позже, в другой горутине:
currentConfig := config.Load().(Config)</code></pre>
Примитивы синхронизации и пакет sync: 9. В чем преимущества и недостатки использования `sync.Map` по сравнению с обычной картой с мьютексом?	**Преимущества `sync.Map`**:

1. Оптимизирована для случаев, когда операции чтения значительно преобладают над записью
2. Не требует явного использования мьютексов
3. Более эффективна при высоком уровне параллелизма
4. Использует два внутренних хранилища: read-only и dirty, что снижает контенцию
5. Атомарные операции для чтений, не требующие блокировок

**Недостатки `sync.Map`**:

1. Более высокие накладные расходы при интенсивных записях
2. Отсутствует встроенная поддержка len() для получения размера
3. Требует приведения типов при получении значений
4. Отсутствует поддержка range для перебора элементов
5. Может быть менее эффективна для простых случаев с низким уровнем параллелизма

**Когда использовать:**

- `sync.Map`: когда карта доступна из множества горутин и преобладают операции чтения
- Обычную карту с мьютексом: когда операции записи частые или при низком параллелизме
Примитивы синхронизации и пакет sync: 10. Какие проблемы могут возникнуть при неправильном использовании примитивов синхронизации?	1. **Deadlock (взаимная блокировка)**: Горутины циклически ожидают ресурсы, удерживаемые друг другом.

   ```go
   func deadlockExample() {
       var mu1, mu2 sync.Mutex
       go func() {
           mu1.Lock()
           time.Sleep(1 * time.Millisecond)
           mu2.Lock() // Потенциальный deadlock
           // ...
       }()
       go func() {
           mu2.Lock()
           time.Sleep(1 * time.Millisecond)
           mu1.Lock() // Потенциальный deadlock
           // ...
       }()
   }
   ```

2. **Race Condition (состояние гонки)**: Одновременный доступ к данным без синхронизации.

   ```go
   func raceExample() {
       counter := 0
       for i := 0; i < 1000; i++ {
           go func() {
               counter++ // Гонка данных
           }()
       }
   }
   ```

3. **Livelock**: Горутины активны, но не продвигаются в работе, постоянно реагируя на действия друг друга.

4. **Starvation (голодание)**: Некоторые горутины не получают доступ к ресурсам из-за других, более привилегированных горутин.

5. **Использование неинициализированных примитивов**: Например, вызов Wait() на nil WaitGroup.

6. **Забытые блокировки**: Захват мьютекса без последующего освобождения.

7. **Неправильное использование копий**: Копирование мьютексов или других примитивов синхронизации после их инициализации или использования.

8. **Memory leaks**: Утечки памяти из-за удерживания ссылок на объекты в примитивах синхронизации.

9. **Excessive locking**: Излишние блокировки, снижающие параллельность кода.

10. **Ошибки в условиях**: Неправильные условия в sync.Cond.Wait() или select, приводящие к вечному ожиданию.
