# Контексты - ответы на вопросы

## 1. Что такое контекст в Go и какие проблемы он решает?

Контекст в Go — это примитив для управления временем жизни горутин, передачи дедлайнов, сигналов отмены и значений по дереву вызовов.

Контексты решают следующие проблемы:

1. **Управление временем жизни горутин** — позволяет изящно отменять операции
2. **Распространение дедлайнов и таймаутов** — устанавливает временные ограничения для операций
3. **Передача запрос-специфичных данных** — позволяет передавать метаданные по цепочке вызовов
4. **Предотвращение утечек ресурсов** — помогает очищать ресурсы при отмене операций
5. **Координация работы нескольких горутин** — обеспечивает согласованную отмену связанных операций

## 2. Какие методы предоставляет интерфейс `Context`?

Интерфейс `Context` предоставляет четыре метода:

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

1. **Deadline()** — возвращает время, когда контекст будет автоматически отменен (если установлено). Если дедлайн не установлен, ok будет false.
2. **Done()** — возвращает канал, который закрывается при отмене контекста или по истечению таймаута/дедлайна.
3. **Err()** — возвращает ошибку, описывающую причину отмены контекста (nil для активного контекста).
4. **Value(key)** — возвращает значение, ассоциированное с ключом, или nil, если значение не найдено.

## 3. Какие типы контекстов предоставляет пакет `context`?

Пакет `context` предоставляет несколько типов контекстов:

1. **Пустой контекст** (`emptyCtx`):
   - `context.Background()` — корневой контекст для всех дочерних
   - `context.TODO()` — для временного использования, когда неясно, какой контекст нужен

2. **Контекст с отменой** (`cancelCtx`):
   - `context.WithCancel(parent)` — возвращает контекст и функцию отмены

3. **Контекст с таймаутом** (`timerCtx`):
   - `context.WithTimeout(parent, timeout)` — контекст, отменяемый через указанное время

4. **Контекст с дедлайном** (`timerCtx`):
   - `context.WithDeadline(parent, time)` — контекст, отменяемый в указанный момент времени

5. **Контекст со значением** (`valueCtx`):
   - `context.WithValue(parent, key, value)` — контекст с добавленным ключ-значением

## 4. В чем разница между `context.Background()` и `context.TODO()`?

`context.Background()` и `context.TODO()` реализованы одинаково (как экземпляры `emptyCtx`), но имеют разное семантическое значение:

**context.Background()**:

- Используется как корневой контекст для всех дочерних контекстов
- Подходит для основных, долгоживущих операций (например, для основной функции сервера)
- Явно указывает, что это корень дерева контекстов
- Никогда не отменяется, не имеет значений и не имеет дедлайна

**context.TODO()**:

- Используется как временное решение, когда неясно, какой контекст следует использовать
- Указывает на "техническую задолженность" — код, который должен быть пересмотрен позже
- Служит как заполнитель, пока вы не решите, какой конкретно контекст нужен
- По реализации идентичен Background(), отличается только назначением

## 5. Как реализована отмена контекста? Что происходит при вызове функции отмены?

Отмена контекста реализована через структуру `cancelCtx` и связанную с ней функцию отмены:

```go
type cancelCtx struct {
    Context
    mu       sync.Mutex
    done     atomic.Value // of chan struct{}
    children map[canceler]struct{}
    err      error
}
```

При вызове функции отмены происходит:

1. Блокировка мьютекса `mu` для защиты внутреннего состояния
2. Проверка, был ли контекст уже отменен (чтобы избежать повторной отмены)
3. Установка значения `err` в `context.Canceled`
4. Закрытие канала `done`, что сигнализирует о отмене
5. Отмена всех дочерних контекстов путем перебора `children`
6. Удаление из родительского контекста (если есть)
7. Разблокировка мьютекса

После отмены, `<-ctx.Done()` станет готовым, а `ctx.Err()` будет возвращать `context.Canceled` или `context.DeadlineExceeded`.

## 6. Как правильно использовать `context.WithValue`? Какие существуют ограничения?

`context.WithValue` создает новый контекст с добавленной парой ключ-значение:

```go
ctx = context.WithValue(ctx, key, value)
```

**Правила и ограничения**:

1. **Типы ключей**:
   - Ключи должны быть сравнимыми (comparable) типами
   - Лучше использовать пользовательские типы для ключей, а не встроенные:

   ```go
   type contextKey string
   const userIDKey contextKey = "user_id"
   ```

2. **Назначение**:
   - Использовать только для запрос-специфичных данных, путешествующих через API и границы процессов
   - Подходит для: trace ID, request ID, авторизационная информация

3. **Что НЕ хранить в контекстах**:
   - Функциональные параметры
   - Глобальные конфигурации
   - Зависимости (БД, логгеры и т.д.)
   - Большие объекты данных

4. **Безопасность**:
   - Значения должны быть безопасными для использования несколькими горутинами
   - Значения не должны быть изменяемыми

5. **Производительность**:
   - Поиск значения требует линейного прохода по всей цепочке родительских контекстов
   - Частое извлечение значений из глубоких цепочек контекстов может быть неэффективным

## 7. Как устроена иерархия контекстов? Что происходит при отмене родительского контекста?

Контексты образуют древовидную структуру, где:

1. Родительский контекст создается первым
2. Дочерние контексты создаются на основе родительского
3. Дочерние контексты наследуют все свойства родителя, но могут добавлять свои

Визуально иерархия выглядит так:

```
Background
    ├── WithValue(k1, v1)
    │       └── WithCancel
    │             └── WithTimeout
    └── WithCancel
            └── WithValue(k2, v2)
```

**При отмене родительского контекста**:

1. Родительский контекст закрывает свой канал `done`
2. Все дочерние контексты автоматически отменяются
3. Сигнал отмены распространяется вниз по дереву
4. Все горутины, ожидающие на `<-ctx.Done()` любого из контекстов, разблокируются
5. Каждый контекст в иерархии получает ошибку отмены (доступную через `Err()`)

Важно: отмена дочернего контекста не влияет на родительский или на "братские" контексты.

## 8. Какие лучшие практики существуют при работе с контекстами?

1. **Первый параметр функции**:

   ```go
   func DoSomething(ctx context.Context, arg Arg) error {
       // ...
   }
   ```

2. **Не хранить контексты в структурах**:

   ```go
   // Плохо:
   type Service struct {
       ctx context.Context
   }
   
   // Хорошо:
   type Service struct {}
   
   func (s *Service) Process(ctx context.Context) {
       // ...
   }
   ```

3. **Всегда отменять контексты**:

   ```go
   ctx, cancel := context.WithTimeout(ctx, timeout)
   defer cancel() // Всегда вызывать, даже после истечения таймаута
   ```

4. **Проверять отмену в долгих операциях**:

   ```go
   for {
       select {
       case <-ctx.Done():
           return ctx.Err()
       default:
           // Продолжать работу
       }
   }
   ```

5. **Правильно передавать контекст**:

   ```go
   // Передавать контекст во все функции, которые могут блокироваться
   data, err := db.QueryContext(ctx, query)
   ```

6. **Группировать связанные значения**:

   ```go
   // Вместо множества WithValue вызовов
   type RequestData struct {
       TraceID string
       UserID  string
   }
   ctx = context.WithValue(ctx, requestDataKey, RequestData{...})
   ```

7. **Документировать ключи контекста**:

   ```go
   // Документировать какие ключи и типы значений ожидаются
   // Определять ключи как константы
   const (
       traceIDKey contextKey = "trace_id"
       userIDKey  contextKey = "user_id"
   )
   ```

## 9. Какие антипаттерны использования контекстов следует избегать?

1. **Игнорирование контекста**:

   ```go
   // Плохо: контекст не используется для управления временем жизни
   func process(ctx context.Context, data []byte) {
       time.Sleep(10 * time.Second) // Игнорирует отмену
   }
   ```

2. **Хранение контекстов в полях структур**:

   ```go
   // Плохо: контекст должен проходить через параметры
   type Service struct {
       ctx context.Context
   }
   ```

3. **Использование нетипизированных ключей**:

   ```go
   // Плохо: строковые ключи без типизации
   ctx = context.WithValue(ctx, "user_id", userID)
   
   // Хорошо:
   type contextKey string
   const userIDKey contextKey = "user_id"
   ctx = context.WithValue(ctx, userIDKey, userID)
   ```

4. **Хранение в контексте зависимостей**:

   ```go
   // Плохо: передача зависимостей через контекст
   ctx = context.WithValue(ctx, "db", database)
   ```

5. **Создание контекстов без отмены**:

   ```go
   // Плохо: нет возможности отменить долгую операцию
   ctx := context.Background()
   go longRunningTask(ctx) // Нельзя отменить
   ```

6. **Использование контекста после отмены**:

   ```go
   ctx, cancel := context.WithCancel(parentCtx)
   cancel()
   
   // Плохо: использование отмененного контекста
   result, err := service.Process(ctx)
   ```

7. **Потеря ошибок отмены**:

   ```go
   // Плохо: игнорирование ctx.Err()
   select {
   case <-ctx.Done():
       return nil // Должно быть return ctx.Err()
   }
   ```

8. **Создание "зомби" горутин**:

   ```go
   // Плохо: горутина может работать вечно
   go func() {
       for {
           // Нет проверки контекста
       }
   }(ctx)
   ```

## 10. Как контексты интегрируются с другими частями стандартной библиотеки (HTTP, SQL, и т.д.)?

### HTTP

**HTTP-сервер**:

```go
func handler(w http.ResponseWriter, r *http.Request) {
    // Получение контекста запроса
    ctx := r.Context()
    
    // Можно создать дочерний с таймаутом
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    // Использование контекста
    results, err := db.QueryContext(ctx, query)
}
```

HTTP-сервер автоматически отменяет контекст запроса, когда клиент разрывает соединение.

**HTTP-клиент**:

```go
req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, err := http.DefaultClient.Do(req)
```

Запрос будет отменен, если контекст отменяется, таймаут истекает или происходит дедлайн.

### SQL

```go
// Запрос с контекстом
rows, err := db.QueryContext(ctx, "SELECT * FROM users WHERE id = ?", id)

// Выполнение с контекстом
result, err := db.ExecContext(ctx, "UPDATE users SET status = ? WHERE id = ?", status, id)

// Подготовленные запросы
stmt, err := db.PrepareContext(ctx, "SELECT * FROM users WHERE id = ?")
rows, err := stmt.QueryContext(ctx, id)
```

Операции с базой данных отменяются при отмене контекста, что освобождает ресурсы.

### gRPC

```go
// Клиент
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()
resp, err := client.SomeMethod(ctx, req)

// Сервер
func (s *Server) SomeMethod(ctx context.Context, req *pb.Request) (*pb.Response, error) {
    // Использование контекста
    if err := ctx.Err(); err != nil {
        return nil, err
    }
}
```

gRPC полностью интегрирован с контекстами для отмены операций и передачи метаданных.

### io/fs

```go
err := fs.WalkDir(fsys, ".", func(path string, d fs.DirEntry, err error) error {
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
        // Обработка директории
    }
})
```

### time

```go
timer := time.NewTimer(time.Second)
select {
case <-ctx.Done():
    timer.Stop()
    return ctx.Err()
case <-timer.C:
    // Обработка таймаута
}
```

Стандартная библиотека Go последовательно использует контексты для отмены операций и управления временем жизни, что делает их универсальным механизмом для работы с асинхронными операциями.
