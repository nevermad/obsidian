# Примитивы синхронизации и пакет sync - ответы на вопросы

## 1. Какие примитивы синхронизации предоставляет пакет `sync`?

Пакет `sync` предоставляет следующие примитивы синхронизации:

- `Mutex` - мьютекс для защиты общих ресурсов от одновременного доступа
- `RWMutex` - мьютекс с разделением доступа на чтение и запись
- `WaitGroup` - ожидание завершения группы горутин
- `Once` - гарантированное однократное выполнение действия
- `Cond` - условная переменная для ожидания событий
- `Pool` - пул объектов для переиспользования
- `Map` - конкурентно-безопасная реализация карты

Также есть связанный пакет `sync/atomic`, предоставляющий атомарные операции для примитивных типов.

## 2. В чем разница между `Mutex` и `RWMutex`? Когда стоит использовать каждый из них?

**Mutex** предоставляет взаимное исключение: только одна горутина может захватить блокировку в определенный момент времени.

**RWMutex** (Read-Write Mutex) предоставляет более гранулярный контроль:

- Множество горутин могут одновременно захватить блокировку на чтение (`RLock`)
- Только одна горутина может захватить блокировку на запись (`Lock`)
- Блокировка на запись исключает любые блокировки на чтение

**Когда использовать:**

- **Mutex**: для простых сценариев, когда не нужно разделять чтение и запись, или когда операции чтения также изменяют состояние
- **RWMutex**: когда операции чтения значительно преобладают над операциями записи, и есть много горутин, читающих данные одновременно

## 3. Как устроен мьютекс внутри? Какие состояния он может иметь?

```go
type Mutex struct {
    state int32  // Состояние мьютекса: незаблокирован, заблокирован, ожидают, проснулся
    sema  uint32 // Семафор для блокировки горутин
}
```

Состояние мьютекса закодировано в поле `state` как битовое поле:

- **Бит 0**: Заблокирован (1) или не заблокирован (0)
- **Бит 1**: Пробуждение (woken)
- **Бит 2-31**: Счетчик ожидающих горутин

Мьютекс в Go использует комбинированный подход:

1. **Быстрый путь**: Попытка получить блокировку без ожидания (атомарные операции)
2. **Спинлок**: Кратковременное активное ожидание блокировки
3. **Блокировка через семафор**: Полная блокировка горутины при долгом ожидании

## 4. Для чего предназначен `WaitGroup` и как им правильно пользоваться?

`WaitGroup` используется для ожидания завершения группы горутин. Он имеет счетчик, который может увеличиваться и уменьшаться.

Правильное использование:

```go
func processItems(items []int) {
    var wg sync.WaitGroup
    
    for _, item := range items {
        wg.Add(1)  // Увеличение счетчика перед запуском горутины
        go func(i int) {
            defer wg.Done()  // Уменьшение счетчика при завершении (эквивалентно wg.Add(-1))
            process(i)
        }(item)
    }
    
    wg.Wait()  // Блокировка до обнуления счетчика
}
```

Ключевые правила:

1. `Add()` должен вызываться до запуска горутин
2. `Done()` должен вызываться в каждой горутине независимо от результата (обычно через defer)
3. `Wait()` блокирует вызывающую горутину до тех пор, пока счетчик не станет равен 0
4. Нельзя копировать `WaitGroup` после первого использования
5. `Wait()` должен вызываться после всех вызовов `Add()`

## 5. Что такое `sync.Once` и для каких задач он подходит?

`sync.Once` гарантирует, что функция будет выполнена только один раз, даже если `Do()` вызывается из разных горутин.

```go
var (
    instance *Singleton
    once     sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })
    return instance
}
```

`sync.Once` подходит для:

1. Инициализации синглтонов
2. Отложенной инициализации ресурсоемких объектов
3. Регистрации, которая должна произойти только один раз
4. Создание соединений, которые должны быть инициализированы лишь однократно
5. Настройка, которая должна выполниться ровно один раз

## 6. Как работает условная переменная `sync.Cond`? Какие методы она предоставляет?

`sync.Cond` позволяет горутинам ожидать изменения какого-либо условия и получать сигналы об этих изменениях.

Методы:

- `NewCond(l Locker)` — создает новую условную переменную с заданным Locker
- `Wait()` — атомарно освобождает связанную блокировку и блокирует вызывающую горутину, затем снова захватывает блокировку при пробуждении
- `Signal()` — пробуждает одну из ожидающих горутин
- `Broadcast()` — пробуждает все ожидающие горутины

Пример использования (очередь):

```go
type Queue struct {
    cond *sync.Cond
    data []interface{}
}

func NewQueue() *Queue {
    return &Queue{
        cond: sync.NewCond(&sync.Mutex{}),
    }
}

func (q *Queue) Push(item interface{}) {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    q.data = append(q.data, item)
    q.cond.Signal() // Уведомить одного ожидающего
}

func (q *Queue) Pop() interface{} {
    q.cond.L.Lock()
    defer q.cond.L.Unlock()
    
    for len(q.data) == 0 {
        q.cond.Wait() // Ждем, пока очередь не станет непустой
    }
    
    item := q.data[0]
    q.data = q.data[1:]
    return item
}
```

## 7. Для чего используется `sync.Pool` и как она взаимодействует со сборщиком мусора?

`sync.Pool` предоставляет кэш временных объектов, которые могут быть сохранены и извлечены позже, избегая частых аллокаций и сборки мусора.

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func ProcessRequest() {
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        bufferPool.Put(buf)
    }()
    
    // Использовать buf...
}
```

Взаимодействие со сборщиком мусора:

1. Объекты в пуле могут быть удалены в любой момент сборки мусора без уведомления
2. Все объекты в пуле очищаются при каждом запуске сборщика мусора
3. `sync.Pool` имеет "victim cache" для хранения объектов между циклами GC
4. Пул не подходит для долгосрочного хранения объектов или для объектов, требующих явного освобождения ресурсов

## 8. Какие атомарные операции предоставляет пакет `sync/atomic`?

Пакет `sync/atomic` предоставляет низкоуровневые атомарные операции памяти:

1. **Load** — атомарное чтение (например, `atomic.LoadInt64(&counter)`)
2. **Store** — атомарная запись (например, `atomic.StoreInt64(&counter, 42)`)
3. **Add** — атомарное добавление (например, `atomic.AddInt64(&counter, 1)`)
4. **Swap** — атомарный обмен значениями (например, `atomic.SwapInt64(&counter, 100)`)
5. **CompareAndSwap (CAS)** — атомарная условная замена (например, `atomic.CompareAndSwapInt64(&counter, old, new)`)

Эти операции доступны для типов: int32, int64, uint32, uint64, uintptr, unsafe.Pointer.

Также есть тип `atomic.Value` для атомарных операций с произвольными типами:

```go
var config atomic.Value
config.Store(loadConfig())
// Позже, в другой горутине:
currentConfig := config.Load().(Config)
```

## 9. В чем преимущества и недостатки использования `sync.Map` по сравнению с обычной картой с мьютексом?

**Преимущества `sync.Map`**:

1. Оптимизирована для случаев, когда операции чтения значительно преобладают над записью
2. Не требует явного использования мьютексов
3. Более эффективна при высоком уровне параллелизма
4. Использует два внутренних хранилища: read-only и dirty, что снижает контенцию
5. Атомарные операции для чтений, не требующие блокировок

**Недостатки `sync.Map`**:

1. Более высокие накладные расходы при интенсивных записях
2. Отсутствует встроенная поддержка len() для получения размера
3. Требует приведения типов при получении значений
4. Отсутствует поддержка range для перебора элементов
5. Может быть менее эффективна для простых случаев с низким уровнем параллелизма

**Когда использовать:**

- `sync.Map`: когда карта доступна из множества горутин и преобладают операции чтения
- Обычную карту с мьютексом: когда операции записи частые или при низком параллелизме

## 10. Какие проблемы могут возникнуть при неправильном использовании примитивов синхронизации?

1. **Deadlock (взаимная блокировка)**: Горутины циклически ожидают ресурсы, удерживаемые друг другом.

   ```go
   func deadlockExample() {
       var mu1, mu2 sync.Mutex
       go func() {
           mu1.Lock()
           time.Sleep(1 * time.Millisecond)
           mu2.Lock() // Потенциальный deadlock
           // ...
       }()
       go func() {
           mu2.Lock()
           time.Sleep(1 * time.Millisecond)
           mu1.Lock() // Потенциальный deadlock
           // ...
       }()
   }
   ```

2. **Race Condition (состояние гонки)**: Одновременный доступ к данным без синхронизации.

   ```go
   func raceExample() {
       counter := 0
       for i := 0; i < 1000; i++ {
           go func() {
               counter++ // Гонка данных
           }()
       }
   }
   ```

3. **Livelock**: Горутины активны, но не продвигаются в работе, постоянно реагируя на действия друг друга.

4. **Starvation (голодание)**: Некоторые горутины не получают доступ к ресурсам из-за других, более привилегированных горутин.

5. **Использование неинициализированных примитивов**: Например, вызов Wait() на nil WaitGroup.

6. **Забытые блокировки**: Захват мьютекса без последующего освобождения.

7. **Неправильное использование копий**: Копирование мьютексов или других примитивов синхронизации после их инициализации или использования.

8. **Memory leaks**: Утечки памяти из-за удерживания ссылок на объекты в примитивах синхронизации.

9. **Excessive locking**: Излишние блокировки, снижающие параллельность кода.

10. **Ошибки в условиях**: Неправильные условия в sync.Cond.Wait() или select, приводящие к вечному ожиданию.
