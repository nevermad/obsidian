Конструкция defer: 1. Что такое `defer` в Go и для чего он используется?	`defer` в Go — это механизм отложенного выполнения функций, гарантирующий их вызов при выходе из текущей функции независимо от причины завершения (нормальное выполнение, возврат из функции, паника). `defer` используется для освобождения ресурсов (закрытие файлов, соединений), очистки состояния (разблокировка мьютексов), финальной обработки данных и создания механизмов восстановления после паник.
Конструкция defer: 2. В каком порядке выполняются отложенные функции, если их несколько в одной функции?	Отложенные функции выполняются в порядке LIFO (Last In, First Out) — последний отложенный вызов выполняется первым. Это аналогично стеку, где последний добавленный элемент извлекается первым:

<pre><code>func example() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// Вывод: 3, 2, 1</code></pre>
Конструкция defer: 3. В какой момент вычисляются аргументы отложенной функции?	Аргументы функции, переданной в `defer`, вычисляются в момент объявления `defer`, а не в момент выполнения отложенной функции:

<pre><code>func example() {
    i := 1
    defer fmt.Println(i) // i = 1 в момент объявления
    i++
}
// Вывод: 1, а не 2</code></pre>
Конструкция defer: 4. Как использовать `defer` с замыканиями для захвата изменяющихся значений?	Для захвата изменяющихся значений нужно использовать анонимную функцию (замыкание), которая будет захватывать переменные по ссылке:

<pre><code>func example() {
    i := 1
    defer func() { fmt.Println(i) }() // Захватывает i по ссылке
    i++
}
// Вывод: 2</code></pre>

Можно также передать изменяющуюся переменную в замыкание как параметр, если нужно зафиксировать текущее значение:

<pre><code>func example() {
    i := 1
    defer func(val int) { fmt.Println(val) }(i) // Передаем копию i как параметр
    i++
}
// Вывод: 1</code></pre>
Конструкция defer: 5. Как отложенные функции могут влиять на возвращаемые значения функции?	Отложенные функции могут изменять именованные возвращаемые значения функции:

<pre><code>func example() (result int) {
    defer func() { result *= 2 }()
    return 5
}
// Результат: 10</code></pre>

Порядок выполнения при возврате:

1. Значение возврата присваивается результату (result = 5)
2. Выполняются отложенные функции (result *= 2)
3. Происходит возврат из функции (return result)
Конструкция defer: 6. Как менялась реализация `defer` в разных версиях Go?	Эволюция реализации `defer` в Go:

1. **До Go 1.12**: Все `defer` размещались в куче, высокие накладные расходы (~35ns)
2. **Go 1.13**: Введено стековое размещение для простых случаев (~6ns)
3. **Go 1.14**: Введено открытое замещение (open-coded defer), когда компилятор встраивает код отложенных вызовов прямо в функцию (~2ns)
4. **Go 1.18+**: Дальнейшие оптимизации (0.3-2ns в оптимальных случаях)

Каждая новая версия значительно снижала накладные расходы на использование `defer`.
Конструкция defer: 7. Какие существуют стратегии размещения структур `defer` в памяти?	В Go используются три стратегии размещения `defer`:

1. **Размещение в куче (heap-allocated defer)** — классический подход, когда структура `_defer` размещается в куче. Используется для сложных случаев, имеет наибольшие накладные расходы.

2. **Стековое размещение (stack-allocated defer)** — быстрый путь, когда `defer` размещается на стеке функции. Применяется для случаев, когда количество `defer` известно на этапе компиляции.

3. **Открытое замещение (open-coded defer)** — компилятор встраивает код отложенных вызовов непосредственно в функцию, без создания структур `_defer`. Самый быстрый вариант, но с ограничениями по сложности кода.
Конструкция defer: 8. Опишите внутреннее устройство `defer` в Go runtime?	Внутренне `defer` реализован через структуру `_defer` в runtime:

<pre><code>type _defer struct {
    siz     int32       // размер аргументов функции
    started bool        // флаг, указывающий, начался ли вызов
    sp      uintptr     // указатель стека в момент создания defer
    pc      uintptr     // программный счетчик возврата
    fn      *funcval    // функция, которая будет вызвана
    _panic  *_panic     // связанная паника
    link    *_defer     // связывание в стек defer'ов текущей горутины
    // другие поля...
}</code></pre>

Каждая горутина имеет свой стек отложенных вызовов, реализованный как односвязный список структур `_defer`. При выходе из функции runtime проходит по этому списку и вызывает все отложенные функции в порядке LIFO.
Конструкция defer: 9. Какие паттерны использования `defer` вы знаете?	Основные паттерны использования `defer`:

1. **Закрытие ресурсов**:

   ```go
   f, err := os.Open(filename)
   if err != nil {
       return err
   }
   defer f.Close() // Гарантированное закрытие файла
   ```

2. **Разблокировка мьютексов**:

   ```go
   mu.Lock()
   defer mu.Unlock() // Гарантированная разблокировка
   ```

3. **Измерение времени выполнения**:

   ```go
   defer func(start time.Time) {
       log.Printf("Execution took: %v", time.Since(start))
   }(time.Now())
   ```

4. **Восстановление после паники**:

   ```go
   defer func() {
       if r := recover(); r != nil {
           log.Printf("Recovered from panic: %v", r)
       }
   }()
   ```

5. **Трассировка функций**:

   ```go
   func foo() {
       defer fmt.Println("exiting foo")
       fmt.Println("in foo")
   }
   ```
Конструкция defer: 10. Какие ограничения и подводные камни есть при использовании `defer`?	Основные ограничения и подводные камни `defer`:

1. **Раннее вычисление аргументов** — аргументы функции фиксируются на момент объявления `defer`
2. **Накладные расходы** — несмотря на оптимизации, в критичном к производительности коде могут иметь значение
3. **Не выполняется при `os.Exit()`** — немедленно завершает программу без выполнения отложенных функций
4. **Влияние на читаемость** — слишком много `defer` может усложнить понимание потока выполнения
5. **Взаимодействие с panic/recover** — сложная логика при вложенных паниках и восстановлениях
6. **Порядок выполнения** — обратный порядок может быть неинтуитивным
7. **Неявное изменение возвращаемых значений** — может затруднить отладку
Конструкция defer: 11. Почему размещение `defer` в цикле может быть проблематичным?	Размещение `defer` в цикле проблематично, потому что отложенные функции будут выполнены только после выхода из содержащей их функции, а не после каждой итерации цикла. Это приводит к:

1. **Накоплению большого количества отложенных вызовов** — если цикл выполняется много раз, это приведёт к утечке памяти или исчерпанию ресурсов
2. **Позднему освобождению ресурсов** — ресурсы (файлы, соединения) будут удерживаться до конца функции
3. **Неожиданному порядку выполнения** — первый созданный ресурс будет освобожден последним

Правильное решение:

<pre><code>for i := 0; i < n; i++ {
    func() {
        resource := acquireResource()
        defer resource.Release() // Освобождается сразу после итерации
        // Использование ресурса
    }()
}</code></pre>
Конструкция defer: 12. Как влияет использование `defer` на производительность программы?	Влияние `defer` на производительность:

1. **Накладные расходы на создание структуры `_defer`** — в ранних версиях Go существенные, в новых — минимальные
2. **Дополнительные вызовы функций** — каждый `defer` это дополнительный вызов
3. **Размещение в памяти** — может вызывать дополнительные аллокации (особенно для heap-allocated defer)
4. **Современные оптимизации** — значительно снижают эти издержки:
   - В Go 1.14+ с открытым замещением накладные расходы составляют около 2ns
   - В большинстве случаев издержки неощутимы для обычных программ
   - В высоконагруженных участках кода (hot paths) всё еще может иметь значение

Рекомендации:

- Не отказываться от `defer` в обычном коде ради производительности
- В критических по производительности участках рассмотреть альтернативы
- В большинстве случаев безопасность и чистота кода важнее небольшого выигрыша в производительности
Ошибки в Go. Паники. Работа с recover: 1. Какова философия обработки ошибок в Go? Чем она отличается от других языков?	Философия обработки ошибок в Go существенно отличается от многих других языков:

1. **Ошибки как значения**: В Go ошибки — это обычные значения, а не исключения. Они передаются, возвращаются и обрабатываются явно.
2. **Явная обработка**: Разработчик должен явно проверять и обрабатывать ошибки в месте их возникновения.
3. **Многоуровневая система**:
   - Обычные ошибки (через интерфейс `error`) для ожидаемых проблем
   - Паники (`panic`) только для неисправимых ситуаций
   - Восстановление (`recover`) для контролируемой обработки паник

В отличие от Java/C#/Python, где широко используются исключения для обработки ошибок, Go продвигает явный стиль, который делает поток выполнения более предсказуемым, улучшает читаемость и снижает вероятность необработанных ошибок.
Ошибки в Go. Паники. Работа с recover: 2. Что такое интерфейс `error` и какие методы он требует?	Интерфейс `error` в Go — это встроенный интерфейс из пакета `builtin`, который требует только одного метода:

<pre><code>type error interface {
    Error() string
}</code></pre>

Этот минималистичный интерфейс требует только метода `Error()`, который должен возвращать строковое описание ошибки. Любой тип, реализующий этот метод, может использоваться как ошибка в Go.

Простота интерфейса `error` позволяет легко создавать пользовательские типы ошибок, добавляя дополнительный контекст и функциональность.
Ошибки в Go. Паники. Работа с recover: 3. Какие способы создания ошибок предоставляет стандартная библиотека?	Стандартная библиотека Go предоставляет несколько способов создания ошибок:

1. **errors.New**: Создает простую ошибку с текстовым сообщением

   ```go
   import "errors"
   err := errors.New("something went wrong")
   ```

2. **fmt.Errorf**: Создает форматированную ошибку

   ```go
   import "fmt"
   err := fmt.Errorf("failed to process %s: %v", filename, reason)
   ```

3. **С Go 1.13 - fmt.Errorf с %w**: Создает ошибку, оборачивающую другую ошибку

   ```go
   originalErr := errors.New("database query failed")
   wrappedErr := fmt.Errorf("failed to fetch user data: %w", originalErr)
   ```

4. **Пользовательские типы ошибок**: Любой тип, реализующий интерфейс `error`

   ```go
   type MyError struct {
       Code    int
       Message string
   }
   
   func (e *MyError) Error() string {
       return fmt.Sprintf("error %d: %s", e.Code, e.Message)
   }
   ```
Ошибки в Go. Паники. Работа с recover: 4. Что такое "sentinel errors" и когда их стоит использовать?	"Sentinel errors" (сторожевые ошибки) — это предопределённые значения ошибок, которые можно сравнивать напрямую:

<pre><code>var (
    ErrNotFound   = errors.New("not found")
    ErrPermission = errors.New("permission denied")
)

func FindItem() error {
    return ErrNotFound
}

// Использование
if err := FindItem(); err == ErrNotFound {
    // Обработка конкретной ошибки
}</code></pre>

Их стоит использовать:

- Для обозначения ожидаемых состояний ошибок без дополнительного контекста
- Когда нужно просто проверить тип ошибки, без извлечения дополнительной информации
- Для стандартных ошибок в API (например, `io.EOF`, `sql.ErrNoRows`)
- В простых пакетах с ограниченным набором возможных ошибок

Недостатки:

- Не содержат дополнительного контекста
- Не могут быть обогащены деталями конкретной ситуации
- Сравнение работает только при использовании одного и того же экземпляра ошибки
Ошибки в Go. Паники. Работа с recover: 5. Что такое паника (panic) и когда она возникает?	Паника (panic) — это механизм аварийного завершения горутины при критических ошибках, сопровождающийся разворачиванием стека и выполнением отложенных функций.

Паника может возникнуть в следующих случаях:

1. **Явный вызов `panic()`**:

   ```go
   func doSomething() {
       if critical_error {
           panic("критическая ошибка")
       }
   }
   ```

2. **Runtime-ошибки**:
   - Доступ по nil-указателю
   - Выход за границы массива/слайса
   - Ошибки при приведении типов
   - Отправка в закрытый канал
   - Одновременная запись в map из разных горутин

3. **Аппаратные исключения**:
   - Деление на ноль
   - Переполнение стека
   - Нарушение защиты памяти

Паники следует использовать только для:

- Истинно неисправимых ситуаций
- Программистских ошибок, которые должны быть исправлены
- Ситуаций, когда продолжение работы бессмысленно или опасно
Ошибки в Go. Паники. Работа с recover: 6. Опишите процесс раскрутки стека при возникновении паники	Когда возникает паника, Go runtime выполняет следующий процесс:

1. **Создание структуры паники**: Создается новая структура `_panic` и помещается в стек паник горутины

   ```go
   type _panic struct {
       argp      unsafe.Pointer // указатель на аргументы
       arg       interface{}    // аргумент паники
       link      *_panic        // связь с предыдущей паникой
       recovered bool           // была ли паника обработана
       aborted   bool           // была ли обработка прервана
       // другие поля...
   }
   ```

2. **Раскрутка стека (unwinding)**:
   - Runtime начинает подниматься по стеку вызовов
   - На каждом уровне вызова проверяется наличие отложенных функций
   - Отложенные функции выполняются в порядке LIFO (последний вошел — первый вышел)
   - Если одна из отложенных функций вызывает `recover()` и обрабатывает панику, процесс раскрутки останавливается
   - Если паника не обработана, раскрутка продолжается до корня стека горутины

3. **Завершение горутины**:
   - Если паника не обработана в горутине, горутина завершается
   - Если это основная горутина (main), программа завершается с выводом сообщения об ошибке и стек-трейсом
   - Паника в одной горутине не влияет на другие горутины
Ошибки в Go. Паники. Работа с recover: 7. Как работает механизм восстановления (recover) и какие у него ограничения?	Механизм восстановления (recover) позволяет перехватить и обработать панику, предотвратив аварийное завершение горутины.

**Принцип работы**:

1. Функция `recover()` проверяет, находится ли текущая горутина в состоянии паники
2. Если да, она помечает текущую панику как обработанную (`recovered = true`)
3. Возвращает аргумент паники (значение, переданное в `panic()`)
4. Если нет паники, возвращает `nil`

**Ограничения**:

1. **Работает только в отложенных функциях**: `recover()` эффективен только внутри вызова `defer`
2. **Работает только в той же горутине**: Невозможно перехватить панику из другой горутины
3. **Должен быть вызван напрямую**: Вызов через другую функцию не работает (за исключением встроенных функций)
4. **Не перехватывает фатальные ошибки**: Некоторые ошибки (например, stack overflow) не могут быть перехвачены
5. **Восстанавливает только текущую панику**: При вложенных паниках может потребоваться цепочка recover-вызовов
Ошибки в Go. Паники. Работа с recover: 8. Почему `recover()` работает только внутри отложенных функций?	`recover()` работает только внутри отложенных функций по нескольким причинам:

1. **Механизм работы паники**: Паника запускает процесс раскрутки стека, при котором выполняются только отложенные функции. Обычный код после вызова `panic()` не выполняется.

2. **Предсказуемость поведения**: Ограничение использования `recover()` отложенными функциями делает поведение более предсказуемым и понятным.

3. **Гарантия выполнения**: Отложенные функции гарантированно выполняются при раскрутке стека, обеспечивая надежный механизм для восстановления.

4. **Дизайн языка**: Это сознательное решение разработчиков Go для обеспечения ясного и единообразного механизма обработки паник.

5. **Структура runtime**: Внутренне `recover()` взаимодействует со структурами `_panic` в стеке горутины, что возможно только в контексте раскрутки стека при выполнении отложенных функций.
Ошибки в Go. Паники. Работа с recover: 9. Как взаимодействуют цепочки паник и восстановлений?	При работе с вложенными паниками и восстановлениями возникают сложные взаимодействия:

1. **Паника во время восстановления**:
   Если во время выполнения `recover()` возникает новая паника, она имеет приоритет над текущей обрабатываемой паникой:

   ```go
   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("Recovered:", r)
               panic("новая паника") // Эта паника перекрывает предыдущую
           }
       }()
       panic("исходная паника")
   }
   // Вывод:
   // Recovered: исходная паника
   // panic: новая паника
   // [стек-трейс]
   ```

2. **Цепочки восстановлений**:
   Можно создать цепочку восстановлений на разных уровнях стека:

   ```go
   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("main recovered:", r)
           }
       }()
       
       f()
       
       fmt.Println("В main после f()")
   }
   
   func f() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("f recovered:", r)
               panic("новая паника из f")
           }
       }()
       
       panic("паника из g")
   }
   // Вывод:
   // f recovered: паника из g
   // main recovered: новая паника из f
   // В main после f()
   ```

3. **Вложенные defer/recover**:
   При наличии вложенных `defer` с `recover()` они выполняются в порядке LIFO:

   ```go
   func main() {
       defer func() {
           defer func() {
               if r := recover(); r != nil {
                   fmt.Println("Inner recover:", r)
               }
           }()
           
           if r := recover(); r != nil {
               fmt.Println("Outer recover:", r)
               panic("re-panic")
           }
       }()
       
       panic("original panic")
   }
   // Вывод:
   // Outer recover: original panic
   // Inner recover: re-panic
   ```
Ошибки в Go. Паники. Работа с recover: 10. Когда следует использовать возврат ошибок, а когда — механизм паники?	**Использовать возврат ошибок для**:

- Ожидаемых проблемных ситуаций (файл не найден, сеть недоступна)
- Случаев, когда вызывающий код должен решить, как поступить
- Проблем с внешними ресурсами и данными
- Ошибок проверки валидации
- Всех публичных API и библиотечных функций
- Когда важна производительность (ошибки дешевле паник)

**Использовать панику для**:

- Неисправимых ситуаций (invariant нарушен, критическая ошибка инициализации)
- Программистских ошибок, которые должны быть исправлены (не для ошибок пользователя)
- Когда восстановление нормальной работы невозможно
- Внутренних ошибок, которые всегда указывают на дефект в программе
- Инициализации пакетов, когда ошибка фатальна для всего приложения

**Гибридный подход**:

- Использовать панику внутри пакета для критических ошибок
- Восстанавливать паники на границах пакета и преобразовывать их в обычные ошибки
Ошибки в Go. Паники. Работа с recover: 11. Какие преимущества и недостатки у паники по сравнению с обычными ошибками с точки зрения производительности?	**Обычные ошибки (преимущества)**:

- Минимальные накладные расходы (простая передача интерфейса)
- Не требуют сбора стек-трейса
- Не выполняют раскрутку стека
- Предсказуемый поток выполнения
- Оптимизированы для частого возникновения

**Обычные ошибки (недостатки)**:

- Требуют явного возврата и проверки на каждом уровне
- Могут привести к увеличению кода за счет обработки
- Могут усложнить сигнатуры функций

**Паники (преимущества)**:

- Автоматическое распространение вверх по стеку
- Не нужно явно возвращать на каждом уровне
- Упрощают код в некоторых случаях
- Гарантируют выполнение очистки (defer)

**Паники (недостатки)**:

- Значительные накладные расходы:
  - Сбор стек-трейса (~10-100 мкс)
  - Раскрутка стека
  - Выполнение всех отложенных функций
- Оптимизированы для редкого использования
- Непредсказуемый поток выполнения
- Сложнее для отладки
- Могут усложнить модель ошибок

С точки зрения чистой производительности, обычные ошибки значительно эффективнее при частом возникновении проблем.
Ошибки в Go. Паники. Работа с recover: 12. Влияет ли паника в одной горутине на другие горутины?	Нет, паника в одной горутине не влияет напрямую на другие горутины. Каждая горутина имеет свой стек выполнения и собственный стек паник. Когда в горутине происходит паника:

1. Выполняется раскрутка стека только этой горутины
2. Если паника не обработана, завершается только эта горутина
3. Другие горутины продолжают выполнение независимо
4. Основная программа продолжает работу, если паника не произошла в главной горутине

Пример:

<pre><code>func main() {
    go func() {
        defer fmt.Println("Горутина завершается")
        panic("Паника в горутине")
    }()
    
    time.Sleep(time.Second)
    fmt.Println("Основная горутина продолжает работу")
}
// Вывод:
// Горутина завершается
// Основная горутина продолжает работу</code></pre>

Однако иногда паника в одной горутине может косвенно повлиять на другие, если:

- Горутины совместно используют ресурсы, которые не освобождаются из-за паники
- Используется механизм координации, который нарушается из-за неожиданного завершения горутины
- Это основная горутина программы, в которой возникла необработанная паника (в этом случае завершается вся программа)
Ошибки в Go. Паники. Работа с recover: 13. Какие лучшие практики существуют для обработки ошибок в Go?	1. **Всегда проверяйте ошибки**:

   ```go
   result, err := someFunction()
   if err != nil {
       // Обработка ошибки обязательна
   }
   ```

2. **Возвращайте ошибки с контекстом**:

   ```go
   if err := doSomething(); err != nil {
       return fmt.Errorf("при выполнении операции: %w", err)
   }
   ```

3. **Используйте явные проверки типов ошибок**:

   ```go
   var notFoundErr *NotFoundError
   if errors.As(err, &notFoundErr) {
       // Обработка конкретного типа ошибки
   }
   ```

4. **Обрабатывайте ошибки на соответствующем уровне**:
   - Низкоуровневые компоненты: возвращают ошибки наверх
   - Средний уровень: добавляют контекст и логируют
   - Верхний уровень: принимают решения о действиях

5. **Документируйте возвращаемые ошибки**:

   ```go
   // Open opens a file and returns an error if the file does not exist.
   func Open(name string) (*File, error) {
       // ...
   }
   ```

6. **Используйте пользовательские типы ошибок для контекста**:

   ```go
   type QueryError struct {
       Query string
       Err   error
   }
   ```

7. **Добавляйте восстановление в горутины**:

   ```go
   go func() {
       defer func() {
           if r := recover(); r != nil {
               log.Printf("recovered: %v", r)
           }
       }()
       // ...
   }()
   ```

8. **Не игнорируйте ошибки в defer**:

   ```go
   defer func() {
       err := file.Close()
       if err != nil {
           log.Printf("failed to close file: %v", err)
       }
   }()
   ```

9. **Возвращайте специальные ошибки для особых случаев**:

   ```go
   var ErrNotFound = errors.New("not found")
   ```

10. **Используйте errors.Is/As вместо прямого сравнения**:

    ```go
    if errors.Is(err, io.EOF) {
        // handle EOF
    }
    ```
Ошибки в Go. Паники. Работа с recover: 14. Как реализовать превращение паник в обычные ошибки на границах API?	Для преобразования паник в обычные ошибки на границах API используется паттерн "защитной границы" (error boundary):

<pre><code>// Экспортируемая функция API
func SafeOperation(input string) (result string, err error) {
    // Устанавливаем defer-обработчик для перехвата паники
    defer func() {
        if r := recover(); r != nil {
            // Получаем стек вызовов для отладки
            stack := debug.Stack()
            
            // Преобразуем панику в ошибку
            switch x := r.(type) {
            case string:
                err = fmt.Errorf("panic occurred: %s\n%s", x, stack)
            case error:
                err = fmt.Errorf("panic occurred: %w\n%s", x, stack)
            default:
                err = fmt.Errorf("panic occurred: %v\n%s", r, stack)
            }
            
            // Можно добавить логирование
            log.Printf("recovered from panic in SafeOperation: %v\n%s", r, stack)
            
            // Обнуляем результат в случае паники
            result = ""
        }
    }()
    
    // Выполняем потенциально опасную операцию
    result = riskyOperation(input)
    return result, nil
}

// Внутренняя функция, которая может вызвать панику
func riskyOperation(input string) string {
    if input == "" {
        panic("empty input not allowed")
    }
    // ...
    return processedInput
}</code></pre>

Этот паттерн обеспечивает:

1. Перехват любых паник, возникающих внутри функции
2. Преобразование паники в обычную ошибку с сохранением информации
3. Гарантию, что API никогда не "уронит" вызывающий код паникой
4. Сохранение стек-трейса для отладки
5. Возможность логирования инцидентов

Обычно этот паттерн применяется в:

- Публичных API библиотек
- Обработчиках HTTP-запросов
- Функциях, выполняющихся в отдельных горутинах
- Границах модулей внутри приложения
Пакет errors. fmt.Errorf, errors.Is  errors.As: 1. Какие изменения в работе с ошибками появились в Go 1.13?	В Go 1.13 были добавлены:

- Поддержка оборачивания ошибок через `%w` в `fmt.Errorf`
- Функции `errors.Is` для сравнения ошибок в цепочке оборачивающих ошибок
- Функции `errors.As` для безопасного приведения типов в цепочке ошибок
- Интерфейс `Unwrap()` для развёртывания оборачивающих ошибок
Пакет errors. fmt.Errorf, errors.Is  errors.As: 2. В чем разница между `errors.New` и `fmt.Errorf`?	- `errors.New` создаёт простую ошибку с фиксированным строковым сообщением
- `fmt.Errorf` создаёт ошибку с форматированным сообщением, поддерживает все форматирующие глаголы пакета fmt
- `fmt.Errorf` с `%w` позволяет оборачивать другие ошибки, сохраняя оригинальную ошибку в цепочке
Пакет errors. fmt.Errorf, errors.Is  errors.As: 3. Как работает оборачивание ошибок с помощью `%w` в `fmt.Errorf`?	При использовании `%w` в `fmt.Errorf`:

- Создаётся специальная структура, реализующая метод `Unwrap()`
- Оригинальная ошибка сохраняется внутри этой структуры
- Метод `Error()` возвращает форматированное сообщение
- Метод `Unwrap()` возвращает оригинальную ошибку

Пример:

<pre><code>originalErr := errors.New("database query failed")
wrappedErr := fmt.Errorf("failed to fetch user data: %w", originalErr)</code></pre>
Пакет errors. fmt.Errorf, errors.Is  errors.As: 4. Опишите внутреннее устройство оборачивания ошибок. Что такое метод `Unwrap()`?	Оборачивание ошибок основано на интерфейсе `Unwrap`:

- Любая ошибка, реализующая метод `Unwrap() error`, считается оборачивающей
- Метод `Unwrap()` возвращает оригинальную ошибку или nil
- При использовании `%w` в `fmt.Errorf` создаётся структура типа `wrapError`
- Функции `errors.Is` и `errors.As` рекурсивно вызывают `Unwrap()` для всей цепочки
Пакет errors. fmt.Errorf, errors.Is  errors.As: 5. Для чего нужна функция `errors.Is` и как она работает внутренне?	Функция `errors.Is(err, target error) bool`:

- Проверяет, содержится ли `target` ошибка где-либо в цепочке оборачивающих ошибок
- Сначала проверяет прямое равенство (`err == target`)
- Затем проверяет наличие метода `Is(error) bool` у ошибки и вызывает его
- Рекурсивно обходит всю цепочку ошибок через `Unwrap()` и повторяет сравнение
- Позволяет безопасно сравнивать ошибки, даже если они обёрнуты в несколько слоёв
Пакет errors. fmt.Errorf, errors.Is  errors.As: 6. Для чего нужна функция `errors.As` и как она работает внутренне?	Функция `errors.As(err error, target interface{}) bool`:

- Пытается привести ошибку (или любую ошибку в цепочке) к указанному типу
- Принимает указатель на переменную целевого типа в `target`
- Проверяет, соответствует ли тип ошибки (или любой в цепочке) целевому типу
- При совпадении типов записывает значение ошибки в `target`
- Проверяет наличие метода `As(interface{}) bool` у ошибки и вызывает его
- Рекурсивно обходит цепочку через `Unwrap()`
- Позволяет безопасно извлекать информацию из ошибок определённого типа
Пакет errors. fmt.Errorf, errors.Is  errors.As: 7. Как можно настроить поведение `errors.Is` и `errors.As` для пользовательских типов ошибок?	Для настройки поведения `errors.Is`:

- Реализовать метод `Is(target error) bool` для пользовательского типа ошибки
- В методе определить собственную логику сравнения с целевой ошибкой

Для настройки поведения `errors.As`:

- Реализовать метод `As(target interface{}) bool` для пользовательского типа
- В методе определить собственную логику приведения типа и заполнения target

Пример для `Is`:

<pre><code>func (e *QueryError) Is(target error) bool {
    t, ok := target.(*QueryError)
    if !ok {
        return false
    }
    return (e.Query == t.Query || t.Query == "") && errors.Is(e.Err, t.Err)
}</code></pre>
Пакет errors. fmt.Errorf, errors.Is  errors.As: 8. Какие преимущества даёт оборачивание ошибок с сохранением контекста?	Преимущества:

- Сохранение контекстной информации по мере прохождения через слои приложения
- Добавление деталей об операции, вызвавшей ошибку
- Возможность проверки на оригинальные ошибки через `errors.Is`
- Возможность извлечения оригинальных ошибок через `errors.As`
- Создание более информативных сообщений об ошибках для пользователей
- Улучшение отладки благодаря более полной информации об ошибке
Пакет errors. fmt.Errorf, errors.Is  errors.As: 9. Как создавать иерархии ошибок с помощью механизма оборачивания?	Для создания иерархий ошибок:

1. Определить базовые типы ошибок для разных доменов приложения
2. Каждый тип должен реализовывать метод `Unwrap() error`
3. Использовать оборачивание для добавления контекста
4. Вложенные ошибки можно проверять с помощью `errors.Is/As`

Пример:

<pre><code>// Базовая ошибка домена
type DomainError struct {
    Domain string
    Err    error
}

func (e *DomainError) Error() string {
    return fmt.Sprintf("%s domain error: %v", e.Domain, e.Err)
}

func (e *DomainError) Unwrap() error {
    return e.Err
}

// Производная ошибка
type ValidationError struct {
    Field string
    Err   error
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %v", e.Field, e.Err)
}

func (e *ValidationError) Unwrap() error {
    return e.Err
}</code></pre>
Пакет errors. fmt.Errorf, errors.Is  errors.As: 10. В чем разница между сентинельными ошибками и типами ошибок? Когда что лучше использовать?	**Сентинельные ошибки**:

- Предопределённые значения ошибок (`var ErrNotFound = errors.New("not found")`)
- Подходят для ошибок без дополнительного контекста
- Используются для общих состояний (EOF, Not Found)
- Удобны, когда проверка по значению достаточна
- Проще в использовании

**Типы ошибок**:

- Пользовательские структуры, реализующие интерфейс `error`
- Подходят для ошибок с дополнительными данными/контекстом
- Позволяют извлекать информацию об ошибке через приведение типа
- Лучше для создания иерархий ошибок
- Более гибкие, но требуют больше кода
Пакет errors. fmt.Errorf, errors.Is  errors.As: 11. Какие лучшие практики существуют при использовании пакета `errors`?	Лучшие практики:

1. Добавлять контекст при оборачивании ошибок
2. Структурировать ошибки по доменам приложения
3. Создавать фабричные методы для часто используемых ошибок
4. Обрабатывать все варианты ошибок с использованием `errors.Is/As`
5. Избегать избыточного оборачивания без добавления контекста
6. Предпочитать типы ошибок для ошибок с дополнительными данными
7. Использовать сентинельные ошибки для общих состояний
8. Делать сообщения об ошибках информативными и понятными
Пакет errors. fmt.Errorf, errors.Is  errors.As: 12. В чем преимущество `errors.Is/As` по сравнению с прямым сравнением ошибок и проверкой типа?	Преимущества:

- Работают через всю цепочку оборачивающих ошибок, а не только на верхнем уровне
- Поддерживают кастомную логику сравнения через методы `Is` и `As`
- Более устойчивы к изменениям в структуре ошибок
- Безопасны с точки зрения nil-значений
- Соответствуют идиоматическому стилю Go 1.13+
- Унифицируют обработку ошибок в кодовой базе
Пакет errors. fmt.Errorf, errors.Is  errors.As: 13. Какие ограничения и проблемы производительности могут возникать при работе с цепочками ошибок?	Ограничения и проблемы:

- Создание форматированных сообщений требует дополнительных ресурсов
- Рекурсивные вызовы `Unwrap()` в `errors.Is/As` могут быть затратны для длинных цепочек
- Каждое оборачивание требует выделения памяти для новой структуры ошибки
- Сложные цепочки ошибок могут затруднять отладку
- Глубокие вложенности могут быть трудны для понимания
- Сложно предсказать поведение `errors.Is/As` с кастомными реализациями
- Увеличение размера стека из-за множественных оборачиваний
Пакет errors. fmt.Errorf, errors.Is  errors.As: 14. Как решить проблему отсутствия стектрейса в стандартных ошибках Go?	Решения проблемы отсутствия стектрейса:

1. Использовать сторонние библиотеки:
   - `github.com/pkg/errors` - добавляет стектрейс при создании ошибок
   - `github.com/go-errors/errors` - предоставляет полный стектрейс

2. Создать собственную обёртку для ошибок со стектрейсом:

   ```go
   type ErrorWithStack struct {
       Err error
       Stack []byte
   }
   
   func NewErrorWithStack(err error) *ErrorWithStack {
       stack := make([]byte, 4096)
       n := runtime.Stack(stack, false)
       return &ErrorWithStack{Err: err, Stack: stack[:n]}
   }
   ```

3. Использовать паники с последующим восстановлением в контролируемых точках:
   - Паники содержат стектрейс, который можно зафиксировать
   - Паники затратны, поэтому подходят только для критических ошибок

4. Логировать ошибки с явным вызовом `runtime.Stack()` при их возникновении
