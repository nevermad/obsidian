# Ошибки в Go. Паники. Работа с recover - ответы на вопросы

## 1. Какова философия обработки ошибок в Go? Чем она отличается от других языков?

Философия обработки ошибок в Go существенно отличается от многих других языков:

1. **Ошибки как значения**: В Go ошибки — это обычные значения, а не исключения. Они передаются, возвращаются и обрабатываются явно.
2. **Явная обработка**: Разработчик должен явно проверять и обрабатывать ошибки в месте их возникновения.
3. **Многоуровневая система**:
   - Обычные ошибки (через интерфейс `error`) для ожидаемых проблем
   - Паники (`panic`) только для неисправимых ситуаций
   - Восстановление (`recover`) для контролируемой обработки паник

В отличие от Java/C#/Python, где широко используются исключения для обработки ошибок, Go продвигает явный стиль, который делает поток выполнения более предсказуемым, улучшает читаемость и снижает вероятность необработанных ошибок.

## 2. Что такое интерфейс `error` и какие методы он требует?

Интерфейс `error` в Go — это встроенный интерфейс из пакета `builtin`, который требует только одного метода:

```go
type error interface {
    Error() string
}
```

Этот минималистичный интерфейс требует только метода `Error()`, который должен возвращать строковое описание ошибки. Любой тип, реализующий этот метод, может использоваться как ошибка в Go.

Простота интерфейса `error` позволяет легко создавать пользовательские типы ошибок, добавляя дополнительный контекст и функциональность.

## 3. Какие способы создания ошибок предоставляет стандартная библиотека?

Стандартная библиотека Go предоставляет несколько способов создания ошибок:

1. **errors.New**: Создает простую ошибку с текстовым сообщением

   ```go
   import "errors"
   err := errors.New("something went wrong")
   ```

2. **fmt.Errorf**: Создает форматированную ошибку

   ```go
   import "fmt"
   err := fmt.Errorf("failed to process %s: %v", filename, reason)
   ```

3. **С Go 1.13 - fmt.Errorf с %w**: Создает ошибку, оборачивающую другую ошибку

   ```go
   originalErr := errors.New("database query failed")
   wrappedErr := fmt.Errorf("failed to fetch user data: %w", originalErr)
   ```

4. **Пользовательские типы ошибок**: Любой тип, реализующий интерфейс `error`

   ```go
   type MyError struct {
       Code    int
       Message string
   }
   
   func (e *MyError) Error() string {
       return fmt.Sprintf("error %d: %s", e.Code, e.Message)
   }
   ```

## 4. Что такое "sentinel errors" и когда их стоит использовать?

"Sentinel errors" (сторожевые ошибки) — это предопределённые значения ошибок, которые можно сравнивать напрямую:

```go
var (
    ErrNotFound   = errors.New("not found")
    ErrPermission = errors.New("permission denied")
)

func FindItem() error {
    return ErrNotFound
}

// Использование
if err := FindItem(); err == ErrNotFound {
    // Обработка конкретной ошибки
}
```

Их стоит использовать:

- Для обозначения ожидаемых состояний ошибок без дополнительного контекста
- Когда нужно просто проверить тип ошибки, без извлечения дополнительной информации
- Для стандартных ошибок в API (например, `io.EOF`, `sql.ErrNoRows`)
- В простых пакетах с ограниченным набором возможных ошибок

Недостатки:

- Не содержат дополнительного контекста
- Не могут быть обогащены деталями конкретной ситуации
- Сравнение работает только при использовании одного и того же экземпляра ошибки

## 5. Что такое паника (panic) и когда она возникает?

Паника (panic) — это механизм аварийного завершения горутины при критических ошибках, сопровождающийся разворачиванием стека и выполнением отложенных функций.

Паника может возникнуть в следующих случаях:

1. **Явный вызов `panic()`**:

   ```go
   func doSomething() {
       if critical_error {
           panic("критическая ошибка")
       }
   }
   ```

2. **Runtime-ошибки**:
   - Доступ по nil-указателю
   - Выход за границы массива/слайса
   - Ошибки при приведении типов
   - Отправка в закрытый канал
   - Одновременная запись в map из разных горутин

3. **Аппаратные исключения**:
   - Деление на ноль
   - Переполнение стека
   - Нарушение защиты памяти

Паники следует использовать только для:

- Истинно неисправимых ситуаций
- Программистских ошибок, которые должны быть исправлены
- Ситуаций, когда продолжение работы бессмысленно или опасно

## 6. Опишите процесс раскрутки стека при возникновении паники

Когда возникает паника, Go runtime выполняет следующий процесс:

1. **Создание структуры паники**: Создается новая структура `_panic` и помещается в стек паник горутины

   ```go
   type _panic struct {
       argp      unsafe.Pointer // указатель на аргументы
       arg       interface{}    // аргумент паники
       link      *_panic        // связь с предыдущей паникой
       recovered bool           // была ли паника обработана
       aborted   bool           // была ли обработка прервана
       // другие поля...
   }
   ```

2. **Раскрутка стека (unwinding)**:
   - Runtime начинает подниматься по стеку вызовов
   - На каждом уровне вызова проверяется наличие отложенных функций
   - Отложенные функции выполняются в порядке LIFO (последний вошел — первый вышел)
   - Если одна из отложенных функций вызывает `recover()` и обрабатывает панику, процесс раскрутки останавливается
   - Если паника не обработана, раскрутка продолжается до корня стека горутины

3. **Завершение горутины**:
   - Если паника не обработана в горутине, горутина завершается
   - Если это основная горутина (main), программа завершается с выводом сообщения об ошибке и стек-трейсом
   - Паника в одной горутине не влияет на другие горутины

## 7. Как работает механизм восстановления (recover) и какие у него ограничения?

Механизм восстановления (recover) позволяет перехватить и обработать панику, предотвратив аварийное завершение горутины.

**Принцип работы**:

1. Функция `recover()` проверяет, находится ли текущая горутина в состоянии паники
2. Если да, она помечает текущую панику как обработанную (`recovered = true`)
3. Возвращает аргумент паники (значение, переданное в `panic()`)
4. Если нет паники, возвращает `nil`

**Ограничения**:

1. **Работает только в отложенных функциях**: `recover()` эффективен только внутри вызова `defer`
2. **Работает только в той же горутине**: Невозможно перехватить панику из другой горутины
3. **Должен быть вызван напрямую**: Вызов через другую функцию не работает (за исключением встроенных функций)
4. **Не перехватывает фатальные ошибки**: Некоторые ошибки (например, stack overflow) не могут быть перехвачены
5. **Восстанавливает только текущую панику**: При вложенных паниках может потребоваться цепочка recover-вызовов

## 8. Почему `recover()` работает только внутри отложенных функций?

`recover()` работает только внутри отложенных функций по нескольким причинам:

1. **Механизм работы паники**: Паника запускает процесс раскрутки стека, при котором выполняются только отложенные функции. Обычный код после вызова `panic()` не выполняется.

2. **Предсказуемость поведения**: Ограничение использования `recover()` отложенными функциями делает поведение более предсказуемым и понятным.

3. **Гарантия выполнения**: Отложенные функции гарантированно выполняются при раскрутке стека, обеспечивая надежный механизм для восстановления.

4. **Дизайн языка**: Это сознательное решение разработчиков Go для обеспечения ясного и единообразного механизма обработки паник.

5. **Структура runtime**: Внутренне `recover()` взаимодействует со структурами `_panic` в стеке горутины, что возможно только в контексте раскрутки стека при выполнении отложенных функций.

## 9. Как взаимодействуют цепочки паник и восстановлений?

При работе с вложенными паниками и восстановлениями возникают сложные взаимодействия:

1. **Паника во время восстановления**:
   Если во время выполнения `recover()` возникает новая паника, она имеет приоритет над текущей обрабатываемой паникой:

   ```go
   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("Recovered:", r)
               panic("новая паника") // Эта паника перекрывает предыдущую
           }
       }()
       panic("исходная паника")
   }
   // Вывод:
   // Recovered: исходная паника
   // panic: новая паника
   // [стек-трейс]
   ```

2. **Цепочки восстановлений**:
   Можно создать цепочку восстановлений на разных уровнях стека:

   ```go
   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("main recovered:", r)
           }
       }()
       
       f()
       
       fmt.Println("В main после f()")
   }
   
   func f() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("f recovered:", r)
               panic("новая паника из f")
           }
       }()
       
       panic("паника из g")
   }
   // Вывод:
   // f recovered: паника из g
   // main recovered: новая паника из f
   // В main после f()
   ```

3. **Вложенные defer/recover**:
   При наличии вложенных `defer` с `recover()` они выполняются в порядке LIFO:

   ```go
   func main() {
       defer func() {
           defer func() {
               if r := recover(); r != nil {
                   fmt.Println("Inner recover:", r)
               }
           }()
           
           if r := recover(); r != nil {
               fmt.Println("Outer recover:", r)
               panic("re-panic")
           }
       }()
       
       panic("original panic")
   }
   // Вывод:
   // Outer recover: original panic
   // Inner recover: re-panic
   ```

## 10. Когда следует использовать возврат ошибок, а когда — механизм паники?

**Использовать возврат ошибок для**:

- Ожидаемых проблемных ситуаций (файл не найден, сеть недоступна)
- Случаев, когда вызывающий код должен решить, как поступить
- Проблем с внешними ресурсами и данными
- Ошибок проверки валидации
- Всех публичных API и библиотечных функций
- Когда важна производительность (ошибки дешевле паник)

**Использовать панику для**:

- Неисправимых ситуаций (invariant нарушен, критическая ошибка инициализации)
- Программистских ошибок, которые должны быть исправлены (не для ошибок пользователя)
- Когда восстановление нормальной работы невозможно
- Внутренних ошибок, которые всегда указывают на дефект в программе
- Инициализации пакетов, когда ошибка фатальна для всего приложения

**Гибридный подход**:

- Использовать панику внутри пакета для критических ошибок
- Восстанавливать паники на границах пакета и преобразовывать их в обычные ошибки

## 11. Какие преимущества и недостатки у паники по сравнению с обычными ошибками с точки зрения производительности?

**Обычные ошибки (преимущества)**:

- Минимальные накладные расходы (простая передача интерфейса)
- Не требуют сбора стек-трейса
- Не выполняют раскрутку стека
- Предсказуемый поток выполнения
- Оптимизированы для частого возникновения

**Обычные ошибки (недостатки)**:

- Требуют явного возврата и проверки на каждом уровне
- Могут привести к увеличению кода за счет обработки
- Могут усложнить сигнатуры функций

**Паники (преимущества)**:

- Автоматическое распространение вверх по стеку
- Не нужно явно возвращать на каждом уровне
- Упрощают код в некоторых случаях
- Гарантируют выполнение очистки (defer)

**Паники (недостатки)**:

- Значительные накладные расходы:
  - Сбор стек-трейса (~10-100 мкс)
  - Раскрутка стека
  - Выполнение всех отложенных функций
- Оптимизированы для редкого использования
- Непредсказуемый поток выполнения
- Сложнее для отладки
- Могут усложнить модель ошибок

С точки зрения чистой производительности, обычные ошибки значительно эффективнее при частом возникновении проблем.

## 12. Влияет ли паника в одной горутине на другие горутины?

Нет, паника в одной горутине не влияет напрямую на другие горутины. Каждая горутина имеет свой стек выполнения и собственный стек паник. Когда в горутине происходит паника:

1. Выполняется раскрутка стека только этой горутины
2. Если паника не обработана, завершается только эта горутина
3. Другие горутины продолжают выполнение независимо
4. Основная программа продолжает работу, если паника не произошла в главной горутине

Пример:

```go
func main() {
    go func() {
        defer fmt.Println("Горутина завершается")
        panic("Паника в горутине")
    }()
    
    time.Sleep(time.Second)
    fmt.Println("Основная горутина продолжает работу")
}
// Вывод:
// Горутина завершается
// Основная горутина продолжает работу
```

Однако иногда паника в одной горутине может косвенно повлиять на другие, если:

- Горутины совместно используют ресурсы, которые не освобождаются из-за паники
- Используется механизм координации, который нарушается из-за неожиданного завершения горутины
- Это основная горутина программы, в которой возникла необработанная паника (в этом случае завершается вся программа)

## 13. Какие лучшие практики существуют для обработки ошибок в Go?

1. **Всегда проверяйте ошибки**:

   ```go
   result, err := someFunction()
   if err != nil {
       // Обработка ошибки обязательна
   }
   ```

2. **Возвращайте ошибки с контекстом**:

   ```go
   if err := doSomething(); err != nil {
       return fmt.Errorf("при выполнении операции: %w", err)
   }
   ```

3. **Используйте явные проверки типов ошибок**:

   ```go
   var notFoundErr *NotFoundError
   if errors.As(err, &notFoundErr) {
       // Обработка конкретного типа ошибки
   }
   ```

4. **Обрабатывайте ошибки на соответствующем уровне**:
   - Низкоуровневые компоненты: возвращают ошибки наверх
   - Средний уровень: добавляют контекст и логируют
   - Верхний уровень: принимают решения о действиях

5. **Документируйте возвращаемые ошибки**:

   ```go
   // Open opens a file and returns an error if the file does not exist.
   func Open(name string) (*File, error) {
       // ...
   }
   ```

6. **Используйте пользовательские типы ошибок для контекста**:

   ```go
   type QueryError struct {
       Query string
       Err   error
   }
   ```

7. **Добавляйте восстановление в горутины**:

   ```go
   go func() {
       defer func() {
           if r := recover(); r != nil {
               log.Printf("recovered: %v", r)
           }
       }()
       // ...
   }()
   ```

8. **Не игнорируйте ошибки в defer**:

   ```go
   defer func() {
       err := file.Close()
       if err != nil {
           log.Printf("failed to close file: %v", err)
       }
   }()
   ```

9. **Возвращайте специальные ошибки для особых случаев**:

   ```go
   var ErrNotFound = errors.New("not found")
   ```

10. **Используйте errors.Is/As вместо прямого сравнения**:

    ```go
    if errors.Is(err, io.EOF) {
        // handle EOF
    }
    ```

## 14. Как реализовать превращение паник в обычные ошибки на границах API?

Для преобразования паник в обычные ошибки на границах API используется паттерн "защитной границы" (error boundary):

```go
// Экспортируемая функция API
func SafeOperation(input string) (result string, err error) {
    // Устанавливаем defer-обработчик для перехвата паники
    defer func() {
        if r := recover(); r != nil {
            // Получаем стек вызовов для отладки
            stack := debug.Stack()
            
            // Преобразуем панику в ошибку
            switch x := r.(type) {
            case string:
                err = fmt.Errorf("panic occurred: %s\n%s", x, stack)
            case error:
                err = fmt.Errorf("panic occurred: %w\n%s", x, stack)
            default:
                err = fmt.Errorf("panic occurred: %v\n%s", r, stack)
            }
            
            // Можно добавить логирование
            log.Printf("recovered from panic in SafeOperation: %v\n%s", r, stack)
            
            // Обнуляем результат в случае паники
            result = ""
        }
    }()
    
    // Выполняем потенциально опасную операцию
    result = riskyOperation(input)
    return result, nil
}

// Внутренняя функция, которая может вызвать панику
func riskyOperation(input string) string {
    if input == "" {
        panic("empty input not allowed")
    }
    // ...
    return processedInput
}
```

Этот паттерн обеспечивает:

1. Перехват любых паник, возникающих внутри функции
2. Преобразование паники в обычную ошибку с сохранением информации
3. Гарантию, что API никогда не "уронит" вызывающий код паникой
4. Сохранение стек-трейса для отладки
5. Возможность логирования инцидентов

Обычно этот паттерн применяется в:

- Публичных API библиотек
- Обработчиках HTTP-запросов
- Функциях, выполняющихся в отдельных горутинах
- Границах модулей внутри приложения
