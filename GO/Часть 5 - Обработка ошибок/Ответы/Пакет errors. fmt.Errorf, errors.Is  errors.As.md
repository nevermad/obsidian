# Ответы на вопросы: Пакет errors. fmt.Errorf, errors.Is / errors.As

## 1. Какие изменения в работе с ошибками появились в Go 1.13?

В Go 1.13 были добавлены:

- Поддержка оборачивания ошибок через `%w` в `fmt.Errorf`
- Функции `errors.Is` для сравнения ошибок в цепочке оборачивающих ошибок
- Функции `errors.As` для безопасного приведения типов в цепочке ошибок
- Интерфейс `Unwrap()` для развёртывания оборачивающих ошибок

## 2. В чем разница между `errors.New` и `fmt.Errorf`?

- `errors.New` создаёт простую ошибку с фиксированным строковым сообщением
- `fmt.Errorf` создаёт ошибку с форматированным сообщением, поддерживает все форматирующие глаголы пакета fmt
- `fmt.Errorf` с `%w` позволяет оборачивать другие ошибки, сохраняя оригинальную ошибку в цепочке

## 3. Как работает оборачивание ошибок с помощью `%w` в `fmt.Errorf`?

При использовании `%w` в `fmt.Errorf`:

- Создаётся специальная структура, реализующая метод `Unwrap()`
- Оригинальная ошибка сохраняется внутри этой структуры
- Метод `Error()` возвращает форматированное сообщение
- Метод `Unwrap()` возвращает оригинальную ошибку

Пример:

```go
originalErr := errors.New("database query failed")
wrappedErr := fmt.Errorf("failed to fetch user data: %w", originalErr)
```

## 4. Опишите внутреннее устройство оборачивания ошибок. Что такое метод `Unwrap()`?

Оборачивание ошибок основано на интерфейсе `Unwrap`:

- Любая ошибка, реализующая метод `Unwrap() error`, считается оборачивающей
- Метод `Unwrap()` возвращает оригинальную ошибку или nil
- При использовании `%w` в `fmt.Errorf` создаётся структура типа `wrapError`
- Функции `errors.Is` и `errors.As` рекурсивно вызывают `Unwrap()` для всей цепочки

## 5. Для чего нужна функция `errors.Is` и как она работает внутренне?

Функция `errors.Is(err, target error) bool`:

- Проверяет, содержится ли `target` ошибка где-либо в цепочке оборачивающих ошибок
- Сначала проверяет прямое равенство (`err == target`)
- Затем проверяет наличие метода `Is(error) bool` у ошибки и вызывает его
- Рекурсивно обходит всю цепочку ошибок через `Unwrap()` и повторяет сравнение
- Позволяет безопасно сравнивать ошибки, даже если они обёрнуты в несколько слоёв

## 6. Для чего нужна функция `errors.As` и как она работает внутренне?

Функция `errors.As(err error, target interface{}) bool`:

- Пытается привести ошибку (или любую ошибку в цепочке) к указанному типу
- Принимает указатель на переменную целевого типа в `target`
- Проверяет, соответствует ли тип ошибки (или любой в цепочке) целевому типу
- При совпадении типов записывает значение ошибки в `target`
- Проверяет наличие метода `As(interface{}) bool` у ошибки и вызывает его
- Рекурсивно обходит цепочку через `Unwrap()`
- Позволяет безопасно извлекать информацию из ошибок определённого типа

## 7. Как можно настроить поведение `errors.Is` и `errors.As` для пользовательских типов ошибок?

Для настройки поведения `errors.Is`:

- Реализовать метод `Is(target error) bool` для пользовательского типа ошибки
- В методе определить собственную логику сравнения с целевой ошибкой

Для настройки поведения `errors.As`:

- Реализовать метод `As(target interface{}) bool` для пользовательского типа
- В методе определить собственную логику приведения типа и заполнения target

Пример для `Is`:

```go
func (e *QueryError) Is(target error) bool {
    t, ok := target.(*QueryError)
    if !ok {
        return false
    }
    return (e.Query == t.Query || t.Query == "") && errors.Is(e.Err, t.Err)
}
```

## 8. Какие преимущества даёт оборачивание ошибок с сохранением контекста?

Преимущества:

- Сохранение контекстной информации по мере прохождения через слои приложения
- Добавление деталей об операции, вызвавшей ошибку
- Возможность проверки на оригинальные ошибки через `errors.Is`
- Возможность извлечения оригинальных ошибок через `errors.As`
- Создание более информативных сообщений об ошибках для пользователей
- Улучшение отладки благодаря более полной информации об ошибке

## 9. Как создавать иерархии ошибок с помощью механизма оборачивания?

Для создания иерархий ошибок:

1. Определить базовые типы ошибок для разных доменов приложения
2. Каждый тип должен реализовывать метод `Unwrap() error`
3. Использовать оборачивание для добавления контекста
4. Вложенные ошибки можно проверять с помощью `errors.Is/As`

Пример:

```go
// Базовая ошибка домена
type DomainError struct {
    Domain string
    Err    error
}

func (e *DomainError) Error() string {
    return fmt.Sprintf("%s domain error: %v", e.Domain, e.Err)
}

func (e *DomainError) Unwrap() error {
    return e.Err
}

// Производная ошибка
type ValidationError struct {
    Field string
    Err   error
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field %s: %v", e.Field, e.Err)
}

func (e *ValidationError) Unwrap() error {
    return e.Err
}
```

## 10. В чем разница между сентинельными ошибками и типами ошибок? Когда что лучше использовать?

**Сентинельные ошибки**:

- Предопределённые значения ошибок (`var ErrNotFound = errors.New("not found")`)
- Подходят для ошибок без дополнительного контекста
- Используются для общих состояний (EOF, Not Found)
- Удобны, когда проверка по значению достаточна
- Проще в использовании

**Типы ошибок**:

- Пользовательские структуры, реализующие интерфейс `error`
- Подходят для ошибок с дополнительными данными/контекстом
- Позволяют извлекать информацию об ошибке через приведение типа
- Лучше для создания иерархий ошибок
- Более гибкие, но требуют больше кода

## 11. Какие лучшие практики существуют при использовании пакета `errors`?

Лучшие практики:

1. Добавлять контекст при оборачивании ошибок
2. Структурировать ошибки по доменам приложения
3. Создавать фабричные методы для часто используемых ошибок
4. Обрабатывать все варианты ошибок с использованием `errors.Is/As`
5. Избегать избыточного оборачивания без добавления контекста
6. Предпочитать типы ошибок для ошибок с дополнительными данными
7. Использовать сентинельные ошибки для общих состояний
8. Делать сообщения об ошибках информативными и понятными

## 12. В чем преимущество `errors.Is/As` по сравнению с прямым сравнением ошибок и проверкой типа?

Преимущества:

- Работают через всю цепочку оборачивающих ошибок, а не только на верхнем уровне
- Поддерживают кастомную логику сравнения через методы `Is` и `As`
- Более устойчивы к изменениям в структуре ошибок
- Безопасны с точки зрения nil-значений
- Соответствуют идиоматическому стилю Go 1.13+
- Унифицируют обработку ошибок в кодовой базе

## 13. Какие ограничения и проблемы производительности могут возникать при работе с цепочками ошибок?

Ограничения и проблемы:

- Создание форматированных сообщений требует дополнительных ресурсов
- Рекурсивные вызовы `Unwrap()` в `errors.Is/As` могут быть затратны для длинных цепочек
- Каждое оборачивание требует выделения памяти для новой структуры ошибки
- Сложные цепочки ошибок могут затруднять отладку
- Глубокие вложенности могут быть трудны для понимания
- Сложно предсказать поведение `errors.Is/As` с кастомными реализациями
- Увеличение размера стека из-за множественных оборачиваний

## 14. Как решить проблему отсутствия стектрейса в стандартных ошибках Go?

Решения проблемы отсутствия стектрейса:

1. Использовать сторонние библиотеки:
   - `github.com/pkg/errors` - добавляет стектрейс при создании ошибок
   - `github.com/go-errors/errors` - предоставляет полный стектрейс

2. Создать собственную обёртку для ошибок со стектрейсом:

   ```go
   type ErrorWithStack struct {
       Err error
       Stack []byte
   }
   
   func NewErrorWithStack(err error) *ErrorWithStack {
       stack := make([]byte, 4096)
       n := runtime.Stack(stack, false)
       return &ErrorWithStack{Err: err, Stack: stack[:n]}
   }
   ```

3. Использовать паники с последующим восстановлением в контролируемых точках:
   - Паники содержат стектрейс, который можно зафиксировать
   - Паники затратны, поэтому подходят только для критических ошибок

4. Логировать ошибки с явным вызовом `runtime.Stack()` при их возникновении
