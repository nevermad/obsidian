# Вопросы для подготовки к собеседованию: Часть 5 - Обработка ошибок

Этот список вопросов охватывает все темы из пятой части материалов и поможет подготовиться к собеседованию. Вопросы организованы по темам и расположены от базовых концепций к более сложным.

## Конструкция defer

1. Что такое `defer` в Go и для чего он используется?
2. В каком порядке выполняются отложенные функции, если их несколько в одной функции?
3. В какой момент вычисляются аргументы отложенной функции?
4. Как использовать `defer` с замыканиями для захвата изменяющихся значений?
5. Как отложенные функции могут влиять на возвращаемые значения функции?
6. Как менялась реализация `defer` в разных версиях Go?
7. Какие существуют стратегии размещения структур `defer` в памяти?
8. Опишите внутреннее устройство `defer` в Go runtime?
9. Какие паттерны использования `defer` вы знаете?
10. Какие ограничения и подводные камни есть при использовании `defer`?
11. Почему размещение `defer` в цикле может быть проблематичным?
12. Как влияет использование `defer` на производительность программы?

## Ошибки в Go. Паники. Работа с recover

1. Какова философия обработки ошибок в Go? Чем она отличается от других языков?
2. Что такое интерфейс `error` и какие методы он требует?
3. Какие способы создания ошибок предоставляет стандартная библиотека?
4. Что такое "sentinel errors" и когда их стоит использовать?
5. Что такое паника (panic) и когда она возникает?
6. Опишите процесс раскрутки стека при возникновении паники.
7. Как работает механизм восстановления (recover) и какие у него ограничения?
8. Почему `recover()` работает только внутри отложенных функций?
9. Как взаимодействуют цепочки паник и восстановлений?
10. Когда следует использовать возврат ошибок, а когда — механизм паники?
11. Какие преимущества и недостатки у паники по сравнению с обычными ошибками с точки зрения производительности?
12. Влияет ли паника в одной горутине на другие горутины?
13. Какие лучшие практики существуют для обработки ошибок в Go?
14. Как реализовать превращение паник в обычные ошибки на границах API?

## Пакет errors. fmt.Errorf, errors.Is / errors.As

1. Какие изменения в работе с ошибками появились в Go 1.13?
2. В чем разница между `errors.New` и `fmt.Errorf`?
3. Как работает оборачивание ошибок с помощью `%w` в `fmt.Errorf`?
4. Опишите внутреннее устройство оборачивания ошибок. Что такое метод `Unwrap()`?
5. Для чего нужна функция `errors.Is` и как она работает внутренне?
6. Для чего нужна функция `errors.As` и как она работает внутренне?
7. Как можно настроить поведение `errors.Is` и `errors.As` для пользовательских типов ошибок?
8. Какие преимущества даёт оборачивание ошибок с сохранением контекста?
9. Как создавать иерархии ошибок с помощью механизма оборачивания?
10. В чем разница между сентинельными ошибками и типами ошибок? Когда что лучше использовать?
11. Какие лучшие практики существуют при использовании пакета `errors`?
12. В чем преимущество `errors.Is/As` по сравнению с прямым сравнением ошибок и проверкой типа?
13. Какие ограничения и проблемы производительности могут возникать при работе с цепочками ошибок?
14. Как решить проблему отсутствия стектрейса в стандартных ошибках Go?

## Связанные заметки

- [[Конструкция defer]]
- [[Ошибки в Go. Паники. Работа с recover]]
- [[Пакет errors. fmt.Errorf, errors.Is / errors.As]]
