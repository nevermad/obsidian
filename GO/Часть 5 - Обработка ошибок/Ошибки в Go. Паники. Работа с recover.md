# Ошибки в Go. Паники. Работа с recover

## Краткий обзор

В Go реализована многоуровневая система обработки ошибок, базирующаяся на явном возврате ошибок как значений и включающая механизмы паники и восстановления для критических ситуаций. Ошибки в Go — это обычные значения, реализующие интерфейс `error`. Паника (`panic`) — это механизм аварийного завершения горутины при неустранимых ошибках, сопровождающийся раскруткой стека и выполнением отложенных функций. Восстановление (`recover`) — это механизм перехвата и обработки паник, позволяющий нормализовать выполнение программы. В Go принято использовать обычные ошибки для ожидаемых проблемных ситуаций, а панику и восстановление — только для действительно исключительных ситуаций, когда нормальное продолжение работы невозможно.

## Подробный разбор

### Философия обработки ошибок в Go

Go придерживается иной парадигмы обработки ошибок, чем многие другие современные языки:

1. **Ошибки как значения**: В Go ошибки — это просто значения, которые можно возвращать, передавать, сравнивать и т.д.
2. **Явная обработка**: Разработчик должен явно проверять и обрабатывать ошибки, а не полагаться на исключения
3. **Многоуровневая система**:
   - Обычные ошибки (возврат интерфейса `error`) для ожидаемых проблем
   - Паники (`panic`) для неисправимых ситуаций
   - Восстановление (`recover`) для контролируемой обработки паник

### Интерфейс error

Ошибки в Go представлены интерфейсом `error` из пакета `builtin`:

```go
type error interface {
    Error() string
}
```

Этот минималистичный интерфейс требует только метода `Error()`, возвращающего текстовое описание ошибки.

#### Создание ошибок

Стандартная библиотека предоставляет несколько способов создания ошибок:

1. **errors.New**: Создает простую ошибку с текстовым сообщением

   ```go
   import "errors"
   
   err := errors.New("something went wrong")
   ```

2. **fmt.Errorf**: Создает отформатированную ошибку

   ```go
   import "fmt"
   
   err := fmt.Errorf("failed to process %s: %v", filename, reason)
   ```

3. **Пользовательские типы ошибок**: Любой тип, реализующий интерфейс `error`

   ```go
   type MyError struct {
       Code    int
       Message string
   }
   
   func (e *MyError) Error() string {
       return fmt.Sprintf("error %d: %s", e.Code, e.Message)
   }
   ```

#### Паттерны обработки ошибок

В Go сложились определённые паттерны обработки ошибок:

1. **Sentinel errors**: Предопределённые значения ошибок для сравнения

   ```go
   var (
       ErrNotFound   = errors.New("not found")
       ErrPermission = errors.New("permission denied")
   )
   
   func FindItem() error {
       return ErrNotFound
   }
   
   // Использование
   if err := FindItem(); err == ErrNotFound {
       // Обработка конкретной ошибки
   }
   ```

2. **Error types**: Пользовательские типы ошибок для проверки через приведение типов

   ```go
   type NotFoundError struct {
       Item string
   }
   
   func (e *NotFoundError) Error() string {
       return fmt.Sprintf("%s not found", e.Item)
   }
   
   // Использование
   if err := FindItem(); err != nil {
       if nfErr, ok := err.(*NotFoundError); ok {
           // Теперь у нас есть доступ к полям ошибки
           fmt.Println("Не найден элемент:", nfErr.Item)
       }
   }
   ```

3. **Error wrapping**: Оборачивание ошибок для сохранения контекста

   ```go
   if err := doSomething(); err != nil {
       return fmt.Errorf("при выполнении операции: %w", err)
   }
   ```

### Механизм паники (panic)

Паника — это механизм аварийного завершения горутины при критических ошибках, сопровождающийся разворачиванием стека и выполнением отложенных функций.

#### Внутреннее устройство паники

Паника в Go реализована через специальные структуры данных в пакете runtime:

```go
// Упрощённая версия (в реальности сложнее)
type _panic struct {
    argp      unsafe.Pointer // указатель на аргументы
    arg       interface{}    // аргумент паники
    link      *_panic        // связь с предыдущей паникой
    recovered bool           // была ли паника обработана
    aborted   bool           // была ли обработка прервана
    // другие поля...
}
```

Каждая горутина имеет свой стек паник, организованный как связный список структур `_panic`.

#### Когда возникает паника

Паника может возникнуть в следующих случаях:

1. **Явный вызов `panic()`**:

   ```go
   func doSomething() {
       if critical_error {
           panic("критическая ошибка")
       }
   }
   ```

2. **Runtime-ошибки**:
   - Доступ по nil-указателю
   - Выход за границы массива/слайса
   - Ошибки при приведении типов
   - Отправка в закрытый канал
   - Одновременная запись в map из разных горутин

3. **Аппаратные исключения**:
   - Деление на ноль
   - Переполнение стека
   - Нарушение защиты памяти

#### Процесс раскрутки стека при панике

Когда возникает паника, Go runtime выполняет следующие действия:

1. Создаёт новую структуру `_panic` и помещает её в стек паник горутины
2. Начинает раскрутку стека (unwinding):
   - Поднимается по стеку вызовов
   - Выполняет все отложенные функции (`defer`) в порядке LIFO
   - Если паника не обработана, завершает горутину
3. Если это паника в main-горутине и она не обработана, программа завершается с выводом сообщения об ошибке и стек-трейса

```go
func main() {
    defer fmt.Println("defer в main")
    
    f()
    
    fmt.Println("эта строка не выполнится")
}

func f() {
    defer fmt.Println("defer в f")
    
    g()
    
    fmt.Println("эта строка не выполнится")
}

func g() {
    panic("паника в g")
}

// Вывод:
// defer в f
// defer в main
// panic: паника в g
// [стек-трейс]
```

### Механизм восстановления (recover)

Восстановление — это механизм перехвата и обработки паник, который позволяет предотвратить аварийное завершение горутины.

#### Внутреннее устройство recover

Функция `recover()` внутренне взаимодействует со структурами `_panic` горутины:

1. Проверяет, находится ли текущая горутина в состоянии паники
2. Если да, помечает текущую панику как обработанную (`recovered = true`)
3. Возвращает аргумент паники
4. Если нет, возвращает `nil`

#### Ограничения recover

`recover()` работает только в отложенных функциях и внутри той же горутины, где произошла паника:

```go
// НЕ СРАБОТАЕТ - recover не в defer
func bad() {
    if r := recover(); r != nil { /* никогда не выполнится */ }
    panic("паника")
}

// НЕ СРАБОТАЕТ - recover в другой горутине
func alsobad() {
    defer func() {
        go func() {
            if r := recover(); r != nil { /* никогда не выполнится */ }
        }()
    }()
    panic("паника")
}

// СРАБОТАЕТ - recover в defer в той же горутине
func good() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recovered:", r)
        }
    }()
    panic("паника")
}
```

#### Типичные паттерны использования recover

1. **Защита границ**:

   ```go
   func serveRequest(request Request) (response Response) {
       defer func() {
           if r := recover(); r != nil {
               // Логирование паники
               log.Printf("panic occurred: %v\n%s", r, debug.Stack())
               // Формирование ответа об ошибке
               response = ErrorResponse{Code: 500, Message: "Internal Server Error"}
           }
       }()
       
       // Обработка запроса может вызвать панику
       return processRequest(request)
   }
   ```

2. **Преобразование паники в ошибку**:

   ```go
   func riskyOperation() (err error) {
       defer func() {
           if r := recover(); r != nil {
               // Конвертация паники в ошибку
               err = fmt.Errorf("panic occurred: %v", r)
           }
       }()
       
       // Потенциально опасный код
       return nil
   }
   ```

3. **Восстановление в горутинах**:

   ```go
   func safeGoroutine(job func()) {
       go func() {
           defer func() {
               if r := recover(); r != nil {
                   log.Printf("goroutine panic: %v", r)
               }
           }()
           
           job()
       }()
   }
   ```

### Цепочки паник и восстановления

Интересные сценарии возникают при работе с вложенными паниками и recover:

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("main recovered:", r)
        }
    }()
    
    f()
    
    fmt.Println("В main после f()")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("f recovered:", r)
            // Новая паника после восстановления
            panic("новая паника из f")
        }
    }()
    
    g()
    
    fmt.Println("В f после g()")
}

func g() {
    panic("паника из g")
}

// Вывод:
// f recovered: паника из g
// main recovered: новая паника из f
// В main после f()
```

### Паника vs ошибки: когда что использовать

В Go существуют чёткие рекомендации по использованию паники и ошибок:

1. **Возвращайте ошибки как значения** для:
   - Ожидаемых проблемных ситуаций (файл не найден, сеть недоступна)
   - Обработка которых может привести к корректному продолжению работы
   - Когда вызывающий код должен иметь возможность решить, как поступить

2. **Используйте panic** только для:
   - Истинно неисправимых ситуаций (invariant нарушен, критическая ошибка инициализации)
   - Программистских ошибок, которые должны быть исправлены (не для ошибок пользователя)
   - В тех редких случаях, когда восстановление невозможно или бессмысленно

3. **Используйте recover** только для:
   - Предотвращения завершения всего процесса (например, в HTTP-сервере)
   - Корректной очистки ресурсов перед завершением
   - Преобразования паник в ошибки на границах пакетов

### Производительность и оптимизации

Обработка ошибок и паник в Go имеет свои особенности с точки зрения производительности:

1. **Возврат ошибок**:
   - Почти не имеет накладных расходов (простая передача интерфейса)
   - Может потребовать дополнительных проверок в коде
   - Не вызывает сборку стек-трейса или другие сложные операции

2. **Паники**:
   - Имеют значительные накладные расходы при возникновении:
     - Сбор стек-трейса
     - Раскрутка стека
     - Выполнение отложенных функций
   - Оптимизированы для редкого использования, а не для частого возникновения

3. **Recover**:
   - Имеет минимальные накладные расходы, если паника не возникает
   - При обработке паники сохраняет большую часть затрат на её возникновение

### Особенности и ограничения

#### 1. Паники в разных горутинах

Паника в одной горутине не влияет на другие горутины и не может быть перехвачена в другой горутине:

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in main:", r) // Никогда не выполнится
        }
    }()
    
    go func() {
        panic("panicInGoroutine") // Паника завершит только эту горутину
    }()
    
    time.Sleep(1 * time.Second)
    fmt.Println("Main goroutine continues")
}
```

#### 2. Паники при деинициализации

Паники в функциях `init()` и в глобальных переменных непосредственно завершают программу, их нельзя перехватить:

```go
var _ = func() interface{} {
    panic("initialization panic") // Завершает программу немедленно
    return nil
}()
```

#### 3. Вложенные паники и recover

При возникновении новой паники во время обработки предыдущей, новая паника имеет приоритет:

```go
func main() {
    defer func() {
        defer func() {
            panic("panic 3") // Эта паника завершит программу
        }()
        
        panic("panic 2") // Эта паника будет перехвачена
    }()
    
    panic("panic 1") // Эта паника будет перехвачена
}
```

### Лучшие практики

1. **Всегда проверяйте ошибки**:

   ```go
   result, err := someFunction()
   if err != nil {
       // Обработка ошибки обязательна
   }
   ```

2. **Возвращайте ошибки с контекстом**:

   ```go
   if err := doSomething(); err != nil {
       return fmt.Errorf("failed to do something: %w", err)
   }
   ```

3. **Документируйте возвращаемые ошибки**:

   ```go
   // Open opens a file and returns the file descriptor.
   // It returns an error if the file does not exist or cannot be accessed.
   func Open(name string) (*File, error) {
       // ...
   }
   ```

4. **Используйте паники только для действительно исключительных ситуаций**

5. **Всегда помещайте recover в defer**

6. **Добавляйте логирование в recover для отладки**:

   ```go
   defer func() {
       if r := recover(); r != nil {
           log.Printf("recovered from panic: %v\n%s", r, debug.Stack())
           // Дальнейшая обработка...
       }
   }()
   ```

## Связи с другими темами

- [[Конструкция defer]]
- [[Пакет errors. fmt.Errorf, errors.Is / errors.As]]
- [[Горутины. Внутреннее устройство горутин]]
- [[Go Runtime. Составляющие части Go Runtime]]

## Источники

1. [Go Documentation: Defer, Panic, and Recover](https://go.dev/blog/defer-panic-and-recover)
2. [Go Language Specification: Run-time panics](https://golang.org/ref/spec#Run_time_panics)
3. [Go Error Handling and Go 2 Draft Designs](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md)
4. [Go's Runtime Source Code: panic implementation](https://github.com/golang/go/blob/master/src/runtime/panic.go)
5. [Go Blog: Error Handling and Go](https://blog.golang.org/error-handling-and-go)
6. [Go Internals: Error Handling in Go](https://medium.com/golangspec/error-handling-in-go-f0125de052f0)
7. [Practical Go: Real World Advice for Writing Maintainable Go Programs](https://dave.cheney.net/practical-go/presentations/qcon-china.html)
8. [Go 101: Panic and Recover](https://go101.org/article/panic-and-recover-more.html)
9. [Subtle Go: How Panic and Recover Work](https://yourbasic.org/golang/recover-from-panic/)
