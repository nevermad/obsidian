# Вопросы для подготовки к собеседованию: Часть 1 - Устройство памяти и базовые типы данных

Этот список вопросов охватывает все темы из первой части материалов и поможет подготовиться к собеседованию. Вопросы организованы по темам и расположены от базовых концепций к более сложным.

## Базовые типы данных

1. Какие базовые типы данных существуют в Go?
2. Чем отличаются int и int64 в Go? В каких случаях стоит использовать каждый из них?
3. Как работают числа с плавающей точкой в Go? Какие особенности и потенциальные проблемы нужно учитывать?
4. Какие ограничения имеют различные числовые типы в Go?
5. Что такое rune в Go и в каких случаях используется?
6. Как реализованы строки в Go? Какая у них внутренняя структура?
7. Почему строки в Go иммутабельны? Какие последствия это имеет?
8. Как работает сравнение чисел с плавающей точкой в Go? Какие есть нюансы?
9. Что такое битовые операции и для чего они используются в Go?
10. Какие есть методы оптимизации работы с константами в Go?

## Zero-Value

1. Что такое Zero-Value в Go и зачем это нужно?
2. Какие Zero-Value имеют различные типы в Go?
3. Какие преимущества даёт концепция Zero-Value в Go?
4. Как реализована безопасность типов через Zero-Value?
5. Чем отличается Zero-Value от nil?
6. Как работает Zero-Value для пользовательских типов?
7. Какие паттерны проектирования связаны с концепцией Zero-Value?
8. Почему в Go нет указателей, указывающих на произвольную область памяти?
9. Как Zero-Value помогает в обработке ошибок?
10. Какие проблемы безопасности решает механизм Zero-Value?

## Указатели

1. Что такое указатели в Go и чем они отличаются от указателей в C/C++?
2. Как создать указатель на переменную в Go?
3. Что делают операторы `&` и `*` в Go?
4. Почему в Go нет арифметики указателей?
5. Какие проблемы безопасности решает отсутствие арифметики указателей?
6. Что произойдет при разыменовании nil-указателя в Go?
7. В каких случаях стоит использовать указатели вместо значений?
8. Какие типы в Go по умолчанию передаются по указателю?
9. Как работают указатели с функциями и методами?
10. Что такое экранирование указателей (pointer escaping) и как это связано с выделением памяти?

## Структуры и методы

1. Как определяются и используются структуры в Go?
2. В чем разница между value receiver и pointer receiver в методах?
3. Когда следует использовать методы с pointer receiver, а когда с value receiver?
4. Как работает встраивание (embedding) структур в Go?
5. Что такое продвижение полей и методов при встраивании?
6. Какие ограничения есть у структур в Go?
7. Как можно контролировать видимость полей структуры?
8. Как работает сравнение структур в Go?
9. Что такое именованные структуры и анонимные структуры?
10. Как использовать теги структур и для чего они нужны?

## Пустой интерфейс и пустая структура

1. Что такое пустой интерфейс в Go и каковы его применения?
2. Какая внутренняя структура у пустого интерфейса?
3. Как работает type assertion с пустым интерфейсом?
4. Какие недостатки есть у пустого интерфейса?
5. Что такое пустая структура `struct{}` и когда её стоит использовать?
6. Сколько памяти занимает пустая структура?
7. Каковы типичные применения пустой структуры?
8. Как используется пустая структура в каналах для сигнализации?
9. Как пустая структура применяется для реализации множеств?
10. В чем разница между `interface{}` и `any` в Go?

## Пакет builtin. Операции new и make

1. Что делает функция `new()` в Go и каков её возвращаемый тип?
2. Что делает функция `make()` и для каких типов она предназначена?
3. В чем разница между `new()` и `make()`?
4. Почему нельзя использовать `make()` для пользовательских типов?
5. Какие параметры можно передать в `make()` при создании слайса, карты и канала?
6. Как внутренне устроены объекты, созданные с помощью `make()`?
7. Какие преимущества дает предварительное выделение памяти через `make()`?
8. Что такое niladic function и какие niladic функции есть в Go?
9. Как оптимизировать использование `make()` для слайсов?
10. Какие операции доступны над объектами, созданными с помощью `new()` и `make()`?

## Выравнивание структур

1. Что такое выравнивание структур в Go и почему оно важно?
2. Какие правила выравнивания полей структуры применяются в Go?
3. Как определить размер структуры и смещение её полей?
4. Какие стратегии можно использовать для оптимизации размера структур?
5. Как повлиять на выравнивание полей структуры для экономии памяти?
6. Что такое padding и когда компилятор его добавляет?
7. Как группировка полей по размеру влияет на размер структуры?
8. Какие инструменты существуют для анализа выравнивания структур?
9. В чем разница между struct alignment и memory alignment?
10. Как выравнивание структур влияет на производительность?

## Кэш-линии

1. Что такое кэш-линии и почему они важны для производительности?
2. Какой типичный размер кэш-линии в современных процессорах?
3. Что такое false sharing и как его избежать в многопоточном коде?
4. Как организовать структуры данных с учетом кэш-линий?
5. Какие паттерны доступа к памяти обеспечивают наилучшую производительность?
6. Что эффективнее с точки зрения кэша: структура массивов (SoA) или массив структур (AoS)?
7. Как можно измерить и профилировать кэш-промахи в Go-программах?
8. Какие техники padding используются для выравнивания по кэш-линиям?
9. Как кэш-линии влияют на параллельные вычисления в Go?
10. Какие алгоритмы и структуры данных считаются кэш-осведомленными (cache-aware)?

## Куча и стек. Escape Analysis

1. Чем отличается аллокация памяти на стеке от аллокации в куче?
2. Что такое Escape Analysis в Go и как он работает?
3. Какие характеристики имеет стек горутины в Go?
4. В каких случаях переменная "убегает" (escapes) в кучу?
5. Как можно проверить, где размещается переменная: на стеке или в куче?
6. Какие оптимизации выполняет компилятор Go при размещении переменных?
7. Почему размещение на стеке обычно эффективнее, чем в куче?
8. Какие ограничения имеет стековая аллокация?
9. Как работает сборщик мусора в Go на высоком уровне?
10. Какие флаги компилятора позволяют анализировать Escape Analysis?
11. Что такое инлайнинг функций и как он влияет на Escape Analysis?
12. В каких случаях лучше намеренно использовать указатели, а в каких - значения?
13. Как устроен стек горутины и как он растет?
14. Что такое sync.Pool и как этот механизм помогает уменьшить нагрузку на сборщик мусора?
15. Какие типичные ошибки приводят к нежелательным аллокациям в куче?

## Дополнительные продвинутые вопросы

[[Ответы на дополнительные вопросы]]

1. Как работа с памятью в Go отличается от C++ и Java?
2. Какие виды оптимизаций компилятора связаны с размещением данных в памяти?
3. Как можно контролировать работу сборщика мусора в Go?
4. Какие есть техники для написания кода без аллокаций (zero allocation)?
5. Как работает пакет unsafe и когда его следует использовать?
6. Какие проблемы параллельного доступа к памяти существуют и как их решать?
7. Как различные модели памяти процессора влияют на многопоточный код в Go?
8. Каков жизненный цикл объекта в Go от создания до удаления сборщиком мусора?
9. Какие хитрости и оптимизации есть в рантайме Go для работы с памятью?
10. Как эффективно организовать многомерные структуры данных с учетом локальности кэша?

## Связанные заметки

- [[Базовые типы данных]]
- [[Указатели]]
- [[Zero-Value]]
- [[Структуры. Pointer receiver. Value receiver]]
- [[Пустой интерфейс и пустая структура]]
- [[Пакет builtin. Операции new и make]]
- [[Выравнивание структур]]
- [[Кэш-линии]]
- [[Куча и стек. Escape Analysis]]
