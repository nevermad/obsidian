# Ответы на вопросы: Структуры и методы

## 1. Как определяются и используются структуры в Go?

Структуры в Go определяются с помощью ключевого слова `type` и `struct`:

```go
type Person struct {
    Name string
    Age  int
}
```

Использование структур включает:
- **Создание**: `p := Person{"Alice", 30}` или `p := Person{Name: "Alice", Age: 30}`
- **Доступ к полям**: `p.Name`, `p.Age`
- **Изменение полей**: `p.Age = 31`
- **Вложение структур**: `type Employee struct { Person; Salary int }`
- **Анонимные поля**: `type Circle struct { Point; Radius float64 }`
- **Указатели на структуры**: `p := &Person{"Bob", 25}; fmt.Println(p.Name)` (автоматическое разыменование)
- **Теги полей**: `json:"name,omitempty"` для метаданных, используемых через рефлексию
- **Методы**: определение функций, связанных со структурой

Структуры в Go — это основной механизм для определения пользовательских типов данных и инкапсуляции связанного состояния и поведения.

## 2. В чем разница между value receiver и pointer receiver в методах?

**Value Receiver** (`func (v Type) Method()`):
- Получает копию значения
- Не может изменять оригинальное значение
- Безопасен для конкурентного использования
- Эффективен для маленьких структур
- Может вызываться для значений и указателей
- Если тип реализует интерфейс с value receiver, и значения, и указатели удовлетворяют интерфейсу

**Pointer Receiver** (`func (v *Type) Method()`):
- Получает указатель на оригинальное значение
- Может изменять оригинальное значение
- Требует синхронизации при конкурентном доступе
- Эффективен для больших структур (избегает копирования)
- Может вызываться для указателей и адресуемых значений
- Если тип реализует интерфейс с pointer receiver, только указатели удовлетворяют интерфейсу

## 3. Когда следует использовать методы с pointer receiver, а когда с value receiver?

**Используйте Pointer Receiver, когда**:
- Метод должен изменять состояние получателя
- Структура большая и копирование неэффективно
- Все другие методы типа используют pointer receiver (согласованность)
- Тип содержит поля, которые нельзя копировать (мьютексы, файловые дескрипторы)
- Тип реализует интерфейс, требующий pointer receiver
- Нужно избежать копирования при каждом вызове метода

**Используйте Value Receiver, когда**:
- Метод не изменяет состояние (чистые функции)
- Тип — маленькая структура или базовый тип (int, string)
- Тип должен быть неизменяемым или иметь семантику значения
- Нужна безопасность при конкурентном доступе без синхронизации
- Все другие методы типа используют value receiver (согласованность)
- Тип — интерфейс (методы интерфейсов всегда имеют value receiver)

## 4. Как работает встраивание (embedding) структур в Go?

Встраивание структур в Go — это механизм композиции, позволяющий включать одну структуру в другую без явного имени поля:

```go
type Person struct {
    Name string
    Age  int
}

type Employee struct {
    Person       // встроенная структура
    Salary int
}
```

Ключевые аспекты встраивания:
- **Продвижение полей**: поля встроенной структуры доступны напрямую (`e.Name` вместо `e.Person.Name`)
- **Продвижение методов**: методы встроенной структуры становятся методами внешней
- **Переопределение**: внешняя структура может определить методы с тем же именем, что и у встроенной
- **Разрешение конфликтов**: при конфликте имен используется явное обращение (`e.Person.Name`)
- **Множественное встраивание**: структура может встраивать несколько типов
- **Встраивание интерфейсов**: структура может встраивать интерфейсы, что требует реализации их методов
- **Встраивание указателей**: можно встраивать указатель на тип (`*Person`)

Встраивание — это не наследование, а композиция с автоматическим делегированием.

## 5. Что такое продвижение полей и методов при встраивании?

Продвижение (promotion) — это механизм, при котором поля и методы встроенной структуры становятся доступными напрямую через внешнюю структуру:

**Продвижение полей**:
- Поля встроенной структуры доступны как поля внешней структуры
- При обращении `outer.field` Go сначала ищет `field` в `outer`, затем в каждой встроенной структуре
- Порядок поиска определяется порядком объявления встроенных типов
- При конфликте имен требуется явное обращение (`outer.embedded.field`)

**Продвижение методов**:
- Методы встроенной структуры становятся методами внешней структуры
- Тип receiver'а сохраняется (value/pointer)
- Методы встроенного указателя продвигаются, только если внешняя структура содержит встроенный указатель
- Продвинутые методы могут быть переопределены в внешней структуре
- Продвинутые методы могут вызывать другие методы той же встроенной структуры

Продвижение обеспечивает механизм повторного использования кода без наследования.

## 6. Какие ограничения есть у структур в Go?

Ограничения структур в Go:
- **Нет наследования**: только композиция через встраивание
- **Нет перегрузки методов**: каждый метод должен иметь уникальное имя
- **Нет конструкторов**: используются функции-фабрики или методы инициализации
- **Нет деструкторов**: используется defer или финализаторы (не рекомендуется)
- **Нет приватных полей внутри структуры**: приватность определяется на уровне пакета
- **Нет виртуальных методов**: полиморфизм реализуется через интерфейсы
- **Нет обобщенных структур** (до Go 1.18): использовались интерфейсы или кодогенерация
- **Нет автоматической сериализации**: требуются теги и явная реализация
- **Ограничения на сравнимость**: структуры с несравнимыми полями (слайсы, карты) не сравнимы
- **Нет атрибутов или аннотаций**: используются теги структур
- **Нет встроенной поддержки иммутабельности**: требуется дисциплина программирования

## 7. Как можно контролировать видимость полей структуры?

Видимость полей структуры в Go контролируется через именование:

- **Экспортируемые поля** (публичные): начинаются с заглавной буквы
  ```go
  type Person struct {
      Name string  // доступно из других пакетов
  }
  ```

- **Неэкспортируемые поля** (приватные): начинаются со строчной буквы
  ```go
  type Person struct {
      name string  // доступно только внутри пакета
  }
  ```

Дополнительные механизмы контроля доступа:
- **Геттеры и сеттеры**: методы для контролируемого доступа к приватным полям
- **Вложенные структуры**: для группировки связанных полей
- **Пакетная инкапсуляция**: определение типов в отдельных пакетах
- **Неэкспортируемые типы**: для полей, которые не должны быть видны извне
- **Функциональные опции**: для контролируемой инициализации
- **Интерфейсы**: для предоставления ограниченного доступа к функциональности

## 8. Как работает сравнение структур в Go?

Сравнение структур в Go:

- Структуры сравнимы с помощью операторов `==` и `!=`, если все их поля сравнимы
- Несравнимые поля: слайсы, карты, функции и структуры с такими полями
- При сравнении проверяется равенство всех соответствующих полей
- Сравнение выполняется рекурсивно для вложенных структур
- Указатели на структуры сравниваются по адресу, а не по содержимому
- Для несравнимых структур можно использовать рефлексию или определить метод сравнения
- Пустые структуры (`struct{}`) всегда равны друг другу
- Структуры с неэкспортируемыми полями могут быть сравнимы внутри пакета, но не между пакетами
- Для глубокого сравнения сложных структур используйте `reflect.DeepEqual` или пользовательские функции

## 9. Что такое именованные структуры и анонимные структуры?

**Именованные структуры**:
- Определяются с помощью `type` с именем
- Создают новый тип в системе типов Go
- Могут иметь методы
- Могут реализовывать интерфейсы
- Могут быть экспортированы из пакета
- Используются для повторного использования типа

```go
type Person struct {
    Name string
    Age  int
}
```

**Анонимные структуры**:
- Определяются без имени типа, непосредственно при использовании
- Не создают новый именованный тип
- Не могут иметь методы (напрямую)
- Структурно эквивалентны, но не идентичны именованным структурам
- Полезны для временных группировок данных
- Часто используются для одноразовых структур (конфигурации, ответы API)

```go
person := struct {
    Name string
    Age  int
}{
    Name: "Alice",
    Age:  30,
}
```

## 10. Как использовать теги структур и для чего они нужны?

Теги структур — это строковые метаданные, связанные с полями структуры, доступные через рефлексию:

```go
type User struct {
    ID        int    `json:"id" db:"user_id"`
    Name      string `json:"name" validate:"required"`
    Email     string `json:"email,omitempty" validate:"email"`
    CreatedAt time.Time `json:"-" db:"created_at"`
}
```

Применения тегов структур:
- **Сериализация/десериализация**: указание имен полей для JSON, XML, YAML
- **ORM и базы данных**: маппинг полей на колонки таблиц
- **Валидация**: правила проверки данных
- **Формы и HTTP**: привязка полей к параметрам запроса
- **Документация API**: генерация документации (Swagger/OpenAPI)
- **Конфигурация**: маппинг полей на переменные окружения или файлы конфигурации
- **Кодогенерация**: инструкции для генераторов кода
- **Пользовательские метаданные**: для специфичных нужд приложения

Теги обрабатываются через пакет `reflect`:
```go
field, _ := reflect.TypeOf(User{}).FieldByName("Name")
jsonTag := field.Tag.Get("json")  // "name"
```
