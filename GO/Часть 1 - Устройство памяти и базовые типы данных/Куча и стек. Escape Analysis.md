# Куча и стек. Escape Analysis

## Краткий обзор

В Go память для переменных и объектов выделяется либо на стеке, либо в куче. Стек — временная область памяти, связанная с горутиной, которая управляется автоматически и очень эффективна. Куча — централизованная область памяти, управляемая сборщиком мусора. Escape Analysis — процесс статического анализа кода компилятором Go для определения, может ли переменная быть безопасно размещена на стеке или должна "убежать" в кучу. Оптимальное размещение данных критически важно для высокопроизводительных приложений: стековые аллокации примерно в 10-100 раз быстрее кучи и не требуют работы сборщика мусора.

## Подробный разбор

### Основные концепции памяти в Go

#### Стек (Stack)

Стек — это непрерывная область памяти, работающая по принципу LIFO (Last In, First Out). Каждая горутина в Go имеет свой собственный стек, который начинается с небольшого размера (2KB в современных версиях Go) и может динамически расти до максимального размера (1GB по умолчанию).

Ключевые характеристики стека:

1. **Автоматическое управление**:
   - Переменные создаются при входе в область видимости
   - Автоматически удаляются при выходе из области видимости
   - Не требуется ручное освобождение или сборка мусора

2. **Высокая производительность**:
   - Выделение и освобождение памяти — это просто инкремент/декремент указателя стека
   - Локальность данных улучшает производительность кэша

3. **Ограниченный размер и видимость**:
   - Стек ограничен в размере (хотя в Go он динамический)
   - Переменные доступны только в своей области видимости
   - Данные на стеке не переживают возврат из функции

```go
func stackExample() {
    // Все эти переменные размещаются на стеке
    a := 5
    b := "hello"
    c := [3]int{1, 2, 3} // Массив фиксированного размера
    
    // При выходе из функции все будет автоматически освобождено
}
```

#### Куча (Heap)

Куча — это область памяти для динамического выделения, управляемая сборщиком мусора Go. Память в куче выделяется и освобождается асинхронно.

Ключевые характеристики кучи:

1. **Динамическое управление**:
   - Память выделяется при необходимости и существует независимо от области видимости
   - Освобождается сборщиком мусора, когда объект становится недостижим
   - Поддерживает объекты произвольного размера и жизненного цикла

2. **Производительность**:
   - Выделение памяти медленнее, чем на стеке
   - Требует сборки мусора, что может вызывать паузы
   - Фрагментация может снижать эффективность использования памяти

3. **Гибкость**:
   - Объекты могут существовать после возврата из функции
   - Размер ограничен только доступной системной памятью
   - Поддерживает структуры данных, размер которых определяется во время выполнения

```go
func heapExample() *int {
    // Эта переменная будет размещена в куче,
    // поскольку ее адрес возвращается из функции
    x := 42
    return &x
}
```

### Escape Analysis

#### Что такое Escape Analysis

Escape Analysis (анализ убегания) — это процесс статического анализа, выполняемый компилятором Go, чтобы определить, может ли переменная быть безопасно выделена на стеке или должна быть "перемещена" (убежать) в кучу.

Основные цели Escape Analysis:
1. Оптимизация производительности за счет максимизации стековых размещений
2. Уменьшение нагрузки на сборщик мусора
3. Улучшение локальности данных и эффективности кэша

#### Правила Escape Analysis

Компилятор Go использует набор эвристик для определения, должна ли переменная "убежать" в кучу:

1. **Возврат адреса локальной переменной**: Если функция возвращает указатель на локальную переменную, эта переменная должна быть размещена в куче
   ```go
   func returnAddress() *int {
       x := 42
       return &x // x убегает в кучу
   }
   ```

2. **Передача адреса как аргумента**: Если адрес локальной переменной передается в функцию, и компилятор не может доказать, что этот адрес не сохраняется, переменная может убежать
   ```go
   func storePointer(p *int) {
       globalVar = p // потенциально сохраняет указатель
   }
   
   func escapeExample() {
       x := 42
       storePointer(&x) // x может убежать
   }
   ```

3. **Переменные, которые могут изменять размер**: Слайсы и другие структуры данных динамического размера часто размещаются в куче
   ```go
   func createSlice(size int) []int {
       return make([]int, size) // обычно убегает в кучу для больших размеров
   }
   ```

4. **Переменные, используемые в замыканиях**: Когда переменная захватывается замыканием, она часто убегает
   ```go
   func createClosure() func() int {
       x := 42
       return func() int {
           return x // x убегает, так как захвачен замыканием
       }
   }
   ```

5. **Интерфейсы и переменные неизвестного размера**: Значения, присваиваемые интерфейсным переменным, часто убегают
   ```go
   func interfaceEscape(x interface{}) {
       // ...
   }
   
   func example() {
       s := "hello" // может убежать при передаче в интерфейс
       interfaceEscape(s)
   }
   ```

#### Инструменты для анализа Escape Analysis

Go предоставляет флаги компилятора для отображения результатов Escape Analysis:

```bash
go build -gcflags="-m" program.go           # Базовый анализ
go build -gcflags="-m -m" program.go        # Подробный анализ
go build -gcflags="-m=2" program.go         # Еще более подробный анализ
```

Пример вывода:
```
./main.go:10:16: inlining call to fmt.Println
./main.go:6:2: moved to heap: x
./main.go:16:13: makeSlice does not escape
./main.go:19:13: []int literal escapes to heap
```

### Примеры размещения данных (Senior Level)

#### Стековое размещение

```go
func stackAllocation() {
    // Все эти переменные, вероятно, будут на стеке
    a := 42
    b := "hello"
    c := [5]int{1, 2, 3, 4, 5}
    d := struct{ x, y int }{10, 20}
    
    // Использование переменных локально
    fmt.Println(a, b, c, d) // Может вызвать убегание из-за интерфейса в fmt.Println
}
```

#### Кучевое размещение

```go
func heapAllocation() *int {
    a := 42
    
    // Случаи, вызывающие убегание в кучу:
    
    // 1. Возврат адреса локальной переменной
    return &a
    
    // 2. Захват переменной в замыкании
    _ = func() {
        fmt.Println(a)
    }
    
    // 3. Хранение указателя в глобальной переменной
    globalPtr = &a
    
    // 4. Отправка указателя через канал
    ch <- &a
}
```

#### Сложные случаи с анализом

```go
// Случай 1: Большие объекты часто размещаются в куче
func largeObject() {
    // Может быть размещено в куче из-за размера
    largeArray := [10000]int{}
    
    // Использование только локально
    for i := range largeArray {
        largeArray[i] = i
    }
}

// Случай 2: Инлайнинг функций может повлиять на escape analysis
func outer() {
    x := 42
    inner(&x) // x может не убежать, если inner будет встроена
}

//go:noinline
func inner(p *int) {
    // Ничего не делаем с указателем, кроме чтения
    fmt.Println(*p)
}

// Случай 3: Интерфейсы часто вызывают убегание
func interfaceParam(data interface{}) {
    fmt.Println(data)
}

func testInterface() {
    x := 42        // x может убежать
    s := "hello"   // s может убежать
    interfaceParam(x)
    interfaceParam(s)
}
```

### Оптимизация размещения данных (Senior Level)

#### Стратегии минимизации аллокаций в куче

1. **Избегайте ненужных указателей**:
   ```go
   // Не оптимально - вызывает размещение в куче
   func createPointerUnnecessarily() *MyStruct {
       return &MyStruct{Field: 42}
   }
   
   // Оптимально
   func createValueDirectly() MyStruct {
       return MyStruct{Field: 42}
   }
   ```

2. **Предварительное выделение с известным размером**:
   ```go
   // Не оптимально - может вызвать несколько аллокаций из-за роста
   func growSlice() []int {
       s := make([]int, 0)
       for i := 0; i < 1000; i++ {
           s = append(s, i)
       }
       return s
   }
   
   // Оптимально - одна аллокация
   func preallocateSlice() []int {
       s := make([]int, 0, 1000)
       for i := 0; i < 1000; i++ {
           s = append(s, i)
       }
       return s
   }
   ```

3. **Повторное использование объектов** через пулы:
   ```go
   var bufferPool = sync.Pool{
       New: func() interface{} {
           return make([]byte, 8192)
       },
   }
   
   func processWithPool() {
       // Получаем буфер из пула
       buffer := bufferPool.Get().([]byte)
       defer bufferPool.Put(buffer)
       
       // Используем буфер...
   }
   ```

4. **Использование стековых буферов для мелких операций**:
   ```go
   func stackBuffer() string {
       // Используем стековый буфер для небольших операций
       var buf [128]byte
       n := copy(buf[:], "some string operation")
       
       // Для больших результатов все равно понадобится куча
       if n >= len(buf) {
           // Переключаемся на динамическую аллокацию только при необходимости
           return bigOperation()
       }
       
       return string(buf[:n])
   }
   ```

#### Анализ производительности и профилирование памяти

1. **Использование pprof для анализа аллокаций**:
   ```go
   import "runtime/pprof"
   
   func main() {
       f, _ := os.Create("mem.prof")
       defer f.Close()
       pprof.WriteHeapProfile(f)
       
       // Или более детальное профилирование
       import "net/http/pprof"
       go func() {
           http.ListenAndServe("localhost:6060", nil)
       }()
   }
   ```

2. **Бенчмаркинг для сравнения стратегий размещения**:
   ```go
   func BenchmarkStackAllocation(b *testing.B) {
       for i := 0; i < b.N; i++ {
           var x [1024]byte
           _ = x
       }
   }
   
   func BenchmarkHeapAllocation(b *testing.B) {
       for i := 0; i < b.N; i++ {
           x := make([]byte, 1024)
           _ = x
       }
   }
   ```

### Глубокое погружение в работу памяти Go (Senior Level)

#### Устройство стека горутин

Стек в Go реализован как contiguous stack (непрерывный стек) с возможностью динамического расширения:

1. **Начальный размер стека**: Каждая горутина начинается с небольшого стека (2KB).

2. **Проверка переполнения**: Компилятор вставляет проверки в пролог функций для обнаружения возможного переполнения стека.

3. **Копирование стека**: Когда стек близок к переполнению, рантайм Go выделяет новый, более крупный стек (обычно в два раза больше), копирует содержимое, обновляет указатели и освобождает старый стек.

```
Начальный стек 2KB     →    Новый стек 4KB
+----------------+          +----------------+
|                |          |                |
|   Данные       |   →      |   Данные       |
|                |          |                |
|                |          |                |
+----------------+          |                |
                            |                |
                            |                |
                            +----------------+
```

4. **Указатели внутри стека**: При расширении стека, рантайм должен корректировать все указатели, которые ссылаются на данные внутри стека.

#### Внутреннее устройство сборщика мусора Go

Go использует параллельный, маркировочно-очистной (concurrent mark-sweep) сборщик мусора с трассировкой указателей:

1. **Триггеры GC**:
   - По достижении порогового значения выделенной памяти (GOGC)
   - Явный вызов `runtime.GC()`
   - Давление системы на память

2. **Фазы сборки мусора**:
   * **Маркировка**:
     - Начинается с корневых указателей (глобальные переменные, стеки горутин)
     - Трассирует все достижимые объекты
     - Выполняется параллельно с работой программы
   
   * **Очистка**:
     - Освобождает память, занятую недостижимыми объектами
     - Возвращает её в свободные списки или в ОС
   
   * **Sweep Phase** (фаза очистки):
     - Очистка выполняется поэтапно и распределяется между выделениями памяти

3. **Приостановки (Stop-The-World, STW)**:
   - Современный GC в Go минимизирует STW-паузы
   - Основная пауза требуется для инициализации цикла сборки
   - Типичная продолжительность < 1ms в Go 1.14+

4. **Write barriers** (барьеры записи):
   - Механизм, отслеживающий изменения в памяти во время работы GC
   - Позволяет GC работать параллельно с приложением
   - Активируются во время фазы маркировки

#### Взаимодействие компилятора и рантайма для оптимизации памяти

1. **Инлайнинг функций**:
   ```go
   // Функция-кандидат для инлайнинга
   func add(a, b int) int {
       return a + b
   }
   
   func main() {
       // Может быть оптимизировано до x := 5 + 3
       x := add(5, 3)
   }
   ```

2. **Анализ убегания (Escape Analysis)**:
   - Статический анализ во время компиляции
   - Определяет, где разместить переменные
   - Может быть ограничен из-за раздельной компиляции пакетов

3. **Оптимизация границ массивов**:
   ```go
   // До оптимизации
   for i := 0; i < len(arr); i++ {
       arr[i] = i
   }
   
   // После оптимизации
   length := len(arr) // вычисляется один раз
   for i := 0; i < length; i++ {
       arr[i] = i
   }
   ```

4. **Оптимизация размера структур**:
   - Компилятор может изменить порядок полей для минимизации padding
   - Уменьшает фрагментацию и улучшает локальность кэша

### Типичные ошибки и антипаттерны

#### Частые причины нежелательных аллокаций в куче

1. **Неявное боксирование в интерфейсах**:
   ```go
   func processValue(v interface{}) {
       // ...
   }
   
   func main() {
       x := 42 // x убегает при передаче в интерфейс
       processValue(x)
   }
   ```

2. **Создание замыканий в цикле**:
   ```go
   func createFuncs() []func() int {
       var funcs []func() int
       
       // В каждой итерации создается новое замыкание,
       // которое захватывает переменную i
       for i := 0; i < 10; i++ {
           funcs = append(funcs, func() int {
               return i // замыкание захватывает i, что вызывает аллокацию
           })
       }
       
       return funcs
   }
   ```

3. **Ненужные преобразования типов**:
   ```go
   func convert(data []byte) string {
       // Каждое преобразование создает новую копию в куче
       return string(data)
   }
   ```

4. **Создание временных слайсов/map в горячих путях**:
   ```go
   func hotPathAlloc(items []int) int {
       // Создание временной map в часто вызываемой функции
       seen := make(map[int]bool)
       for _, item := range items {
           seen[item] = true
       }
       return len(seen)
   }
   ```

#### Утечки памяти в Go

Да, даже с GC в Go возможны утечки памяти:

1. **Неосвобожденные ресурсы**:
   ```go
   func leakingResource() {
       f, _ := os.Open("large-file.txt")
       // Забыли f.Close() - дескриптор файла не будет закрыт
       
       data := make([]byte, 1024*1024*100)
       _, _ = f.Read(data)
   }
   ```

2. **Бесконечно растущие структуры данных**:
   ```go
   var cache = make(map[string][]byte)
   
   func handleRequest(key string, data []byte) {
       // Кэш растет бесконечно, никогда не очищается
       cache[key] = data
   }
   ```

3. **Захваченные переменные в горутинах**:
   ```go
   func startWorkers(jobs <-chan Job) {
       for job := range jobs {
           // Утечка горутины, если канал results никогда не очищается
           results := make(chan Result)
           go func(j Job) {
               results <- process(j)
           }(job)
       }
   }
   ```

4. **Циклические ссылки с finalizers**:
   ```go
   type Node struct {
       next *Node
       data []byte
   }
   
   func createCycle() {
       a := &Node{data: make([]byte, 1024*1024)}
       b := &Node{data: make([]byte, 1024*1024)}
       a.next = b
       b.next = a
       
       // Если a и b станут недоступны, но на них есть finalizers,
       // циклическая ссылка может препятствовать сборке мусора
   }
   ```

### Рекомендации по работе с памятью

#### Лучшие практики для высокопроизводительного кода

1. **Предпочитайте стековые размещения**:
   - Используйте значения вместо указателей, где это возможно
   - Передавайте небольшие структуры по значению
   - Возвращайте результаты по значению, не по указателю (для небольших структур)

2. **Минимизируйте аллокации в горячих путях**:
   - Предварительно выделяйте буферы
   - Используйте пулы объектов для повторного использования
   - Избегайте создания временных объектов в циклах

3. **Эффективная работа со слайсами**:
   - Предварительно выделяйте емкость, где возможно
   - Обрезайте слайсы (re-slicing) для уменьшения занимаемой памяти
   - Используйте `copy()` вместо re-slicing, чтобы освободить базовый массив

4. **Используйте структуры подходящего размера**:
   - Учитывайте выравнивание полей структуры
   - Группируйте поля по размеру для минимизации padding
   - Рассмотрите использование инструментов для анализа размера структур

5. **Профилирование и мониторинг**:
   - Регулярно профилируйте использование памяти
   - Устанавливайте лимиты на использование памяти в критических компонентах
   - Мониторьте метрики GC и время пауз

#### Использование sync.Pool для снижения нагрузки на GC

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 4096)
    },
}

func processRequest(data []byte) []byte {
    // Получаем буфер из пула
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer)
    
    // Сбрасываем буфер перед использованием
    buffer = buffer[:0]
    
    // Используем буфер...
    for _, b := range data {
        buffer = append(buffer, b+1)
    }
    
    // Создаем копию результата перед возвратом буфера в пул
    result := make([]byte, len(buffer))
    copy(result, buffer)
    
    return result
}
```

#### Настройка работы GC

```go
import "runtime/debug"

func tuneGC() {
    // Установка целевого процента для запуска GC
    // По умолчанию GOGC=100 (GC запускается, когда объем выделенной памяти удваивается)
    // GOGC=200 - менее частые сборки, больше использование памяти
    // GOGC=50 - более частые сборки, меньше использование памяти
    debug.SetGCPercent(200)
    
    // Принудительный запуск сборки мусора
    runtime.GC()
    
    // Освобождение неиспользуемой памяти в ОС
    debug.FreeOSMemory()
}
```

## Связанные заметки
- [[Базовые типы данных]]
- [[Указатели]]
- [[Структуры. Pointer receiver. Value receiver]]
- [[Пустой интерфейс и пустая структура]]
- [[Выравнивание структур]]

## Источники
- [Go Memory Management](https://povilasv.me/go-memory-management/)
- [Go GC Guide](https://tip.golang.org/doc/gc-guide)
- [Go Escape Analysis](https://github.com/golang/go/wiki/CompilerOptimizations#escape-analysis)
- [Go 101: Memory Layout](https://go101.org/article/memory-layout.html)
- [Go's Memory Management](https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44)
- [Dave Cheney: High Performance Go Workshop](https://dave.cheney.net/high-performance-go-workshop/gophercon-2019.html)
- [Golang Garbage Collection Handbook](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)
- [Golang Runtime Source Code](https://github.com/golang/go/blob/master/src/runtime/malloc.go) 