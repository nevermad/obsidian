
## Короткий ответ

Модификаторы видимости в Solidity (`public`, `private`, `internal`, `external`) определяют, как функции и переменные могут быть доступны внутри и вне контракта. На уровне байт-кода EVM эти модификаторы влияют на способ вызова функций и доступа к данным, что может привести к различным затратам газа.

---

## Подробный разбор

### **Public**
1. **Определение:**
   - Функции и переменные с модификатором `public` доступны как внутри контракта, так и извне.
   - Для переменных автоматически создается геттер (getter) функция.

2. **Пример:**
   ```solidity
   uint public value = 42;

   function getValue() public view returns (uint) {
       return value;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода функция `public` имеет специальный обработчик для внешних вызовов через ABI.
   - Геттер для переменной `value` будет выглядеть как:
     ```
     function value() external view returns (uint) {
         return value;
     }
     ```

4. **Особенности:**
   - Удобен для переменных, которые должны быть доступны извне.
   - Может увеличивать затраты газа из-за необходимости поддержки внешних вызовов.

5. **Подводные камни:**
   - Внешние вызовы `public` функций требуют больше газа, чем внутренние вызовы.
   - Не рекомендуется использовать для чувствительных данных, так как они становятся доступны всем.

---

### **Private**
1. **Определение:**
   - Функции и переменные с модификатором `private` доступны только внутри контракта, где они объявлены.
   - Никакой внешний контракт или аккаунт не может получить к ним доступ.

2. **Пример:**
   ```solidity
   uint private secretValue = 123;

   function getSecretValue() private view returns (uint) {
       return secretValue;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода отсутствует обработчик для внешних вызовов.
   - Данные хранятся в `storage`, но доступны только через внутренние вызовы.

4. **Особенности:**
   - Используется для защиты конфиденциальных данных.
   - Меньше затрат газа по сравнению с `public`.

5. **Подводные камни:**
   - Даже если переменная `private`, данные все равно хранятся в блокчейне и могут быть прочитаны напрямую из `storage`.
   - Не обеспечивает полной безопасности, а только ограничивает доступ через ABI.

---

### **Internal**
1. **Определение:**
   - Функции и переменные с модификатором `internal` доступны внутри контракта и его наследников.
   - Внешние контракты или аккаунты не могут получить к ним доступ.

2. **Пример:**
   ```solidity
   uint internal sharedValue = 789;

   function getSharedValue() internal view returns (uint) {
       return sharedValue;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода доступ осуществляется через внутренние вызовы.
   - Используется для организации логики между базовым и производным контрактами.

4. **Особенности:**
   - Полезен для повторного использования кода в наследуемых контрактах.
   - Меньше затрат газа по сравнению с `public`.

5. **Подводные камни:**
   - Наследники могут изменять поведение функций, что требует осторожности при проектировании.

---

### **External**
1. **Определение:**
   - Функции с модификатором `external` доступны только для внешних вызовов.
   - Переменные не могут быть объявлены как `external`.

2. **Пример:**
   ```solidity
   function setValue(uint _value) external {
       value = _value;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода используется более эффективный механизм для внешних вызовов через `calldata`.
   - Внутри контракта вызов `external` функции невозможен напрямую.

4. **Особенности:**
   - Экономит газ за счет использования `calldata`.
   - Подходит для функций, которые не должны вызываться внутри контракта.

5. **Подводные камни:**
   - Невозможно вызвать `external` функцию внутри контракта без использования `this.functionName()`.

---

### **Нюансы на уровне байт-кода EVM**
1. **Public vs External:**
   - `public` функции поддерживают как внутренние, так и внешние вызовы, что увеличивает их сложность и затраты газа.
   - `external` функции используют `calldata`, что делает их более эффективными для внешних вызовов.

2. **Private vs Internal:**
   - `private` функции и переменные полностью скрыты от внешнего мира, но их данные все еще доступны в блокчейне.
   - `internal` функции позволяют наследникам переиспользовать код, но требуют осторожности при проектировании.

3. **Gas Costs:**
   - Внешние вызовы (`public`, `external`) требуют больше газа, чем внутренние (`private`, `internal`).
   - Использование `calldata` в `external` функциях снижает затраты газа.

---

### **Пример комбинированного использования**
```solidity
contract VisibilityExample {
    uint private secretValue = 123;
    uint internal sharedValue = 456;
    uint public visibleValue = 789;

    function getSecretValue() private view returns (uint) {
        return secretValue;
    }

    function getSharedValue() internal view returns (uint) {
        return sharedValue;
    }

    function getVisibleValue() public view returns (uint) {
        return visibleValue;
    }

    function setExternalValue(uint _value) external {
        visibleValue = _value;
    }
}
```

- В этом примере:
  - `secretValue` доступна только внутри контракта.
  - `sharedValue` доступна внутри контракта и его наследников.
  - `visibleValue` доступна всем.
  - `setExternalValue` может быть вызвана только извне.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Что такое упаковка структур? Приведите примеры.]]

---

## Источники
- [Solidity Documentation - Visibility and Getters](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters)
- [Understanding Function Visibility in Solidity](https://ethereum.stackexchange.com/questions/91874/what-is-the-difference-between-public-private-internal-and-external-functions)
---