
## Короткий ответ

Модификаторы видимости в Solidity (`public`, `private`, `internal`, `external`) определяют, как функции и переменные могут быть доступны внутри и вне контракта. На уровне EVM эти модификаторы влияют на способ вызова функций, использование `calldata` или `storage`, а также затраты газа. Понимание их работы критически важно для оптимизации смарт-контрактов.

---

## Подробный разбор

### **Public**

#### **Определение:**
- Функции и переменные с модификатором `public` доступны как внутри контракта, так и извне.
- Для переменных автоматически создается геттер (getter) функция.

#### **Пример:**
```solidity
uint public value = 42;
function getValue() public view returns (uint) {
    return value;
}
```

#### **Технические детали на уровне EVM:**
- **Геттер для переменной:**
  - Компилятор автоматически генерирует внешнюю функцию для доступа к переменной:
    ```solidity
    function value() external view returns (uint) {
        return value;
    }
    ```
  - На уровне EVM используется опкод `SLOAD` для чтения данных из `storage`.
- **Вызов функций:**
  - `public` функции поддерживают как внутренние вызовы (через `JUMP`), так и внешние вызовы (через ABI).
  - Внешние вызовы требуют больше газа, так как используют `CALL`.

#### **Особенности:**
- Удобен для переменных, которые должны быть доступны извне.
- Может увеличивать затраты газа из-за необходимости поддержки внешних вызовов.

#### **Подводные камни:**
- Внешние вызовы `public` функций требуют больше газа, чем внутренние вызовы.
- Не рекомендуется использовать для чувствительных данных, так как они становятся доступны всем через ABI.

---

### **Private**

#### **Определение:**
- Функции и переменные с модификатором `private` доступны только внутри контракта, где они объявлены.
- Никакой внешний контракт или аккаунт не может получить к ним доступ.

#### **Пример:**
```solidity
uint private secretValue = 123;
function getSecretValue() private view returns (uint) {
    return secretValue;
}
```

#### **Технические детали на уровне EVM:**
- **Доступ к данным:**
  - Переменные хранятся в `storage`, но доступ к ним возможен только через внутренние вызовы.
  - На уровне EVM используется опкод `SLOAD` для чтения данных.
- **Отсутствие внешнего интерфейса:**
  - Нет геттеров или обработчиков для внешних вызовов.

#### **Особенности:**
- Используется для защиты конфиденциальных данных.
- Меньше затрат газа по сравнению с `public`.

#### **Подводные камни:**
- Даже если переменная `private`, данные все равно хранятся в блокчейне и могут быть прочитаны напрямую из `storage`.
- Не обеспечивает полной безопасности, а только ограничивает доступ через ABI.

---

### **Internal**

#### **Определение:**
- Функции и переменные с модификатором `internal` доступны внутри контракта и его наследников.
- Внешние контракты или аккаунты не могут получить к ним доступ.

#### **Пример:**
```solidity
uint internal sharedValue = 789;
function getSharedValue() internal view returns (uint) {
    return sharedValue;
}
```

#### **Технические детали на уровне EVM:**
- **Доступ через наследование:**
  - На уровне EVM наследники получают доступ к `internal` функциям и переменным через внутренние вызовы.
  - Используется опкод `JUMP` для вызова функций внутри контракта.
- **Хранение данных:**
  - Переменные хранятся в `storage` и доступны через `SLOAD`.

#### **Особенности:**
- Полезен для повторного использования кода в наследуемых контрактах.
- Меньше затрат газа по сравнению с `public`.

#### **Подводные камни:**
- Наследники могут изменять поведение функций, что требует осторожности при проектировании.

---

### **External**

#### **Определение:**
- Функции с модификатором `external` доступны только для внешних вызовов.
- Переменные не могут быть объявлены как `external`.

#### **Пример:**
```solidity
function setValue(uint _value) external {
    value = _value;
}
```

#### **Технические детали на уровне EVM:**
- **Использование `calldata`:**
  - Аргументы функции хранятся в `calldata`, что делает внешние вызовы более эффективными.
  - На уровне EVM используется опкод `CALLDATALOAD` для чтения данных.
- **Ограничение на внутренние вызовы:**
  - Внутри контракта вызов `external` функции невозможен напрямую. Требуется использование `this.functionName()`.

#### **Особенности:**
- Экономит газ за счет использования `calldata`.
- Подходит для функций, которые не должны вызываться внутри контракта.

#### **Подводные камни:**
- Невозможно вызвать `external` функцию внутри контракта без использования `this.functionName()`.

---

### **Нюансы на уровне байт-кода EVM**

#### **1) Public vs External:**
- **Public:**
  - Поддерживает как внутренние, так и внешние вызовы.
  - Внешние вызовы требуют больше газа из-за использования `CALL`.
- **External:**
  - Использует `calldata` для хранения аргументов, что снижает затраты газа.
  - Ограничен только внешними вызовами.

#### **2) Private vs Internal:**
- **Private:**
  - Полностью скрыт от внешнего мира, но данные доступны в блокчейне.
- **Internal:**
  - Доступен для наследников, что позволяет переиспользовать код.

#### **3) Gas Costs:**
- Внешние вызовы (`public`, `external`) требуют больше газа, чем внутренние (`private`, `internal`).
- Использование `calldata` в `external` функциях снижает затраты газа.

---

### **Пример комбинированного использования**

```solidity
contract VisibilityExample {
    uint private secretValue = 123;
    uint internal sharedValue = 456;
    uint public visibleValue = 789;

    function getSecretValue() private view returns (uint) {
        return secretValue;
    }

    function getSharedValue() internal view returns (uint) {
        return sharedValue;
    }

    function getVisibleValue() public view returns (uint) {
        return visibleValue;
    }

    function setExternalValue(uint _value) external {
        visibleValue = _value;
    }
}
```

- **Анализ:**
  - `secretValue` доступна только внутри контракта.
  - `sharedValue` доступна внутри контракта и его наследников.
  - `visibleValue` доступна всем через геттер.
  - `setExternalValue` может быть вызвана только извне.

---

### **Заключение**

Модификаторы видимости в Solidity играют ключевую роль в управлении доступом к данным и функциям. На уровне EVM они влияют на способ вызова функций, использование памяти (`calldata`, `storage`) и затраты газа. Понимание этих механизмов критически важно для оптимизации смарт-контрактов.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Что такое упаковка структур? Приведите примеры.]]

---

## Источники
- [Solidity Documentation - Visibility and Getters](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters)
- [Understanding Function Visibility in Solidity](https://ethereum.stackexchange.com/questions/91874/what-is-the-difference-between-public-private-internal-and-external-functions)
- [The EVM Handbook](https://noxx3xxon.notion.site/noxx3xxon/The-EVM-Handbook-bb38e175cc404111a391907c4975426d)
- [EVM opcodes & instructions set](https://www.evm.codes/)