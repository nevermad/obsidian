## Короткий ответ
В Ethereum существуют три основных метода отправки Ether: `transfer`, `send` и `call`. Каждый метод имеет свои особенности, преимущества и ограничения. Профессиональный подход требует понимания их работы на уровне EVM, включая опкоды, газовые затраты и потенциальные уязвимости.

---

## Подробный разбор

### **1) Метод `transfer`**

#### **Особенности:**
- **Газовое ограничение:** Фиксированное значение 2300 газа.
- **Обработка ошибок:** Выбрасывает исключение при неудаче.
- **На уровне EVM:**
  - Использует инструкцию `CALL` с фиксированным лимитом газа:
    ```solidity
    CALL(gas=2300, address, value, data)
    ```
  - Если вызов завершается неудачно, выбрасывается исключение (`REVERT`).

#### **Пример использования:**
```solidity
contract Sender {
    function sendViaTransfer(address payable recipient) public payable {
        recipient.transfer(msg.value); // Отправка Ether с ограничением в 2300 газа
    }
}
```

#### **Технические детали:**
- **Ограничения:**
  - Жесткое ограничение в 2300 газа делает `transfer` непригодным для контрактов с сложной логикой в fallback-функции.
  - Может привести к сбоям при взаимодействии с контрактами, требующими больше газа.

- **Подводные камни:**
  - Не совместим с будущими изменениями в Ethereum (например, увеличение стоимости операций).
  - Рекомендуется избегать в новых проектах.

---

### **2) Метод `send`**

#### **Особенности:**
- **Газовое ограничение:** Также фиксированное значение 2300 газа.
- **Обработка ошибок:** Возвращает `false` при неудаче вместо выброса исключения.
- **На уровне EVM:**
  - Аналогично `transfer`, использует инструкцию `CALL` с фиксированным лимитом газа:
    ```solidity
    CALL(gas=2300, address, value, data)
    ```

#### **Пример использования:**
```solidity
contract Sender {
    function sendViaSend(address payable recipient) public payable {
        bool success = recipient.send(msg.value);
        require(success, "Send failed"); // Проверка результата
    }
}
```

#### **Технические детали:**
- **Ограничения:**
  - Требует явной проверки результата, что усложняет код.
  - Устаревший метод, аналогичный `transfer`.

- **Подводные камни:**
  - Сложность отладки из-за отсутствия автоматического выброса исключений.
  - Рекомендуется избегать в новых проектах.

---

### **3) Метод `call`**

#### **Особенности:**
- **Газовое ограничение:** Динамическое, отправляет все доступное газо или указанное количество газа.
- **Обработка ошибок:** Возвращает результат выполнения (`success`) и данные.
- **На уровне EVM:**
  - Использует инструкцию `CALL` с динамическим лимитом газа:
    ```solidity
    CALL(gas=remainingGas, address, value, data)
    ```
  - Позволяет передавать дополнительные данные вместе с Ether.

#### **Пример использования:**
```solidity
contract Sender {
    function sendViaCall(address payable recipient) public payable {
        (bool success, ) = recipient.call{value: msg.value}("");
        require(success, "Call failed"); // Проверка результата
    }
}
```

#### **Технические детали:**
- **Преимущества:**
  - Большая гибкость для целевого контракта.
  - Совместимость с современными стандартами и рекомендациями.
  - Возможность отправлять Ether с данными.

- **Подводные камни:**
  - Требует явной проверки результата (`success`).
  - Может быть использован для вызова функций контракта, что требует осторожности.

---

### **Сравнение методов**

| Метод      | Газ          | Обработка ошибок | Рекомендации                     |
|------------|--------------|------------------|----------------------------------|
| `transfer` | 2300         | Выбрасывает исключение | Устаревший, избегать в новых проектах |
| `send`     | 2300         | Возвращает `false` | Устаревший, избегать в новых проектах |
| `call`     | Динамический | Возвращает результат | Предпочтительный способ          |

---

### **Почему `call` предпочтителен?**

1. **Гибкость:**
   - Отправляет все доступное газо, что позволяет целевому контракту выполнять более сложную логику.
   - Это особенно важно для контрактов с fallback-функциями, которые требуют больше газа.

2. **На уровне EVM:**
   - На уровне EVM `call` выполняется через инструкцию `CALL` с динамическим лимитом газа:
     ```solidity
     CALL(gas=remainingGas, address, value, data)
     ```

3. **Пример использования:**
   ```solidity
   contract Receiver {
       uint public value;

       fallback() external payable {
           value = 42; // Простая операция записи
       }
   }

   contract Sender {
       function sendViaCall(address payable recipient) public payable {
           (bool success, ) = recipient.call{value: msg.value}("");
           require(success, "Call failed");
       }
   }
   ```

   - В этом примере:
     - Целевой контракт может выполнять любую логику в fallback-функции без ограничений.

---

### **Заключение**
Использование `transfer` и `send` считается устаревшим из-за жесткого ограничения в 2300 газа, которое может привести к сбоям при взаимодействии с контрактами. Рекомендуется использовать метод `call`, который предоставляет большую гибкость и совместимость с современными стандартами Ethereum.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Что такое raw call? Как представлен на уровне байткода? Когда стоит применять? Какое значение msg.sender, msg.value внутри вызова delegatecall?]]

---

## Источники
- [Three Methods to Transfer Funds in Ethereum by Means of Solidity](https://medium.com/daox/three-methods-to-transfer-funds-in-ethereum-by-means-of-solidity-5719944ed6e9)
- [Understanding Ether Transfer Methods in Solidity](https://ethereum.stackexchange.com/questions/81994/what-is-the-difference-between-fallback-and-receive-functions-in-solidity)
---
