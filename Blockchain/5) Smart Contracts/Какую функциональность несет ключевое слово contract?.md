## Короткий ответ

Ключевое слово `contract` в Solidity используется для определения смарт-контракта. На уровне EVM контракт представляет собой исполняемый код (runtime code), который хранится в блокчейне и выполняется при вызове функций. Контракт также имеет связанное с ним хранилище состояния (storage) и уникальный адрес.

---

## Подробный разбор

### **Что такое contract?**

#### **На уровне Solidity:**
- Ключевое слово `contract` определяет новый смарт-контракт, который является основным строительным блоком в Solidity.
- Контракт содержит:
  - **Переменные состояния:** Хранят данные в блокчейне.
  - **Функции:** Определяют логику контракта.
  - **Модификаторы:** Управляют доступом к функциям.
  - **События:** Позволяют логировать важные действия.
  - **Структуры и перечисления:** Используются для создания сложных типов данных.

#### **Пример:**
```solidity
contract MyContract {
    uint public value;

    function setValue(uint _value) public {
        value = _value;
    }
}
```

---

### **Что такое contract на уровне EVM?**

#### **1) Байт-код контракта:**
- **Initial Code (Creation Bytecode):**
  - Это код, который выполняется один раз при развертывании контракта.
  - Его задача — подготовить runtime code и вернуть его.
  - Пример:
    ```solidity
    constructor(uint _value) {
        value = _value;
    }
    ```
  - На уровне EVM:
    - Initial code использует опкоды `CODECOPY` и `RETURN` для создания runtime code.

- **Runtime Code:**
  - Это код, который остается после развертывания и содержит логику контракта.
  - Пример:
    ```solidity
    function setValue(uint _value) public {
        value = _value;
    }
    ```

#### **2) Адрес контракта:**
- Адрес контракта вычисляется на основе:
  - Адреса создателя (deployer).
  - Номера транзакции создателя.
  - Для `CREATE2`: Хэша init code и соли.

#### **3) Storage:**
- Storage организовано в виде слотов памяти, каждый размером 32 байта.
- Пример:
  ```solidity
  contract Example {
      uint public a; // Slot 0
      uint public b; // Slot 1
  }
  ```

#### **4) Вызовы контракта:**
- На уровне EVM контракты взаимодействуют через опкоды:
  - `CALL`: Для вызова функций.
  - `DELEGATECALL`: Для выполнения кода в контексте вызывающего контракта.
  - `STATICCALL`: Для вызова функций без изменения состояния.

---

### **Аналогия с классами в ООП**

#### **Сходства:**
- Контракты похожи на классы в объектно-ориентированных языках программирования.
- Поддерживают наследование, инкапсуляцию и полиморфизм.

#### **Различия:**
- Контракты существуют в блокчейне и имеют связанные с ними затраты газа.
- Переменные состояния хранятся в блокчейне и не могут быть удалены после записи.
- Функции могут вызываться как внешними аккаунтами (EOA), так и другими контрактами.

---

### **Основные компоненты контракта**

#### **1) Переменные состояния:**
```solidity
uint public balance;
```
- Эти переменные хранятся в блокчейне и являются частью состояния контракта.

#### **2) Функции:**
```solidity
function deposit() public payable {
    balance += msg.value;
}
```
- Функции определяют поведение контракта. Они могут быть `public`, `private`, `internal`, `external`, а также `view` или `pure`.

#### **3) Конструктор:**
```solidity
constructor(uint initialValue) {
    balance = initialValue;
}
```
- Конструктор выполняется один раз при развертывании контракта.

#### **4) Модификаторы:**
```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Not the owner");
    _;
}
```
- Модификаторы позволяют ограничивать доступ к функциям.

#### **5) События:**
```solidity
event Deposit(address indexed sender, uint amount);
```
- События используются для логирования действий контракта.

---

### **Наследование**

#### **Пример:**
```solidity
contract Parent {
    function foo() public pure virtual returns (string memory) {
        return "Parent";
    }
}

contract Child is Parent {
    function foo() public pure override returns (string memory) {
        return "Child";
    }
}
```
- Здесь `Child` наследует от `Parent` и переопределяет метод `foo`.

#### **Технические детали:**
- На уровне EVM наследование реализуется через копирование кода родительского контракта в дочерний.

---

### **Заключение**

Ключевое слово `contract` в Solidity определяет смарт-контракт, который на уровне EVM представляет собой исполняемый код, хранящийся в блокчейне. Контракты имеют связанное с ними хранилище состояния и уникальный адрес. Понимание работы контрактов на уровне EVM критически важно для профессиональной разработки смарт-контрактов.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Какую функциональность добавляет ключевое слово calldata, memory? В чем отличие calldata и memory?]]
- [[Как работают модификаторы видимости public, private, internal, external на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Как работает constructor в контракте?]]

---

## Источники
- [Solidity Documentation - Contracts](https://docs.soliditylang.org/en/latest/contracts.html)
- [Solidity Inheritance](https://docs.soliditylang.org/en/latest/contracts.html#inheritance)
- [EVM Opcodes](https://www.evm.codes/)