
### **1) Где хранятся immutable переменные?**
- **Определение:**
  - Immutable переменные внедряются в runtime-код контракта при развертывании.
- **На уровне EVM:**
  - Immutable переменные хранятся в байт-коде контракта.
  - Опкоды: `CODECOPY` используется для чтения значений immutable переменных.

---

### **2) Где могут храниться переменные, объявленные в теле функции? (stack, memory, storage)**
- **Определение:**
  - Переменные, объявленные в теле функции, могут храниться в `stack` (примитивные типы) или `memory` (сложные типы, такие как массивы или структуры).
- **На уровне EVM:**
  - Примитивные типы (например, `uint`) хранятся в стеке (`stack`), используя опкоды `PUSH`/`POP`.
  - Сложные типы (например, `string` или `struct`) хранятся в памяти (`memory`), используя опкоды `MLOAD`/`MSTORE`.

---

### **3) Как определяется, какую часть слота нужно считать, если в ней хранится несколько переменных?**
- **Определение:**
  - Если несколько переменных упакованы в один слот, их положение определяется порядком объявления и размером.
- **На уровне EVM:**
  - Опкоды: `SLOAD` загружает весь слот, а затем используются битовые операции (например, `AND`, `SHR`) для извлечения конкретной части данных.

---

### **4) Value и Reference типы**
- **Value типы:**
  - Хранятся напрямую в слотах `storage` или `stack`. Примеры: `uint`, `bool`, `address`.
- **Reference типы:**
  - Хранят ссылку на данные. Примеры: `array`, `struct`, `mapping`.
- **На уровне EVM:**
  - Value типы используются с опкодами `PUSH`/`POP`.
  - Reference типы используются с опкодами `MLOAD`/`MSTORE` или `SLOAD`/`SSTORE`.

---

### **5) Зачем использовать структуры при объявлении смарт-контракта, если мы можем объявить все переменные просто в теле смарт-контракта?**
- **Определение:**
  - Структуры позволяют группировать связанные данные, что улучшает читаемость и организацию кода.
- **Преимущества:**
  - Удобство работы с логически связанными данными.
  - Эффективное использование памяти через упаковку.
- **На уровне EVM:**
  - Опкоды: `SLOAD`/`SSTORE` используются для доступа к полям структуры.

---

### **6) Как происходит конвертация байткода в текст? Я как программист работаю с текстом, но ведь этот текст хранится в байткоде.**
- **Определение:**
  - Байткод декомпилируется в текстовый формат с помощью инструментов, таких как Dedaub Decompiler.
- **На уровне EVM:**
  - Байткод состоит из последовательности опкодов, которые интерпретируются декомпилятором для восстановления исходного кода.
- **Инструменты:**
  - [Dedaub Decompiler](https://app.dedaub.com/decompile).

---

### **7) Как работает `public`, `external`, `private`, `internal` на уровне EVM (байткод)?**
- **Определение:**
  - Модификаторы видимости влияют на доступность функций:
    - `public`: Доступна внутри и снаружи контракта.
    - `external`: Доступна только извне.
    - `internal`: Доступна внутри контракта и его наследников.
    - `private`: Доступна только внутри контракта.
- **На уровне EVM:**
  - Опкоды: `CALL` используется для вызова `external` функций, а `JUMP` для внутренних вызовов.

---

### **8) В чем разница между `pure` и `view` на уровне EVM (байткод)?**
- **Определение:**
  - `view`: Может читать данные из `storage`, но не изменять их.
  - `pure`: Не может читать или изменять данные из `storage`.
- **На уровне EVM:**
  - `view` использует опкоды `SLOAD` для чтения данных.
  - `pure` не использует `SLOAD` или `SSTORE`.

---

### **9) Какой формируется layout функции при вызове `public` или `external`?**
- **Определение:**
  - Для `public` функций генерируется геттер, который позволяет читать значения переменных.
  - Для `external` функций используется ABI для вызова.
- **На уровне EVM:**
  - Опкоды: `CALL` используется для вызова `external` функций, а `JUMP` для `public`.

---

### **10) В каких случаях EVM использует `JUMP` для функций с модификатором?**
- **Определение:**
  - `JUMP` используется для перехода к внутренним функциям или модификаторам.
- **На уровне EVM:**
  - Опкоды: `JUMP` и `JUMPI` используются для управления потоком выполнения.

---

### **11) Как работает `payable` на уровне EVM и какую добавляет проверку?**
- **Определение:**
  - `payable` разрешает отправку Ether вместе с вызовом функции.
- **На уровне EVM:**
  - Опкоды: `CALL` проверяет значение `msg.value` и разрешает передачу Ether.

---

### **12) Конкретнее узнать, откуда берется runtime код? Из initial кода?**
- **Определение:**
  - Runtime код генерируется после выполнения `initial code` (конструктора).
- **На уровне EVM:**
  - `initial code` выполняется при развертывании контракта, а затем сохраняется `runtime code`.

---

### **13) Можно ли отправить деньги контракту без `payable` функций? (Ответ: да)**
- **Определение:**
  - Да, через механизм `selfdestruct` или mining rewards (устаревший механизм).
- **На уровне EVM:**
  - Опкоды: `SELFDESTRUCT` отправляет остаточный баланс на указанный адрес.

---

### **14) Что такое interface в Solidity? Как представлен на уровне EVM? Какие особенности и ограничения?**
- **Определение:**
  - Интерфейс определяет набор функций, которые должны быть реализованы в контракте.
- **На уровне EVM:**
  - Интерфейсы используют ABI для вызова функций.
- **Особенности:**
  - Интерфейсы не содержат реализации функций.
  - Используются для взаимодействия с внешними контрактами.

---

## Источники
- [Solidity Documentation - Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
- [Understanding Immutable Variables in Solidity](https://ethereum.stackexchange.com/questions/81994/what-is-the-difference-between-fallback-and-receive-functions-in-solidity)
- [Dedaub Decompiler](https://app.dedaub.com/decompile)
---