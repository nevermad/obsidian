## Короткий ответ
`delegatecall`, `call` и библиотеки в Solidity предоставляют разные способы взаимодействия между контрактами. Каждый метод имеет свои особенности, преимущества и ограничения. Понимание их работы на уровне EVM критически важно для профессиональной разработки смарт-контрактов.

---

## Подробный разбор

### **1) Метод `call`**

#### **Особенности:**
- **Контекст выполнения:**
  - Выполняет код целевого контракта в его собственном контексте.
  - Storage и `msg.sender` остаются из целевого контракта.
- **На уровне EVM:**
  - Использует инструкцию `CALL`.
  - Пример:
    ```solidity
    (bool success, bytes memory data) = target.call{value: amount}(abi.encodeWithSignature("functionName(uint256)", param));
    require(success, "Call failed");
    ```

#### **Преимущества:**
- Гибкость: Позволяет передавать Ether и данные.
- Совместимость: Может вызывать любые функции контракта.

#### **Подводные камни:**
- Требует явной проверки результата (`success`).
- Может быть использован для вызова неизвестных или злонамеренных контрактов.

---

### **2) Метод `delegatecall`**

#### **Особенности:**
- **Контекст выполнения:**
  - Выполняет код целевого контракта в контексте вызывающего контракта.
  - Storage, `msg.sender` и `msg.value` берутся из вызывающего контракта.
- **На уровне EVM:**
  - Использует инструкцию `DELEGATECALL`.
  - Пример:
    ```solidity
    (bool success, bytes memory data) = target.delegatecall(abi.encodeWithSignature("functionName(uint256)", param));
    require(success, "Delegatecall failed");
    ```

#### **Преимущества:**
- Позволяет повторно использовать код без копирования данных.
- Применяется для прокси-контрактов и библиотек.

#### **Подводные камни:**
- Неправильное использование может привести к изменению неожиданных переменных в storage.
- Требует совпадения структуры storage вызывающего и целевого контрактов.

---

### **3) Библиотеки**

#### **Особенности:**
- **Контекст выполнения:**
  - Библиотеки используют `delegatecall` для выполнения кода в контексте вызывающего контракта.
  - Не могут хранить состояние (кроме специальных случаев).
- **На уровне EVM:**
  - Используют инструкцию `DELEGATECALL`.
  - Пример:
    ```solidity
    library SafeMath {
        function add(uint a, uint b) internal pure returns (uint) {
            uint c = a + b;
            require(c >= a, "Overflow");
            return c;
        }
    }

    contract Example {
        using SafeMath for uint;

        function calculate(uint a, uint b) public pure returns (uint) {
            return a.add(b);
        }
    }
    ```

#### **Преимущества:**
- Повторное использование кода без дублирования.
- Экономия газа за счет оптимизации.

#### **Подводные камни:**
- Ограниченная функциональность: Библиотеки не могут хранить состояние.
- Требуется тщательное проектирование для предотвращения ошибок.

---

### **4) Сравнение `call`, `delegatecall` и библиотек**

| Характеристика       | `call`                          | `delegatecall`                  | Библиотеки                      |
|----------------------|---------------------------------|----------------------------------|----------------------------------|
| Контекст выполнения  | Целевой контракт               | Вызывающий контракт             | Вызывающий контракт             |
| Storage              | Целевого контракта             | Вызывающего контракта           | Вызывающего контракта           |
| Передача Ether       | Да                              | Нет                              | Нет                              |
| Применение           | Взаимодействие с внешними контрактами | Прокси-контракты, делегирование логики | Повторное использование кода     |

---

### **5) Примеры использования**

#### **`call`:**
- **Отправка Ether:**
  ```solidity
  (bool success, ) = recipient.call{value: amount}("");
  require(success, "Transfer failed");
  ```

#### **`delegatecall`:**
- **Прокси-контракт:**
  ```solidity
  contract Proxy {
      address public implementation;

      fallback() external payable {
          address(implementation).delegatecall(msg.data);
      }
  }
  ```

#### **Библиотеки:**
- **Безопасные математические операции:**
  ```solidity
  library SafeMath {
      function mul(uint a, uint b) internal pure returns (uint) {
          if (a == 0) return 0;
          uint c = a * b;
          require(c / a == b, "Overflow");
          return c;
      }
  }

  contract Example {
      using SafeMath for uint;

      function multiply(uint a, uint b) public pure returns (uint) {
          return a.mul(b);
      }
  }
  ```

---

### **6) Технические детали на уровне EVM**

#### **`call`:**
- **Опкоды:**
  - `CALL`: Выполняет вызов целевого контракта.
  - `RETURNDATACOPY`: Копирует возвращаемые данные.

#### **`delegatecall`:**
- **Опкоды:**
  - `DELEGATECALL`: Выполняет вызов целевого контракта в контексте вызывающего.
  - `RETURNDATACOPY`: Копирует возвращаемые данные.

#### **Библиотеки:**
- **Опкоды:**
  - `DELEGATECALL`: Используется для выполнения кода библиотеки.
  - `CODECOPY`: Копирует байт-код библиотеки.

---

### **7) Заключение**

`call`, `delegatecall` и библиотеки предоставляют разные способы взаимодействия между контрактами. Каждый метод имеет свои особенности, преимущества и ограничения. Профессиональный подход требует понимания их работы на уровне EVM, включая опкоды, газовые затраты и потенциальные уязвимости.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Что такое delegatecall? Как представлен на уровне EVM? Откуда берется storage, откуда bytecode? Какое значение msg.sender, msg.value внутри вызова delegatecall? Когда стоит применять?]]
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]

---

## Источники
- [Solidity Delegatecall vs Call vs Library](https://www.blocksism.com/blog/solidity-delegatecall-call-library)
- [Understanding Delegatecall in Solidity](https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall)
---