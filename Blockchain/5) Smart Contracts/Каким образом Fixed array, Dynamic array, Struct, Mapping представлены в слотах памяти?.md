
## Короткий ответ

В Solidity `Fixed Array`, `Dynamic Array`, `Struct` и `Mapping` хранятся в слотах памяти (`storage`) по-разному. Фиксированные массивы занимают последовательные слоты, динамические массивы используют указатели, структуры занимают несколько слотов в зависимости от полей, а маппинги распределяются по хэшам ключей. Каждый тип данных имеет свои особенности хранения, которые влияют на производительность и затраты газа.

---

## Подробный разбор

### **Fixed Array (Фиксированный массив)**
1. **Определение:**
   - Фиксированный массив имеет заранее определенный размер, который не может быть изменен после объявления.
   - Элементы массива хранятся последовательно в слотах памяти, начиная с индекса, соответствующего объявлению переменной.

2. **Пример:**
   ```solidity
   uint[3] public fixedArray = [1, 2, 3];
   ```
   - `fixedArray[0]` хранится в слоте `0`.
   - `fixedArray[1]` хранится в слоте `1`.
   - `fixedArray[2]` хранится в слоте `2`.

3. **Технические детали:**
   - Каждый элемент массива занимает один слот памяти (32 байта).
   - Если элементы массива имеют размер меньше 32 байт (например, `uint8`), они могут быть упакованы вместе для экономии места.
   - Упаковка происходит только для элементов одного типа, если они помещаются в один слот.

4. **Особенности:**
   - Занимает фиксированное количество слотов.
   - Удобен для работы с небольшими массивами, так как доступ к элементам быстрый.

5. **Подводные камни:**
   - Если массив слишком большой, он может занимать много слотов, что увеличивает затраты газа.
   - Нельзя изменить размер массива после объявления.
   - Упаковка данных может привести к неожиданным результатам, если не учитывать порядок объявления переменных.

---

### **Dynamic Array (Динамический массив)**
1. **Определение:**
   - Динамический массив может менять размер во время выполнения.
   - Первый слот содержит длину массива, а сами данные хранятся в отдельных слотах, вычисляемых по формуле:
     ```
     keccak256(slot) + index
     ```
     Где:
     - `slot` — номер слота, где хранится указатель на массив.
     - `index` — индекс элемента в массиве.

2. **Пример:**
   ```solidity
   uint[] public dynamicArray;
   ```

   - Первый слот (например, `0`) содержит длину массива.
   - Элементы массива хранятся в слотах, вычисляемых по формуле:
     ```
     keccak256(0) + 0, keccak256(0) + 1, ...
     ```

3. **Технические детали:**
   - Первый слот массива содержит длину массива (`length`).
   - Для каждого элемента массива вычисляется хэш от номера слота массива и добавляется индекс элемента.
   - Например, если массив объявлен в слоте `0`, то первый элемент будет храниться в слоте:
     ```
     keccak256(0) + 0
     ```
     Второй элемент:
     ```
     keccak256(0) + 1
     ```

4. **Особенности:**
   - Гибкость: можно добавлять или удалять элементы.
   - Требует больше газа для управления, особенно при изменении размера.

5. **Подводные камни:**
   - Изменение размера массива может быть дорогостоящим, особенно при добавлении большого количества элементов.
   - При работе с большими массивами важно учитывать ограничения на газ.
   - Обращение к элементам массива требует вычисления хэша, что может быть дорогостоящим.

---

### **Struct (Структура)**
1. **Определение:**
   - Структура — это пользовательский тип данных, который может содержать несколько полей разных типов.
   - Поля структуры занимают последовательные слоты в зависимости от их типа.

2. **Пример:**
   ```solidity
   struct User {
       uint id;
       string name;
   }
   User public user;
   ```

   - `user.id` хранится в слоте `0`.
   - `user.name` хранится в слоте `1` (или более, если строка длинная).

3. **Технические детали:**
   - Каждое поле структуры занимает один или несколько слотов в зависимости от его типа.
   - Если поля имеют размер меньше 32 байт, они могут быть упакованы вместе для экономии места.
   - Строки и динамические массивы внутри структур хранятся как указатели на данные.

4. **Особенности:**
   - Позволяет организовать сложные данные.
   - Может быть частью других структур или массивов.

5. **Подводные камни:**
   - Сложные структуры могут занимать много слотов, что увеличивает затраты газа.
   - При работе с вложенными структурами важно следить за распределением памяти.
   - Упаковка данных может привести к неожиданным результатам, если не учитывать порядок объявления полей.

---

### **Mapping (Маппинг)**
1. **Определение:**
   - Маппинг — это ассоциативный массив, где ключи связаны со значениями.
   - Ключи не хранятся напрямую, а используются для вычисления слотов.

2. **Пример:**
   ```solidity
   mapping(uint => uint) public map;
   ```

   - Номер слота для значения вычисляется по формуле:
     ```
     keccak256(key . slot)
     ```
     Где:
     - `key` — ключ маппинга.
     - `slot` — номер слота, где хранится указатель на маппинг.

3. **Технические детали:**
   - Маппинги не хранят ключи напрямую, а используют их для вычисления хэша.
   - Значения маппинга хранятся в слотах, вычисляемых по формуле:
     ```
     keccak256(abi.encode(key, slot))
     ```
   - Маппинги не поддерживают итерацию, так как ключи не хранятся явно.

4. **Особенности:**
   - Быстрый доступ к данным по ключу.
   - Не требует предварительного выделения памяти.

5. **Подводные камни:**
   - Обращение к несуществующему ключу возвращает дефолтное значение, что может скрывать ошибки.
   - Маппинги не поддерживают итерацию, что может быть ограничением в некоторых случаях.
   - Вычисление хэша для доступа к значению может быть дорогостоящим.

---

### **Пример комбинированного использования**
```solidity
contract Example {
    struct User {
        uint id;
        string name;
    }

    User[] public users; // Динамический массив структур
    mapping(uint => User) public userMap; // Маппинг структур

    function addUser(uint _id, string memory _name) public {
        users.push(User(_id, _name)); // Добавление в массив
        userMap[_id] = User(_id, _name); // Добавление в маппинг
    }
}
```

- В этом примере:
  - `users` — динамический массив структур.
  - `userMap` — маппинг, где ключом является `id`, а значением — структура `User`.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Как расcчитывается номер слота для хранения переменных смарт-контракта?]]
- [[Что такое упаковка структур? Приведите примеры.]]

---

## Источники
- [Solidity Documentation - Layout in Storage](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
- [Understanding Ethereum Storage Layout](https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7)
---
