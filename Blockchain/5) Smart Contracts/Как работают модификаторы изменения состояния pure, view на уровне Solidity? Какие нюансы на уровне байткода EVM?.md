
## Короткий ответ

Модификаторы `pure` и `view` в Solidity определяют, может ли функция изменять состояние контракта. `pure` функции не могут читать или изменять состояние, а `view` функции могут только читать данные. На уровне байт-кода EVM эти модификаторы влияют на способ вызова функций и затраты газа.

---

## Подробный разбор

### **Pure**
1. **Определение:**
   - Функции с модификатором `pure` не могут читать или изменять состояние контракта.
   - Используются для выполнения вычислений, которые зависят только от входных параметров.

2. **Пример:**
   ```solidity
   function add(uint a, uint b) public pure returns (uint) {
       return a + b;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода `pure` функции не имеют доступа к `storage` или другим глобальным переменным контракта.
   - Вызов `pure` функции не требует газа, если она выполняется вне транзакции (например, через `call`).

4. **Особенности:**
   - Полезны для математических вычислений и преобразований данных.
   - Не могут взаимодействовать с состоянием контракта.

5. **Подводные камни:**
   - Попытка чтения или изменения состояния внутри `pure` функции вызовет ошибку компиляции.
   - Некорректное использование может привести к неправильной логике контракта.

---

### **View**
1. **Определение:**
   - Функции с модификатором `view` могут читать состояние контракта, но не могут его изменять.
   - Используются для получения данных из контракта.

2. **Пример:**
   ```solidity
   uint public value = 42;

   function getValue() public view returns (uint) {
       return value;
   }
   ```

3. **Технические детали:**
   - На уровне байт-кода `view` функции имеют доступ к `storage`, но не могут изменять его.
   - Вызов `view` функции не требует газа, если она выполняется вне транзакции (например, через `call`).

4. **Особенности:**
   - Полезны для предоставления доступа к данным контракта.
   - Могут использоваться для проверки условий без изменения состояния.

5. **Подводные камни:**
   - Попытка изменения состояния внутри `view` функции вызовет ошибку компиляции.
   - Некорректное использование может привести к неожиданным результатам при взаимодействии с другими контрактами.

---

### **Нюансы на уровне байт-кода EVM**
1. **Pure Functions:**
   - На уровне байт-кода `pure` функции не содержат операций чтения или записи в `storage`.
   - Выполняются полностью в памяти (`memory`) или стеке (`stack`).

2. **View Functions:**
   - На уровне байт-кода `view` функции могут содержать операции чтения из `storage`.
   - Не содержат операций записи в `storage`.

3. **Gas Costs:**
   - Вызов `pure` и `view` функций не требует газа, если они выполняются вне транзакции (например, через `call`).
   - Если функция вызывается внутри транзакции, она потребляет газ за выполнение операций.

---

### **Пример комбинированного использования**
```solidity
contract Example {
    uint public value = 42;

    function add(uint a, uint b) public pure returns (uint) {
        return a + b; // Pure function
    }

    function getValue() public view returns (uint) {
        return value; // View function
    }

    function setValue(uint _value) public {
        value = _value; // Modifies state
    }
}
```

- В этом примере:
  - `add` — это `pure` функция, которая выполняет вычисления без доступа к состоянию.
  - `getValue` — это `view` функция, которая читает значение переменной `value`.
  - `setValue` изменяет состояние контракта.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Что такое упаковка структур? Приведите примеры.]]
- [[Как работают модификаторы видимости public, private, internal, external на уровне Solidity? Какие нюансы на уровне байткода EVM?]]

---

## Источники
- [Solidity Documentation - Pure and View Functions](https://docs.soliditylang.org/en/latest/contracts.html#pure-functions)
- [Understanding Pure and View Functions in Solidity](https://ethereum.stackexchange.com/questions/91874/what-is-the-difference-between-pure-and-view-functions-in-solidity)
---
