
## Короткий ответ

`msg.sender` и `tx.origin` — это глобальные переменные в Solidity, которые предоставляют информацию о вызывающем адресе. `msg.sender` указывает на непосредственного отправителя транзакции или вызова (может быть контрактом), а `tx.origin` указывает на исходный аккаунт внешнего пользователя (EOA), который инициировал цепочку вызовов.

---

## Подробный разбор

### **Что такое `msg.sender`?**
1. **Определение:**
   - `msg.sender` — это адрес, который непосредственно вызвал текущую функцию.
   - Может быть как внешним аккаунтом (EOA), так и другим смарт-контрактом.

2. **Пример:**
   ```solidity
   contract Example {
       address public caller;

       function setCaller() public {
           caller = msg.sender; // Адрес, который вызвал функцию
       }
   }
   ```

3. **Технические детали:**
   - На уровне EVM `msg.sender` определяется как адрес, который выполнил текущий вызов.
   - Если контракт A вызывает контракт B, то для контракта B `msg.sender` будет адрес контракта A.

4. **Особенности:**
   - Полезен для проверки прав доступа (например, только владелец может вызывать функцию).
   - Может использоваться для взаимодействия с другими контрактами.

5. **Подводные камни:**
   - При использовании `msg.sender` важно учитывать, что вызов может быть выполнен через другой контракт.

---

### **Что такое `tx.origin`?**
1. **Определение:**
   - `tx.origin` — это адрес внешнего аккаунта (EOA), который инициировал всю цепочку вызовов.
   - Всегда является внешним аккаунтом, а не контрактом.

2. **Пример:**
   ```solidity
   contract Example {
       address public origin;

       function setOrigin() public {
           origin = tx.origin; // Адрес внешнего аккаунта, который начал транзакцию
       }
   }
   ```

3. **Технические детали:**
   - На уровне EVM `tx.origin` определяется как адрес внешнего аккаунта, который начал транзакцию.
   - Если контракт A вызывает контракт B, а контракт B вызывает контракт C, то для всех контрактов `tx.origin` будет один и тот же адрес.

4. **Особенности:**
   - Полезен для проверки, что транзакция была инициирована внешним пользователем.
   - Редко используется в современных контрактах из-за потенциальных уязвимостей.

5. **Подводные камни:**
   - Использование `tx.origin` может привести к уязвимостям, связанным с фишингом или подменой вызовов.
   - Не рекомендуется использовать для проверки прав доступа.

---

### **Разница между `msg.sender` и `tx.origin`**
| Характеристика      | `msg.sender`                       | `tx.origin`                        |
|---------------------|------------------------------------|------------------------------------|
| **Определение**     | Непосредственный отправитель вызова | Исходный внешний аккаунт          |
| **Тип адреса**      | Может быть EOA или контрактом      | Всегда EOA                        |
| **Использование**    | Проверка прав доступа             | Определение исходного вызова      |
| **Уязвимости**      | Безопасен при правильном использовании | Может быть уязвимым для атак      |

---

### **Пример комбинированного использования**
```solidity
contract Bank {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function deposit() public payable {
        require(msg.sender == tx.origin, "Direct deposits only");
    }

    function withdraw(uint amount) public {
        require(msg.sender == owner, "Not the owner");
        payable(msg.sender).transfer(amount);
    }
}
```

- В этом примере:
  - Функция `deposit` проверяет, что депозит был выполнен напрямую внешним аккаунтом (используется `tx.origin`).
  - Функция `withdraw` проверяет, что вызывающий является владельцем контракта (используется `msg.sender`).

---

### **Как это работает на уровне EVM?**
1. **`msg.sender`:**
   - На уровне байт-кода `msg.sender` определяется как адрес, который выполнил текущий вызов.
   - Может меняться при каждом новом вызове контракта.

2. **`tx.origin`:**
   - На уровне байт-кода `tx.origin` остается постоянным для всей цепочки вызовов.
   - Указывает на внешний аккаунт, который начал транзакцию.

3. **Gas Costs:**
   - Использование `msg.sender` и `tx.origin` не требует дополнительных затрат газа.

---

### **Пример уязвимости с `tx.origin`**
```solidity
contract Vulnerable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(tx.origin == owner, "Not the owner");
        owner = newOwner;
    }
}
```

- В этом примере:
  - Если злоумышленник создаст контракт, который вызовет функцию `transferOwnership`, то `tx.origin` будет адресом жертвы.
  - Это может привести к передаче владения контрактом злоумышленнику.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Что такое modificator? Как работает на уровне Solidity и EVM?]]
- [[Какова последовательность выполнения кода нескольких модификаторов и тела функции?]]

---

## Источники
- [Solidity Documentation - Global Variables](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#special-variables-and-functions)
- [Understanding msg.sender and tx.origin in Solidity](https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin)
---