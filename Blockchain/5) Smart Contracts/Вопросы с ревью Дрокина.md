### **1) Что такое сложные типы данных?**
- **Определение:**
  - Сложные типы данных — это типы, которые состоят из нескольких элементов или занимают более одного слота памяти. Примеры: массивы (`array`), структуры (`struct`), маппинги (`mapping`), строки (`string`) и байты (`bytes`).
- **На уровне EVM:**
  - Массивы и структуры хранятся в `storage`, где каждый элемент занимает один или несколько слотов.
  - Маппинги используют хэш от ключа и базового слота для вычисления местоположения значения.
  - Опкоды: `SLOAD` и `SSTORE` используются для чтения и записи данных в `storage`.

---

### **2) Какой слот памяти в storage брать в mapping, как хранится, как вычисляется значение (маппинг имеет базовый слот)?**
- **Определение:**
  - Маппинги не хранят данные напрямую в базовом слоте. Вместо этого они используют хэш от ключа и базового слота для вычисления местоположения значения в `storage`.
- **На уровне EVM:**
  - Формула: `keccak256(abi.encode(key, slot))`, где `key` — ключ маппинга, а `slot` — базовый слот.
  - Опкоды: `SHA3` используется для вычисления хэша, а `SLOAD`/`SSTORE` для доступа к данным.

---

### **3) Какие проблемы с заворотом примитивов в структуры данных (аллокация, сколько газа тратится)?**
- **Проблемы:**
  - Заворот примитивов в структуры может привести к увеличению затрат газа из-за неэффективного использования слотов памяти.
  - Если структура не упакована, каждое поле занимает отдельный слот, что увеличивает расходы на запись/чтение.
- **На уровне EVM:**
  - Опкоды: `SSTORE` стоит 20,000 газа за запись нового значения и 5,000 газа за изменение существующего.
  - Упаковка данных снижает количество операций `SSTORE`.

---

### **4) Как десериализируется calldata? Где хранится в транзакции?**
- **Десериализация:**
  - `calldata` десериализуется в формате ABI (Application Binary Interface). Первые 4 байта — это селектор функции, остальные байты — параметры.
- **На уровне EVM:**
  - `calldata` хранится в поле `data` транзакции.
  - Опкоды: `CALLDATALOAD`, `CALLDATASIZE`, `CALLDATACOPY` используются для работы с `calldata`.

---

### **5) Как immutable переменные работают на уровне байткода? Можно ли такие переменные объявить в storage/memory/calldata?**
- **Определение:**
  - Immutable переменные внедряются в байт-код контракта при развертывании. Они могут быть объявлены только в контексте контракта (не в `storage`, `memory` или `calldata`).
- **На уровне EVM:**
  - Immutable переменные хранятся в runtime-коде контракта.
  - Опкоды: `CODECOPY` используется для доступа к значениям immutable переменных.

---

### **6) Где хранятся immutable переменные? Где хранятся константы?**
- **Immutable переменные:**
  - Хранятся в runtime-коде контракта.
- **Константы:**
  - Внедряются непосредственно в байт-код контракта во время компиляции.
- **На уровне EVM:**
  - Immutable: `CODECOPY` для чтения значений.
  - Константы: Значения внедряются в инструкции, такие как `PUSH`.

---

### **7) [https://app.dedaub.com/decompile](https://app.dedaub.com/decompile "https://app.dedaub.com/decompile") Декомпилятор контрактов (вопрос про селекторы)**
- **Определение:**
  - Декомпиляторы, такие как Dedaub, анализируют байт-код контракта для восстановления исходного кода. Селекторы функций (первые 4 байта хэша Keccak-256) помогают идентифицировать функции в байт-коде.
- **На уровне EVM:**
  - Селекторы функций используются в опкоде `CALLVALUE` для вызова соответствующих функций.

---

### **8) Селекторов нет для конструктора, fallback/receive, модификаторы видимости (как именно?) БАЙТКОООООД**
- **Определение:**
  - Селекторы не генерируются для конструктора, так как он выполняется только при развертывании. Для `fallback` и `receive` селекторы также отсутствуют, так как они вызываются без указания конкретной функции.
- **Модификаторы видимости:**
  - `external`: Только извне.
  - `public`: Изнутри и снаружи.
  - `internal`: Только внутри контракта.
  - `private`: Только в текущем контракте.
- **На уровне EVM:**
  - Опкоды: `CALL`, `DELEGATECALL` используются для вызова функций с учетом их видимости.

---

### **9) Private наследники контракта не могут дернуть, а external могут**
- **Определение:**
  - Функции, объявленные как `private`, недоступны для наследников контракта. Функции с модификатором `external` доступны только извне, но могут быть вызваны через интерфейс или адрес контракта.
- **На уровне EVM:**
  - Опкоды: `CALL` используется для вызова `external` функций, а `JUMP` для внутренних вызовов.

---

### **10) Как проверить, что контракт instanceOf другого контракта?**
- **Определение:**
  - Проверка выполняется с помощью сравнения адреса контракта и его ABI.
- **Пример:**
  ```solidity
  function isInstanceOf(address addr) public view returns (bool) {
      return addr.code.length > 0 && addr == address(this);
  }
  ```
- **На уровне EVM:**
  - Опкоды: `EXTCODESIZE` проверяет размер кода контракта.

---

### **11) Как именно работает force eth?**
- **Определение:**
  - Force ETH работает через механизм `selfdestruct`, который отправляет остаточный баланс контракта на указанный адрес.
- **На уровне EVM:**
  - Опкоды: `SELFDESTRUCT` используется для удаления контракта и отправки средств.

---

### **12) Проблема коллизии storage (GAP, unstructured storage)**
- **Определение:**
  - Коллизия storage возникает, когда два контракта используют одинаковые слоты для хранения данных.
- **Решение:**
  - Использование уникальных ключей (например, через `keccak256`) или резервирование слотов (GAP) для предотвращения пересечений.
- **На уровне EVM:**
  - Опкоды: `SLOAD`/`SSTORE` используются для доступа к данным.

---

## Источники
- [Solidity Documentation - Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
- [Understanding Immutable Variables in Solidity](https://ethereum.stackexchange.com/questions/81994/what-is-the-difference-between-fallback-and-receive-functions-in-solidity)
- [Dedaub Decompiler](https://app.dedaub.com/decompile)
---