
## Короткий ответ

Строки в Solidity хранятся как динамические массивы байтов (`bytes`) в `storage`. Они занимают один или несколько слотов в зависимости от длины строки. Для строк короче 32 байт данные хранятся непосредственно в слоте, а для более длинных строк используется указатель на данные.

---

## Подробный разбор

### **Как хранятся строки?**
1. **Определение:**
   - Строка в Solidity — это динамический массив символов, который может изменяться во время выполнения.
   - Строки хранятся в `storage` как последовательность байтов.

2. **Пример:**
   ```solidity
   string public text = "Hello";
   ```

   - Если длина строки меньше или равна 31 байту (учитывая 1 байт для длины), она хранится непосредственно в слоте.
   - Если длина строки больше 31 байта, первый слот содержит указатель на данные, а сами данные хранятся в отдельных слотах.

3. **Технические детали:**
   - **Короткие строки (<= 31 байт):**
     - Данные хранятся непосредственно в слоте.
     - Последний байт слота содержит длину строки.
     - Например, строка `"Hello"` (5 символов) будет храниться в одном слоте:
       ```
       Slot 0: 0x48656c6c6f000000000000000000000000000000000000000000000000000005
       ```
       Где:
       - `48656c6c6f` — это ASCII-коды символов строки.
       - `0000000000000000000000000000000000000000000000000000000000000005` — это длина строки (5).

   - **Длинные строки (> 31 байт):**
     - Первый слот содержит хэш данных строки.
     - Данные строки хранятся в отдельных слотах, вычисляемых по формуле:
       ```
       keccak256(slot)
       ```
       Где `slot` — номер слота, где хранится указатель на строку.
     - Например, строка `"This is a very long string that exceeds 31 bytes"` будет храниться следующим образом:
       - Слот `0`: Хэш данных строки.
       - Слот `keccak256(0)`: Первые 32 байта строки.
       - Слот `keccak256(0) + 1`: Следующие 32 байта строки и т.д.

4. **Особенности:**
   - Строки в Solidity не поддерживают прямую манипуляцию символами (например, доступ к конкретному символу).
   - Работа с длинными строками может быть дорогостоящей, так как требует выделения дополнительной памяти.

5. **Подводные камни:**
   - Изменение строки может быть дорогостоящим, особенно если она длинная.
   - При работе с большими строками важно учитывать ограничения на газ.
   - Обращение к строкам через маппинги или массивы может увеличить затраты газа из-за необходимости вычисления хэшей.

---

### **Пример использования**
```solidity
contract StringExample {
    string public shortString = "Hello"; // Короткая строка
    string public longString = "This is a very long string that exceeds 31 bytes"; // Длинная строка

    function getShortStringLength() public view returns (uint) {
        return bytes(shortString).length; // Возвращает длину строки
    }

    function getLongStringLength() public view returns (uint) {
        return bytes(longString).length; // Возвращает длину строки
    }
}
```

- В этом примере:
  - `shortString` хранится непосредственно в слоте.
  - `longString` использует указатель на данные.

---

## Связанные темы
- [Вернуться к списку вопросов](5.%20Список%20вопросов.md)
- [[Как работают модификаторы изменения состояния pure, view на уровне Solidity? Какие нюансы на уровне байткода EVM?]]
- [[Как расcчитывается номер слота для хранения переменных смарт-контракта?]]
- [[Что такое упаковка структур? Приведите примеры.]]

---

## Источники
- [Solidity Documentation - Strings](https://docs.soliditylang.org/en/latest/types.html#string-literals-and-types)
- [Understanding Ethereum Storage Layout](https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7)
---