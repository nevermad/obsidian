---
title: Как транзакция выполняется на уровне EVM?
tags: [EVM, Ethereum, Транзакции, Выполнение транзакции, State Trie, Gas, Opcodes]
---
## Короткий ответ

EVM выполняет транзакции последовательно, используя **стек**, **память** и **хранилище**. Code storage аккаунта **неизменен**, но storage аккаунта **может изменяться**.

![[Pasted image 20241213174105.png]]
## Подробный разбор

**1. Получение транзакции:**

* **Валидатор**, выбранный протоколом для предложения блока, получает транзакцию из **mempool** (пула транзакций, ожидающих включения в блок).  (см. [[Как консенсус POS определяет активного валидатора  или block proposer?]])
* **Проверка валидности транзакции:** Валидатор проверяет подпись, nonce (номер транзакции для предотвращения повторного использования), достаточный баланс отправителя для оплаты gas fee (комиссии за выполнение транзакции) и корректность формата транзакции.

**2. Выполнение транзакции:**

* **Создание execution environment (среды выполнения):** Для каждой транзакции создается изолированная среда с собственным  **стеком**,  **памятью** и доступом к **глобальному состоянию** блокчейна.
* **Gas Metering:**  EVM отслеживает потребление во время выполнения.  Если gas исчерпан, транзакция отменяется (reverted). (см. [[В чем различие Gas Price и Gas Limit?]])
* **Выполнение опкодов:** Транзакция, содержащая **bytecode**, декодируется в последовательность опкодов - элементарные инструкции для EVM.  EVM выполняет эти опкоды последовательно, изменяя состояние среды выполнения.
* **Изменение State Trie:** Если транзакция изменяет состояние блокчейна (например,  перевод Ether, изменение данных в storage контракта),  эти изменения записываются в  **State Trie**  -  Merkle Patricia Trie,  представляющее глобальное состояние.  (см. [[Расскажите об основных компонентах EVM? Какие сущности существуют постоянно, какие временно? Расскажите о их жизненном цикле.]])


**3. Code Storage и Storage аккаунта:**

* **Code Storage:** Code storage аккаунта, содержащий bytecode смарт-контракта,  **неизменен**.  Транзакция не может изменить код уже развернутого контракта. (см. [[Можно ли изменить код контракта?]])
* **Storage:**  Storage аккаунта, постоянная область хранения для смарт-контрактов,   **может изменяться** в результате выполнения транзакции.  Запись данных в storage потребляет gas. (см. [[Расскажите о свойствах, особенностях, ограничениях, времени жизни информации, каким образом структурирован storage.]])


**4. Результат транзакции:**

* **Успешное выполнение:**  Если транзакция выполнена успешно,  изменения state  записываются в блок,  и gas fee перечисляется майнеру.
* **Ошибка (Revert):** Если во время выполнения произошла ошибка (например, не хватило gas,  ошибка в коде контракта),  транзакция отменяется,  изменения state откатываются,  но gas fee все равно списывается.

**5. Разница между revert и assert транзакции:**

`revert` и `assert` - это инструкции в Solidity, которые используются для обработки ошибок и остановки выполнения контракта.  Они оба откатывают все изменения состояния, сделанные в текущей транзакции, и возвращают оставшийся газ отправителю. Однако, они предназначены для разных типов ошибок и имеют разные способы использования:

**`assert`:**

* **Предназначение:**  `assert` используется для обнаружения **внутренних ошибок** в контракте. Это ситуации, которые **никогда не должны происходить** при правильной работе контракта.  Примеры:
    * Деление на ноль.
    * Переполнение или выход за границы массива.
    * Вызов функции с некорректными аргументами.
* **Gas:** `assert` потребляет **весь оставшийся газ** транзакции.
* **Индикация ошибки:**  `assert`  сигнализирует о критической ошибке в логике контракта, которая требует немедленного исправления.


**`revert`:**

* **Предназначение:** `revert` используется для обработки **ошибок, которые могут возникнуть в результате взаимодействия с контрактом**, например:
    * Недостаточный баланс пользователя.
    * Некорректные входные данные от пользователя.
    * Невыполнение определенных условий, необходимых для выполнения операции.
* **Gas:** `revert` возвращает **оставшийся газ** отправителю.
* **Индикация ошибки:**  `revert` сигнализирует о том, что операция не может быть выполнена по какой-либо причине, но это не обязательно означает критическую ошибку в коде контракта.  `revert` может сопровождаться сообщением об ошибке, которое поясняет причину отката.  Начиная с Solidity 0.8.4,  можно использовать `Custom Errors` для более эффективного и информативного описания ошибок.


**В чем ключевая разница?**

Главное отличие между `assert` и `revert` заключается в их **предназначении** и **способе использования газа**:

* **`assert`** для **критических внутренних ошибок**, которые указывают на баги в коде контракта. Он потребляет весь газ, чтобы четко сигнализировать о серьезной проблеме.
* **`revert`** для **обработки ожидаемых ошибок**, которые могут возникнуть в результате взаимодействия с контрактом. Он возвращает оставшийся газ, так как эти ошибки не обязательно являются результатом багов в коде.

**Когда использовать `assert`?**

* Проверка инвариантов (условий, которые всегда должны быть истинными).
* Проверка условий, нарушение которых свидетельствует о серьезной ошибке в логике контракта.
* Тестирование кода контракта (для проверки того, что код работает как ожидается).

**Когда использовать `revert`?**

* Валидация входных данных от пользователя.
* Проверка условий, необходимых для выполнения операции (например, проверка баланса).
* Обработка ошибок, которые могут возникнуть при взаимодействии с другими контрактами.
* Сигнализация об ошибках пользователю с помощью сообщений или Custom Errors.

**Пример:**

```solidity
function withdraw(uint256 amount) public {
    require(amount <= balances[msg.sender], "Insufficient balance"); // revert если баланс недостаточен
    balances[msg.sender] -= amount;
    payable(msg.sender).transfer(amount);  // Если transfer не удастся, он автоматически вызовет revert
}

function divide(uint256 a, uint256 b) internal pure returns (uint256) {
   assert(b != 0); // assert если b равно нулю - это критическая ошибка
    return a / b;
}
```


Правильное использование `assert` и `revert`  повышает безопасность и надежность смарт-контрактов, облегчает отладку и делает код более понятным.

## Связанные темы

* [Вернуться к списку вопросов](4.%20Список%20вопросов.md)
* [[Что такое газ?]]
* [[В чем различие Gas Price и Gas Limit?]]
* [[Расскажите об основных компонентах EVM? Какие сущности существуют постоянно, какие временно? Расскажите о их жизненном цикле.]]
* [[Расскажите о свойствах, особенностях, ограничениях, времени жизни информации, каким образом структурирован storage.]]

## Источники

* [Ethereum Documentation - EVM](https://ethereum.org/en/developers/docs/evm/)
* [Yellow Paper - EVM](https://ethereum.github.io/yellowpaper/paper.pdf#page=12)


---