---
title: Можно ли сделать контракт изменяемым?
tags: [EVM, Ethereum, Smart Contract, Изменчивость кода, Безопасность, Proxy Pattern]
---

## Короткий ответ

Напрямую изменить код развернутого контракта нельзя. Однако, можно использовать паттерны проектирования, такие как **Proxy Pattern**, для создания контрактов с обновляемой логикой.


## Подробный разбор

Хотя код смарт-контракта в Ethereum неизменен после развертывания, существуют способы создания контрактов с обновляемой логикой.  Один из наиболее распространенных подходов - это **Proxy Pattern (паттерн прокси)**.

**Как работает Proxy Pattern?**

1. **Proxy Contract:** Развертывается proxy-контракт, который выступает в качестве посредника.  Этот контракт содержит адрес **implementation contract (контракта реализации)**,  в котором находится actual code (фактический код) с логикой.

2. **Implementation Contract:**  Этот контракт содержит actual code (фактический код)  смарт-контракта и может быть обновлен.

3. **Взаимодействие:**  Когда пользователь взаимодействует с proxy-контрактом, proxy перенаправляет вызовы в implementation contract.

4. **Обновление:** Для обновления логики,  развертывается **новый implementation contract**  с измененным кодом.  Затем в proxy-контракте **изменяется адрес**,  на который он ссылается,  указывая на новый implementation contract.


**Другие подходы:**

* **Upgradeable Contracts:**  Существуют библиотеки и фреймворки, которые предоставляют инструменты для создания upgradable contracts (обновляемых контрактов).

#### Уточнения

**1) Как меняется адрес в прокси контракте?**

Вы правы, код самого прокси-контракта также неизменен после развертывания.  Ключ в том, что адрес implementation contract хранится не непосредственно в коде, а **в storage (хранилище)** прокси-контракта. Storage, в отличие от кода, может быть изменен.

Обычно в прокси-контракте есть специальная функция, например, `upgradeTo(newImplementationAddress)`, которая доступна только **владельцу** или **администратору** прокси.  Эта функция изменяет значение переменной в storage, которая хранит адрес implementation contract, на новый адрес.

**Пример (упрощенный):**

```solidity
pragma solidity ^0.8.0;

contract Proxy {
    address public implementation;

    constructor(address _implementation) {
        implementation = _implementation;
    }

    function upgradeTo(address newImplementation) public onlyOwner {
        implementation = newImplementation;
    }

    fallback() external payable {
        (bool success, bytes memory result) = implementation.delegatecall(msg.data);
        require(success, "Delegatecall failed");
        assembly {
            returndataoffset := 0
            returndatasize := mload(result)
            return(add(32, result), mload(result))
        }
    }
}
```

В этом примере, функция `upgradeTo` меняет значение переменной `implementation` в storage контракта.  `fallback` функция использует `delegatecall`, чтобы перенаправить все вызовы на текущий implementation contract.  `delegatecall`  критически важен, так как он выполняет код implementation contract **в контексте прокси-контракта**,  позволяя implementation contract изменять storage прокси.


**2) Подробнее про upgradable contracts на solidity**

Существует несколько популярных библиотек и фреймворков для создания upgradable contracts в Solidity:

* **OpenZeppelin Upgrades:**  Один из наиболее известных и хорошо документированных инструментов. Предлагает различные паттерны для обновления, включая UUPS (Unstructured Storage Proxy) и Transparent Proxy.  Обеспечивает безопасность и удобство использования.

* **Truffle Upgrades:** Плагин для Truffle framework, который упрощает процесс развертывания и обновления контрактов.  Интегрируется с OpenZeppelin Upgrades.


**Основные принципы upgradable contracts:**

* **Разделение логики и данных:**  Код, который может быть обновлен, отделяется от данных контракта.

* **Прозрачность для пользователей:**  Пользователи взаимодействуют с прокси-контрактом, не зная о существовании implementation contract.

* **Управление доступом:**  Обновление контракта должно быть доступно только авторизованным лицам.

* **Тестирование:**  Upgradable contracts требуют более тщательного тестирования, чтобы убедиться в корректности работы после обновления.


**Выбор подхода:**

Выбор между ручным использованием Proxy Pattern и использованием библиотек зависит от сложности проекта и требований к безопасности. Библиотеки, такие как OpenZeppelin Upgrades, предоставляют проверенные и безопасные решения, но могут добавить некоторую сложность в проект.  Ручная реализация Proxy Pattern дает больше гибкости, но требует глубокого понимания принципов работы и повышенного внимания к безопасности.


**Важно:**

Использование паттернов для создания изменяемых контрактов вносит **дополнительную сложность** и может повлиять на **безопасность**.  Необходимо тщательно продумать архитектуру и учесть потенциальные риски.


## Связанные темы

* [Вернуться к списку вопросов](4.%20Список%20вопросов.md)
* [[Можно ли изменить код контракта?]]
* [[Какие преимущества и недостатки есть у неизменности контрактов?]]
* [[Proxy Pattern]]


---